[
  {
    "title": "토스테크",
    "url": "https://toss.tech/rss.xml",
    "items": [
      {
        "title": "Simplicity 4 : AI 아바타가 발표하는 온라인 컨퍼런스 제작기",
        "link": "https://toss.tech/article/simplicity_behind",
        "pubDate": "Thu, 01 May 2025 09:48:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1e6a360d-33e3-8027-b8bf-fe251b990150\" class=\"css-14on8x8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">Simplicity는 더 나은 사용자 경험을 만들기 위해, </span><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">토스가 치열하게 고민해온 과정을 나누는 디자인 컨퍼런스</span><span class=\"css-1kxrhf3\">예요. 우리의 실험과 시도들이 사용자 경험을 고민하는 다른 디자이너들에게도 영감이 되기를 바라며 시작했어요. </span></span></span></p><p id=\"1e6a360d-33e3-8088-812e-c1f27f51d427\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">2021년부터 토스 디자인 챕터가 정기적으로 개최하고 있죠. 내용뿐 아니라 메시지를 어떻게 전달할지도 늘 중요하게 여겼기 때문에, 2023년부터는 유튜브 영상이 아닌 웹 기반 인터랙티브 사이트로 전환해 운영하고 있어요.</span></span></span></p><p id=\"1e6a360d-33e3-802a-84b6-c6fb826ca28b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css 1c1qox8\">.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}</style><h2 id=\"1e6a360d-33e3-80da-aeb9-e7d8f3701fb1\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><style data-emotion=\"css p4abj2\">.css-p4abj2{display:contents;line-height:1.55;}</style><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">지속 가능한 컨퍼런스 만들기</span></span></span></h2><p id=\"1e6a360d-33e3-8092-b5d1-df6361ccd5ab\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">디자인 챕터에게 심플리시티는 거의 종합 예술에 가까운 프로젝트예요. </span><span class=\"css-q3ktjb\">운영, 디자인, 개발, 대본, 촬영, 녹음, 홍보까지</span><span class=\"css-1kxrhf3\">—모든 과정이 고도화된 협업으로 이루어지죠.</span></span></span></p><p id=\"1e6a360d-33e3-80e4-ac96-ec3e2e2a3cee\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">한 번으로 끝나는 행사가 아니라, </span><span class=\"css-q3ktjb\">매년 반복되는 시즌제 컨퍼런스</span><span class=\"css-1kxrhf3\">이기 때문에 ‘지속 가능성’이 정말 중요한 주제였어요. 매년 </span><span class=\"css-q3ktjb\">퀄리티와 지속 가능성 사이의 균형</span><span class=\"css-1kxrhf3\">을 고민해야 했죠. 그 과정에서 많은 부분을 효율적으로 만들어왔지만, </span><span class=\"css-q3ktjb\">촬영만큼은 늘 어려운 과제</span><span class=\"css-1kxrhf3\">였어요.</span></span></span></p><p id=\"1e6a360d-33e3-80f8-8aa3-c3f19a4067aa\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">촬영을 하려면 대본이 완성되어야 하는데, 그 과정만 무려 두 달이 넘게 걸려요. 내부 피드백, 법무·보안·개인정보 검토를 거치며 수차례 수정되고, 최종적으로는 발표자 톤에 맞춰 구어체로 다시 다듬어야 하거든요. 대본이 늦어지면 촬영도 늦어지고, 전체 일정이 밀리기도 하죠.</span></span></span></p><p id=\"1e6a360d-33e3-8018-a383-ea5d3aa96c20\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그런데 이게 끝이 아니에요. 혹여라도 대본상의 문제를 나중에 발견하게 되면, 다시 촬영을 해야 해야 하거든요.</span><span class=\"css-q3ktjb\"> </span><span class=\"css-1kxrhf3\">촬영은 디자인 챕터의 전문 영역이 아니라 항상 외부 전문가나 다른 팀의 도움을 받아야 하는 구조적 제약도 있었죠. </span></span></span></p><p id=\"1e6a360d-33e3-80e4-8db8-c56c2f53485e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1e6a360d-33e3-8032-ab6f-d0ce86af8152\" class=\"css-of5acw\"><style data-emotion=\"css 1pgssrp\">.css-1pgssrp{max-width:100%;border-radius:16px;}</style><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/e78ebb66-4999-4dd7-92c4-a1093ed62a3a/image.png\" alt=\"\" class=\"css-1pgssrp\"/><style data-emotion=\"css wgpbp3\">.css-wgpbp3{display:block;margin-top:6px;}</style><figcaption class=\"css-wgpbp3\"><style data-emotion=\"css 18442ym\">.css-18442ym{font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}</style><style data-emotion=\"css jfs1hr\">.css-jfs1hr{white-space:pre-wrap;font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}</style><span class=\"css-jfs1hr\">전문가의 도움을 받아 촬영한 24년 심플리시티 중 한 장면</span></figcaption></figure><p id=\"1e6a360d-33e3-80b8-b210-d53f0fc7edfc\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1e6a360d-33e3-80e6-925b-d4b6adf5f769\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">더 큰 문제는, 발표 경험이 익숙하지 않은 연사들에게도 부담이 컸다는 거예요.</span><span class=\"css-1kxrhf3\"> 실제로 워크숍에서 연사자들이 가장 꺼리는 일로 “발표하기, 촬영하기, 녹음하기”를 꼽았을 정도였죠. 컨퍼런스인데, 발표가 가장 하기 싫다니—아이러니하죠?</span></span></span></p><p id=\"1e6a360d-33e3-803b-b5fa-db32643a88e8\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그래서 자연스럽게 이런 질문이 생겼어요</span></span></span></p><style data-emotion=\"css 2sk6rv\">.css-2sk6rv{font-size:19px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);white-space:pre-wrap;margin:24px 0;padding-left:20px;position:relative;}.css-2sk6rv::before{content:'';display:block;position:absolute;top:4px;left:0;width:2px;height:calc(100% - 4px * 2);padding:4px 0;background-color:var(--adaptiveGrey800);}</style><blockquote id=\"1e6a360d-33e3-8076-8241-d124517f3c7f\" class=\"css-2sk6rv\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">지속가능한 컨퍼런스를 만들기 위해서는, \n촬영 프로세스부터 바꿔야 하지 않을까?</span></span></span><style data-emotion=\"css 7mseny\">.css-7mseny>*{margin-left:0;margin-right:0;}.css-7mseny>:last-child{margin-bottom:0;}blockquote>.css-7mseny:first-child>:first-child{margin-top:0;}</style></blockquote><p id=\"1e6a360d-33e3-809b-a061-fbb85a352781\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css 1ifza5r\">.css-1ifza5r{border:0;margin-top:0;margin-bottom:0;height:1px;opacity:1;background:var(--tHairlineBackground);margin:0;}</style><hr class=\"css-1ifza5r\"/><p id=\"1e6a360d-33e3-8054-8660-cbff4af7cc18\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1e6a360d-33e3-803e-a19e-ff5200e46931\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-q3ktjb\">AI 아바타가 발표한다면</span></span></span></h2><p id=\"1e6a360d-33e3-8028-ada9-ce52893594ee\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그래서 이번 시즌에는 새로운 방식을 시도했어요. </span><span class=\"css-q3ktjb\">AI 아바타가 발표를 대신해보는 실험</span><span class=\"css-1kxrhf3\">이었죠. 혹시 눈치채신 분 계실까요?</span></span></span></p><p id=\"1e6a360d-33e3-8046-9058-d85721576975\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">간단할 거라고 생각했지만, 막상 해보니 쉽지만은 않았어요. AI 서비스들의 한국어 지원이 매끄럽지 않아서, 자연스러운 음성을 만들기가 어려웠거든요. 그래서 여러 번 테스트를 거쳐, 최적의 방법을 찾아냈어요.</span></span></span></p><style data-emotion=\"css nv7vyi\">.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}</style><aside class=\"css-nv7vyi\"><div class=\"css-1vn47db\"><style data-emotion=\"css hokoge\">.css-hokoge{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;counter-reset:numberedList;}.css-hokoge ul,.css-hokoge ol{margin:16px 0 0;}.css-hokoge>li{counter-increment:numberedList;margin-bottom:16px;padding-left:24px;}.css-hokoge>li:last-of-type{margin-bottom:0;}.css-hokoge>li>span{position:relative;}.css-hokoge>li>span>:first-child::before{content:counter(numberedList) '.';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ol class=\"css-hokoge\"><style data-emotion=\"css 1hwiibq\">.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}</style><li id=\"1e6a360d-33e3-80a1-94ca-c5fb2ff48f58\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">연사자의 음성을 녹음</span><span class=\"css-1kxrhf3\">한 뒤, </span><style data-emotion=\"css iynyr0\">.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}</style><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.elevenlabs.io/\">ElevenLabs</a><span class=\"css-1kxrhf3\">에서 대본 기반으로 AI 발표 음성을 생성</span></span></span></li><li id=\"1e6a360d-33e3-80e3-9176-da53ba3a5590\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">연사자가 말하는 영상</span><span class=\"css-1kxrhf3\">을 촬영해 </span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.heygen.com/\">Heygen</a><span class=\"css-1kxrhf3\">에서 AI 아바타를 생성</span></span></span></li><li id=\"1e6a360d-33e3-8043-a864-f44efe69f188\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">1번에서 만든 음성을 Heygen에 입력해</span><span class=\"css-1kxrhf3\">, AI 아바타가 발표하는 최종 영상으로 출력</span></span></span></li></ol></div></aside><p id=\"1e6a360d-33e3-80bb-9250-deedf5d239b3\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><figure id=\"1e6a360d-33e3-8054-90a3-d53d5f54f063\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/ff5e8566-0460-436c-a569-bd1fcfca4742/AI서비스.png\" alt=\"\" class=\"css-1pgssrp\"/><figcaption class=\"css-wgpbp3\"><span class=\"css-jfs1hr\">로고 출처 : 일레븐랩스와 헤이젠 공식 홈페이지</span></figcaption></figure><p id=\"1e6a360d-33e3-80bf-9b57-d5115cba0161\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1e6a360d-33e3-80ce-bb3a-ee21480c9f0b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">기존의 방식이라면 연사자는 발표 내용을 자연스럽게 말하기 위해 여러 번 연습하고, 촬영 중간에 한 번이라도 말을 더듬거나 버벅이면 처음부터 다시 찍어야 했어요. 하지만 이번에는 딱 한 번만 찍어도 AI 아바타를 만드는 데 충분했어요.</span></span></span></p><p id=\"1e6a360d-33e3-80f3-bf14-c152a0cd7b6e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">촬영 자체도 훨씬 간편해졌어요. </span><span class=\"css-q3ktjb\">AI 아바타 생성을 위한 학습용 데이터</span><span class=\"css-1kxrhf3\">로만 쓰이다 보니, 연사자가 회의실에 들어와서 나갈 때까지 30분이면 촬영이 끝났거든요.</span></span></span></p><p id=\"1e6a360d-33e3-8091-8043-ec2f2bbb39a0\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">덕분에 연사자의 부담은 확 줄었고, 일정도 유연하게 조율할 수 있었어요. 심지어 오픈을 </span><span class=\"css-q3ktjb\">일주일 앞두고도 대본 수정이 가능한 정도</span><span class=\"css-1kxrhf3\">였죠.</span></span></span></p><p id=\"1e6a360d-33e3-80a1-844b-cd7cd6a27274\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">촬영은 어떻게 했냐고요? 아마 들으면 깜짝 놀라실 거예요. 스튜디오도, 전문 장비도 없었어요. 회의실에서, 아이폰 전면 카메라로, 스노우 앱을 켜고 녹화했거든요. 말 그대로 셀카 찍듯 촬영했죠.</span></span></span></p><p id=\"1e6a360d-33e3-80f6-935b-e933b24dce7f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">처음에는 전문 장비를 갖춰서 촬영해보기도 했지만, 오히려 익숙하지 않아 결과물이 더 어색하더라고요. 그래서 여러 번 시도해 본 끝에, 지금의 제약 안에서도 원하는 결과를 만들 수 있는 가장 효율적인 방식을 찾아냈어요. </span></span></span></p><p id=\"1e6a360d-33e3-80f8-8cc4-cb72adc16336\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><figure id=\"1e6a360d-33e3-8023-bcb3-f0307435fcdd\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/228c4470-c858-408e-98c0-5174d7a53110/image.png\" alt=\"\" class=\"css-1pgssrp\"/><figcaption class=\"css-wgpbp3\"><span class=\"css-jfs1hr\">회의실에서 촬영하는 모습</span></figcaption></figure><p id=\"1e6a360d-33e3-80f8-8085-e226077c309c\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1e6a360d-33e3-80fb-aece-d76f5f6d7f3a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">물론 지금 저희가 만든 AI 아바타가 실제 사람에 비해 어색한 부분도 있지만, 기술이 워낙 빠르게 발전하고 있어서 앞으로 훨씬 더 자연스럽게 될 것 같아요. 그리고 이 방식보다 더 효율적인 방법이 많이 생겨나겠죠.</span></span></span></p><p id=\"1e6a360d-33e3-804e-930c-d1e5a845e816\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><figure id=\"1e6a360d-33e3-80a3-8af5-c937463b7835\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/c2871aaf-0461-4871-a872-fcb541914192/image.png\" alt=\"\" class=\"css-1pgssrp\"/><figcaption class=\"css-wgpbp3\"><span class=\"css-jfs1hr\">노트북으로 촬영 모니터링하는 장면</span></figcaption></figure><figure id=\"1e6a360d-33e3-80b1-9f95-c5c25d00fb61\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/473f066a-e36d-4627-b7a2-82e2a144a450/ScreenRecording_05-01-2025_19-45-37_1.gif\" alt=\"\" class=\"css-1pgssrp\"/><figcaption class=\"css-wgpbp3\"><span class=\"css-jfs1hr\">경태님의 AI아바타가 대신 발표하는 모습</span></figcaption></figure><h2 id=\"1e6a360d-33e3-80f0-ad6a-d3832987f7cc\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">시청 경험까지 새롭게</span></span></span></h2><p id=\"1e6a360d-33e3-8020-a87d-fa7f42210724\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이번 시즌에서는 AI 아바타 외에도 </span><span class=\"css-q3ktjb\">시청 경험 자체를 더 나아지게 만들기 위한 변화</span><span class=\"css-1kxrhf3\">들이 있었어요.</span></span></span></p><style data-emotion=\"css 1feg9au\">.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}</style><h3 id=\"1e6a360d-33e3-80d8-8298-ea967f3bda26\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">1. 모바일 최적화</span></span></span></h3><p id=\"1e6a360d-33e3-803f-a122-d09bb915c53b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">2023년에는 데스크탑으로 시청하는 사용자가 많았지만, 2024년에는 </span><span class=\"css-q3ktjb\">모바일 사용자 비율이 크게 늘었어요.</span></span></span></p><p id=\"1e6a360d-33e3-8002-b539-d1df59ab1410\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">데스크탑 환경이 아닌 숏폼 형식으로 콘텐츠를 소비하는 게 적합한 것 같았죠. 그래서 이번엔 처음부터 모바일 중심으로 화면과 인터페이스를 설계했어요. “</span><style data-emotion=\"css 1odxvuk\">.css-1odxvuk{white-space:pre-wrap;font-style:italic;}</style><span class=\"css-1odxvuk\">숏츠 보는 것 같았다</span><span class=\"css-1kxrhf3\">”고 느꼈다면, 저희가 의도한 바를 정확히 느끼신 거예요. 실제로 데스크탑 디자인은 모바일 디자인을 완성한 이후에 제작되었어요.</span></span></span></p><figure id=\"1e6a360d-33e3-803e-97e1-ce4e61d65807\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/6301a8b8-286b-49d6-91ea-d018ab9d0fb9/ScreenRecording_05-01-2025_10-00-20_1.gif\" alt=\"\" class=\"css-1pgssrp\"/><figcaption class=\"css-wgpbp3\"><span class=\"css-jfs1hr\">화면 터치만으로 탐색이 가능한 모바일 화면</span></figcaption></figure><figure id=\"1e6a360d-33e3-8006-834e-d9dbb084ab70\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/f83ed677-5ca1-49f8-a50b-172e4e579922/pc-flow-3.gif\" alt=\"\" class=\"css-1pgssrp\"/><figcaption class=\"css-wgpbp3\"><span class=\"css-jfs1hr\">화면 탐색 기능이 하단 버튼으로 있는 데스크탑 화면</span></figcaption></figure><p id=\"1e6a360d-33e3-80ae-b2c9-da913b178348\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1e6a360d-33e3-8090-8b08-ec2ed0193237\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1e6a360d-33e3-80b0-a884-e1c3aec47a29\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">2. 콘텐츠 길이 최적화</span></span></span></h3><p id=\"1e6a360d-33e3-80de-bafe-fc7bef8d5597\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">지난 시즌 평균 시청 시간이 3분 정도였어요. 그래서 이번에는 세션이 너무 길지 않도록 모두 </span><span class=\"css-q3ktjb\">5분 이하</span><span class=\"css-1kxrhf3\">로 구성했어요. 짧지만 명확한 메시지를 전하기 위해 </span><span class=\"css-q3ktjb\">이미지 자료나 구성도 더욱 정교하게 다듬었죠. </span><span class=\"css-1kxrhf3\">그래서일까요? 지난 시즌에는 평균 완독률이 12% 정도였는데, 이번에는 51%를 넘었어요.</span></span></span></p><figure id=\"1e6a360d-33e3-800a-9027-cfc4db2304b3\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/0f4db019-264b-4961-b5a8-9df87477c733/pc-flow-4.gif\" alt=\"\" class=\"css-1pgssrp\"/><figcaption class=\"css-wgpbp3\"><span class=\"css-jfs1hr\">[토스가 디자인 툴을 만든 이유] 중 한 장면</span></figcaption></figure><p id=\"1e6a360d-33e3-8060-a279-cb3674b02f95\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1e6a360d-33e3-805a-876b-e23324f50b91\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">3. 세션별 특색 강화</span></span></span></h3><p id=\"1e6a360d-33e3-8086-a490-ea4f7a87ed83\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">커버 이미지, 배경 음악, 메인 컬러까지—각 세션마다 모두 다르게 설정했어요. </span><span class=\"css-q3ktjb\">음악만 듣거나 커버만 봐도 어떤 세션인지 연상할 수 있도록,</span><span class=\"css-1kxrhf3\"> 개성과 몰입감을 중요하게 생각했어요.</span></span></span></p><figure id=\"1e6a360d-33e3-800c-b0d0-c324066f14f1\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/86dd8506-195a-4786-b343-5ad0ed9c2bab/Comp_1_(1).gif\" alt=\"\" class=\"css-1pgssrp\"/><figcaption class=\"css-wgpbp3\"><span class=\"css-jfs1hr\">세션별 모션 그래픽</span></figcaption></figure><p id=\"1e6a360d-33e3-80c6-aec5-d460108da4f2\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1e6a360d-33e3-80d1-80ed-e6cb877c2b3e\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-q3ktjb\">앞으로의 심플리시티</span></span></span></h2><p id=\"1e6a360d-33e3-80d6-a020-e6667c47f870\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이번 시즌을 계기로, Simplicity는 단순 온라인 컨퍼런스가 아니라 콘텐츠 플랫폼으로써 </span><span class=\"css-q3ktjb\">더 효율적이고 지속 가능한 형태</span><span class=\"css-1kxrhf3\">로 진화했어요.  기존처럼 시즌마다 새로운 사이트를 만드는 방식에서 벗어나, 앞으로는 </span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://toss.im/simplicity/\">https://toss.im/simplicity/</a><span class=\"css-q3ktjb\"> 에 시즌별로 콘텐츠가 업데이트</span><span class=\"css-1kxrhf3\">될 예정이에요. </span></span></span></p><p id=\"1e6a360d-33e3-80b7-be37-d84917359c69\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그리고 이 변화는 이번 시즌 4의 주인공이기도 </span><span class=\"css-q3ktjb\">UX플랫폼 조직의 노력</span><span class=\"css-1kxrhf3\">으로 만들어졌어요. </span></span></span></p><p id=\"1e6a360d-33e3-80ba-9339-dc6bf63dc807\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그래픽 디자이너, 인터랙션 디자이너, 플랫폼 디자이너, UX 엔지니어, UX라이터 등 UX 플랫폼 조직의 많은 팀의 협업이 있었기에 가능한 일이었죠. 곧 각 팀의 시선에서 바라본 Simplicity 제작 비하인드도 소개해드릴게요.</span></span></span></p><p id=\"1e6a360d-33e3-80f4-af4d-ccfcd77d6a06\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이번 저희의 실험을, 부디 재미있게 지켜봐주세요!</span></span></span></p><p id=\"1e6a360d-33e3-80f0-a625-c04a2e85e69e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1e6a360d-33e3-8035-9953-ef60fc5a75a2\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://toss.im/simplicity\">심플리시티 시즌 4 보러가기 &gt;</a></span></span></p><p id=\"1e6a360d-33e3-8005-923d-e8eef0e6ed30\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-1kxrhf3{white-space:pre-wrap;}Simplicity는 더 나은 사용자 경험을 만들기 위해, .css-q3ktjb{white-space:pre-wrap;font-weight:bold;}토스가 치열하게 고민해온 과정을 나누는 디자인 컨퍼런스예요. 우리의 실험과 시도들이 사용자 경험을 고민하는 다른 디자이너들에게도 영감이 되기를 바라며 시작했어요. \n2021년부터 토스 디자인 챕터가 정기적으로 개최하고 있죠. 내용뿐 아니라 메시지를 어떻게 전달할지도 늘 중요하게 여겼기 때문에, 2023년부터는 유튜브 영상이 아닌 웹 기반 인터랙티브 사이트로 전환해 운영하고 있어요.\n\n.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}\n.css-p4abj2{display:contents;line-height:1.55;}지속 가능한 컨퍼런스 만들기\n디자인 챕터에게 심플리시티는 거의 종합 예술에 가까운 프로젝트예요. 운영, 디자인, 개발, 대본, 촬영, 녹음, 홍보까지—모든 과정이 고도화된 협업으로 이루어지죠.\n한 번으로 끝나는 행사가 아니라, 매년 반복되는 시즌제 컨퍼런스이기 때문에 ‘지속 가능성’이 정말 중요한 주제였어요. 매년 퀄리티와 지속 가능성 사이의 균형을 고민해야 했죠. 그 과정에서 많은 부분을 효율적으로 만들어왔지만, 촬영만큼은 늘 어려운 과제였어요.\n촬영을 하려면 대본이 완성되어야 하는데, 그 과정만 무려 두 달이 넘게 걸려요. 내부 피드백, 법무·보안·개인정보 검토를 거치며 수차례 수정되고, 최종적으로는 발표자 톤에 맞춰 구어체로 다시 다듬어야 하거든요. 대본이 늦어지면 촬영도 늦어지고, 전체 일정이 밀리기도 하죠.\n그런데 이게 끝이 아니에요. 혹여라도 대본상의 문제를 나중에 발견하게 되면, 다시 촬영을 해야 해야 하거든요. 촬영은 디자인 챕터의 전문 영역이 아니라 항상 외부 전문가나 다른 팀의 도움을 받아야 하는 구조적 제약도 있었죠. \n\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}.css-wgpbp3{display:block;margin-top:6px;}.css-18442ym{font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}.css-jfs1hr{white-space:pre-wrap;font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}전문가의 도움을 받아 촬영한 24년 심플리시티 중 한 장면\n\n더 큰 문제는, 발표 경험이 익숙하지 않은 연사들에게도 부담이 컸다는 거예요. 실제로 워크숍에서 연사자들이 가장 꺼리는 일로 “발표하기, 촬영하기, 녹음하기”를 꼽았을 정도였죠. 컨퍼런스인데, 발표가 가장 하기 싫다니—아이러니하죠?\n그래서 자연스럽게 이런 질문이 생겼어요\n.css-2sk6rv{font-size:19px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);white-space:pre-wrap;margin:24px 0;padding-left:20px;position:relative;}.css-2sk6rv::before{content:'';display:block;position:absolute;top:4px;left:0;width:2px;height:calc(100% - 4px * 2);padding:4px 0;background-color:var(--adaptiveGrey800);}\n지속가능한 컨퍼런스를 만들기 위해서는, \n촬영 프로세스부터 바꿔야 하지 않을까?.css-7mseny>*{margin-left:0;margin-right:0;}.css-7mseny>:last-child{margin-bottom:0;}blockquote>.css-7mseny:first-child>:first-child{margin-top:0;}\n\n.css-1ifza5r{border:0;margin-top:0;margin-bottom:0;height:1px;opacity:1;background:var(--tHairlineBackground);margin:0;}\n\nAI 아바타가 발표한다면\n그래서 이번 시즌에는 새로운 방식을 시도했어요. AI 아바타가 발표를 대신해보는 실험이었죠. 혹시 눈치채신 분 계실까요?\n간단할 거라고 생각했지만, 막상 해보니 쉽지만은 않았어요. AI 서비스들의 한국어 지원이 매끄럽지 않아서, 자연스러운 음성을 만들기가 어려웠거든요. 그래서 여러 번 테스트를 거쳐, 최적의 방법을 찾아냈어요.\n.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}\n.css-hokoge{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;counter-reset:numberedList;}.css-hokoge ul,.css-hokoge ol{margin:16px 0 0;}.css-hokoge>li{counter-increment:numberedList;margin-bottom:16px;padding-left:24px;}.css-hokoge>li:last-of-type{margin-bottom:0;}.css-hokoge>li>span{position:relative;}.css-hokoge>li>span>:first-child::before{content:counter(numberedList) '.';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\n연사자의 음성을 녹음한 뒤, .css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}ElevenLabs에서 대본 기반으로 AI 발표 음성을 생성\n연사자가 말하는 영상을 촬영해 Heygen에서 AI 아바타를 생성\n1번에서 만든 음성을 Heygen에 입력해, AI 아바타가 발표하는 최종 영상으로 출력\n\n\n\n로고 출처 : 일레븐랩스와 헤이젠 공식 홈페이지\n\n기존의 방식이라면 연사자는 발표 내용을 자연스럽게 말하기 위해 여러 번 연습하고, 촬영 중간에 한 번이라도 말을 더듬거나 버벅이면 처음부터 다시 찍어야 했어요. 하지만 이번에는 딱 한 번만 찍어도 AI 아바타를 만드는 데 충분했어요.\n촬영 자체도 훨씬 간편해졌어요. AI 아바타 생성을 위한 학습용 데이터로만 쓰이다 보니, 연사자가 회의실에 들어와서 나갈 때까지 30분이면 촬영이 끝났거든요.\n덕분에 연사자의 부담은 확 줄었고, 일정도 유연하게 조율할 수 있었어요. 심지어 오픈을 일주일 앞두고도 대본 수정이 가능한 정도였죠.\n촬영은 어떻게 했냐고요? 아마 들으면 깜짝 놀라실 거예요. 스튜디오도, 전문 장비도 없었어요. 회의실에서, 아이폰 전면 카메라로, 스노우 앱을 켜고 녹화했거든요. 말 그대로 셀카 찍듯 촬영했죠.\n처음에는 전문 장비를 갖춰서 촬영해보기도 했지만, 오히려 익숙하지 않아 결과물이 더 어색하더라고요. 그래서 여러 번 시도해 본 끝에, 지금의 제약 안에서도 원하는 결과를 만들 수 있는 가장 효율적인 방식을 찾아냈어요. \n\n회의실에서 촬영하는 모습\n\n물론 지금 저희가 만든 AI 아바타가 실제 사람에 비해 어색한 부분도 있지만, 기술이 워낙 빠르게 발전하고 있어서 앞으로 훨씬 더 자연스럽게 될 것 같아요. 그리고 이 방식보다 더 효율적인 방법이 많이 생겨나겠죠.\n\n노트북으로 촬영 모니터링하는 장면경태님의 AI아바타가 대신 발표하는 모습\n시청 경험까지 새롭게\n이번 시즌에서는 AI 아바타 외에도 시청 경험 자체를 더 나아지게 만들기 위한 변화들이 있었어요.\n.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}\n1. 모바일 최적화\n2023년에는 데스크탑으로 시청하는 사용자가 많았지만, 2024년에는 모바일 사용자 비율이 크게 늘었어요.\n데스크탑 환경이 아닌 숏폼 형식으로 콘텐츠를 소비하는 게 적합한 것 같았죠. 그래서 이번엔 처음부터 모바일 중심으로 화면과 인터페이스를 설계했어요. “.css-1odxvuk{white-space:pre-wrap;font-style:italic;}숏츠 보는 것 같았다”고 느꼈다면, 저희가 의도한 바를 정확히 느끼신 거예요. 실제로 데스크탑 디자인은 모바일 디자인을 완성한 이후에 제작되었어요.\n화면 터치만으로 탐색이 가능한 모바일 화면화면 탐색 기능이 하단 버튼으로 있는 데스크탑 화면\n\n\n2. 콘텐츠 길이 최적화\n지난 시즌 평균 시청 시간이 3분 정도였어요. 그래서 이번에는 세션이 너무 길지 않도록 모두 5분 이하로 구성했어요. 짧지만 명확한 메시지를 전하기 위해 이미지 자료나 구성도 더욱 정교하게 다듬었죠. 그래서일까요? 지난 시즌에는 평균 완독률이 12% 정도였는데, 이번에는 51%를 넘었어요.\n[토스가 디자인 툴을 만든 이유] 중 한 장면\n\n3. 세션별 특색 강화\n커버 이미지, 배경 음악, 메인 컬러까지—각 세션마다 모두 다르게 설정했어요. 음악만 듣거나 커버만 봐도 어떤 세션인지 연상할 수 있도록, 개성과 몰입감을 중요하게 생각했어요.\n세션별 모션 그래픽\n\n앞으로의 심플리시티\n이번 시즌을 계기로, Simplicity는 단순 온라인 컨퍼런스가 아니라 콘텐츠 플랫폼으로써 더 효율적이고 지속 가능한 형태로 진화했어요.  기존처럼 시즌마다 새로운 사이트를 만드는 방식에서 벗어나, 앞으로는 https://toss.im/simplicity/ 에 시즌별로 콘텐츠가 업데이트될 예정이에요. \n그리고 이 변화는 이번 시즌 4의 주인공이기도 UX플랫폼 조직의 노력으로 만들어졌어요. \n그래픽 디자이너, 인터랙션 디자이너, 플랫폼 디자이너, UX 엔지니어, UX라이터 등 UX 플랫폼 조직의 많은 팀의 협업이 있었기에 가능한 일이었죠. 곧 각 팀의 시선에서 바라본 Simplicity 제작 비하인드도 소개해드릴게요.\n이번 저희의 실험을, 부디 재미있게 지켜봐주세요!\n\n심플리시티 시즌 4 보러가기 >",
        "content": "알고 보면 더 재미있어요. 심플리시티 시즌 4의 흥미로운 제작기를 소개합니다.",
        "contentSnippet": "알고 보면 더 재미있어요. 심플리시티 시즌 4의 흥미로운 제작기를 소개합니다.",
        "guid": "https://toss.tech/article/simplicity_behind",
        "isoDate": "2025-05-01T09:48:00.000Z"
      },
      {
        "title": "Simplicity 4 : 한 번쯤 이상을 꿈꿔본 모두에게",
        "link": "https://toss.tech/article/35921",
        "pubDate": "Thu, 24 Apr 2025 13:30:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css 1c1qox8\">.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}</style><h2 id=\"1dfa360d-33e3-8042-877e-e12f8499adf1\" class=\"css-1c1qox8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css p4abj2\">.css-p4abj2{display:contents;line-height:1.55;}</style><span class=\"css-p4abj2\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">토스 디자인 컨퍼런스 네 번째 이야기, </span><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">Simplicity 4</span></span></span></h2><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1dfa360d-33e3-8097-baa6-d8e433897ca3\" class=\"css-of5acw\"><style data-emotion=\"css 1pgssrp\">.css-1pgssrp{max-width:100%;border-radius:16px;}</style><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/5f5c0cab-0bbf-4802-9be6-88e97ae3af34/image.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1dfa360d-33e3-8066-a19d-d4800bbd1475\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dfa360d-33e3-8008-9e16-f5323a81c805\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">일하면서 한 번쯤, 이상을 꿈꿔본 적이 있나요? </span></span></span></p><p id=\"1dfa360d-33e3-8094-8574-d7d47b97ee32\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">빠른 문제해결이 중요한 토스에서도, 그 너머의 이상을 그리는 사람들이 있어요. 디자이너, 리서처, 라이터, 엔지니어링 등 다양한 분야에서 정교하고 아름다운 UX를 실현하기 위해 새로운 시도를 이어가고 있죠.하지만 현실은 쉽지만은 않아요. </span></span></span></p><p id=\"1dfa360d-33e3-80f0-9721-ee29001ac54e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이번 시즌에서는, </span><span class=\"css-q3ktjb\">일하는 누구나 꿈꿔본 이상을 현실로 만들기 위해 고군분투한 토스팀의 여정을 들려드려요. </span><span class=\"css-1kxrhf3\">우리는 어떤 고민을 했고, 어떻게 답을 찾았을까요? </span></span></span></p><p id=\"1dfa360d-33e3-8033-af43-e283bc3148eb\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그래픽, 인터랙션, 엔지니어링, UX 라이팅, 리서치, 플랫폼 디자인까지, 총 14개의 이야기가 준비되어 있어요. 잠깐 들여다보실래요?</span></span></span></p><p id=\"1dfa360d-33e3-80ef-be6f-f7fb4b39d467\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dfa360d-33e3-80a5-83f1-d82a6416817b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css 1ifza5r\">.css-1ifza5r{border:0;margin-top:0;margin-bottom:0;height:1px;opacity:1;background:var(--tHairlineBackground);margin:0;}</style><hr class=\"css-1ifza5r\"/><p id=\"1dfa360d-33e3-8032-bb96-cbb3824d5711\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1dfa360d-33e3-8050-8f88-c71e29c63ebd\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">토스다움을 완성하는 순간들</span></span></span></h2><p id=\"1dfa360d-33e3-8056-a6c5-e0b78e1d25ad\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css 1feg9au\">.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}</style><h3 id=\"1dfa360d-33e3-80dd-a05a-fab4d6479195\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">이토록 아름다운 새로고침 </span></span></span></h3><p id=\"1dfa360d-33e3-80cb-b8b8-cbe129ad628a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Graphic Design</span></span></span></p><p id=\"1dfa360d-33e3-8004-b8a6-c68acfc61ae5\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">화면을 아래로 당기면 나오는 그래픽, Pull To Refresh. 그 짧은 찰나에 아름다움을 담기 위한 고민을 들려드려요.</span></span></span></p><p id=\"1dfa360d-33e3-80fd-ac31-e93228dc3707\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-80ae-a1ad-f286018f3fb7\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">인터랙션으로 첫인상 만들기 </span></span></span></h3><p id=\"1dfa360d-33e3-80aa-83c0-caf31c894a1b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Interaction Design </span></span></span></p><p id=\"1dfa360d-33e3-806f-8945-cbc6ef46dce2\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스를 처음 써보는 외국인에게 토스를 어떻게 소개해야 할까? 모두가 감탄한 온보딩, 그 중심에는 인터랙션이 있었어요.</span></span></span></p><p id=\"1dfa360d-33e3-805c-9465-e0581cb800d3\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-80fe-9c8c-eb9b88d1f12d\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">토스 그래픽 더 토스답게 만들기 </span></span></span></h3><p id=\"1dfa360d-33e3-80e4-aaa7-c7fdc14f4b10\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Graphic Design</span></span></span></p><p id=\"1dfa360d-33e3-808b-9936-f6a354ba68db\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">IT 업계에 3D 그래픽이 넘쳐나는 시대. 토스는 어떻게 &#x27;토스다움&#x27;을 만들어냈을까요? 그 여정을 보여드려요.</span></span></span></p><p id=\"1dfa360d-33e3-8096-b78f-ead192ad7164\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-801b-aa11-d9cc7af8890d\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">디자인 조직의 개발자들 </span></span></span></h3><p id=\"1dfa360d-33e3-808b-8fbd-d32eff6d25e0\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Android, FE, iOS </span></span></span></p><p id=\"1dfa360d-33e3-80de-b8b0-c1d4e99f2758\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">인터랙션 개발의 매력은 무엇일까요? 아름다움과 감각을 설계하는 세 명의 인터랙션 개발자가 답해드릴게요.</span></span></span></p><p id=\"1dfa360d-33e3-80de-981a-f449c366c0d8\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dfa360d-33e3-8088-94dd-f08838e6716d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><hr class=\"css-1ifza5r\"/><p id=\"1dfa360d-33e3-8038-b5a4-c0420176b1a9\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1dfa360d-33e3-80ff-9025-d226b4050fa2\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">진짜 ‘모두’를 위한 유니버셜 UX</span></span></span></h2><p id=\"1dfa360d-33e3-8017-9c5c-e43c542e13bc\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-8051-8450-ee0b85903077\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">진짜 모두를 위한 금융 </span></span></span></h3><p id=\"1dfa360d-33e3-8060-b4d1-df5976e16804\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Universal Design</span></span></span></p><p id=\"1dfa360d-33e3-808f-8906-cc71ce205d5c\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">2,800만 명이 쓰는 앱에서 7,000명의 스크린 리더 사용자 경험까지 챙기기 위해, 토스는 어떤 노력을 하고 있을까요?</span></span></span></p><p id=\"1dfa360d-33e3-8074-8ccd-fd5e0c4e30aa\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-804e-85aa-d9aba649a3c4\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">우리가 몰랐던 시각 장애인의 UX </span></span></span></h3><p id=\"1dfa360d-33e3-8099-8d80-dd8993ac0573\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">UX Research</span></span></span></p><p id=\"1dfa360d-33e3-80a2-b1d2-d6b1cc270ed1\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">시각 장애인이 토스를 더 쉽게 쓰려면, 무엇이 달라져야 할까요? 리서치를 통해 얻은 세 가지 인사이트를 공유할게요.</span></span></span></p><p id=\"1dfa360d-33e3-805c-8c07-f3b02a4905c8\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dfa360d-33e3-801c-94b7-d9ce7cd8e694\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><hr class=\"css-1ifza5r\"/><p id=\"1dfa360d-33e3-80c9-8b27-d75d21ba6eb5\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1dfa360d-33e3-80f9-9871-ef0b85cd0e79\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">토스가 사용자 경험과 마주하는 법</span></span></span></h2><p id=\"1dfa360d-33e3-805a-bcde-d340b55739d9\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-805f-a6f7-e4c34c09fc63\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">경험을 수치화하는 방법 </span></span></span></h3><p id=\"1dfa360d-33e3-805a-bebf-cbb7b4637bb7\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">UX Research</span></span></span></p><p id=\"1dfa360d-33e3-8078-9052-ee206faf049e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">사용자가 원하는 기능을 잘 찾는지, 정성적인 경험도 이제 수치로 말할 수 있어요. 토스만의 새로운 기준으로요.</span></span></span></p><p id=\"1dfa360d-33e3-80e8-ad78-f534f20e0912\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-80ef-a22f-c591207d7186\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">모두가 유저를 만나는 순간까지 </span></span></span></h3><p id=\"1dfa360d-33e3-809b-a96a-e162a06b1477\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">UX Research</span></span></span></p><p id=\"1dfa360d-33e3-80ce-b4b8-f65ebbd8e9f9\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">일하느라 사용자를 만날 시간이 없다면, 점심시간은 어떨까요? 식사하며 사용자의 목소리를 듣는 토스 팀의 이야기를 들려드릴게요.</span></span></span></p><p id=\"1dfa360d-33e3-803e-93c9-d63decc5eb22\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dfa360d-33e3-808b-8ee1-e0ba9e987d88\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><hr class=\"css-1ifza5r\"/><p id=\"1dfa360d-33e3-8026-909b-d05e29f304dd\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1dfa360d-33e3-80e8-8ed6-c6ef89c4a3cc\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">UX가 AI를 만났을 때</span></span></span></h2><p id=\"1dfa360d-33e3-80aa-991c-f0e9a182725e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-8037-b4ec-edcbfab5e6bf\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">AI시대에 라이터로 살아남기 </span></span></span></h3><p id=\"1dfa360d-33e3-8093-945f-d2f73c2c134a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">UX Writing</span></span></span></p><p id=\"1dfa360d-33e3-805b-9228-d643907637c9\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">AI는 UX라이터에게 위기이자 기회예요.\n다크패턴을 계기로, 라이터에서 프롬프트 엔지니어로 성장한 이야기를 들려드려요.</span></span></span></p><p id=\"1dfa360d-33e3-806b-9f56-d8a5ebfbf464\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-805a-81ef-c35066db8851\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">AI봇을 만들면서 배운 3가지 </span></span></span></h3><p id=\"1dfa360d-33e3-801b-9bab-e4180d402e77\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">UX Research</span></span></span></p><p id=\"1dfa360d-33e3-8072-9a04-d7c31ac0df87\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">사용자를 만나기 전에 가볍게 의견을 물어볼 수 있는 AI UT봇. ‘휴리봇’ 을 만들면서 배운 3가지들 알려드릴게요.</span></span></span></p><p id=\"1dfa360d-33e3-80ec-be11-ca971734fcb1\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-8039-b45a-ead1463d85f8\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">토스 그래픽을 10초 만에 그리는 AI </span></span></span></h3><p id=\"1dfa360d-33e3-80ad-a458-ef6d9cb315a8\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Graphic Design</span></span></span></p><p id=\"1dfa360d-33e3-8023-8b22-c247e4f643fb\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">‘토스트’를 소개합니다. 인간이 3일 걸려 만드는 3D 그래픽을 10초 만에 만든다니, 퀄리티까지 따라올 수 있을까요? </span></span></span></p><p id=\"1dfa360d-33e3-8037-9b13-ec8c7254d94f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dfa360d-33e3-8058-a7ed-f74c6ab6ca6c\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><hr class=\"css-1ifza5r\"/><p id=\"1dfa360d-33e3-807b-a567-fbdfc2414f21\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1dfa360d-33e3-8025-9e07-efc674c61180\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">익숙함 너머, 본질을 보다</span></span></span></h2><p id=\"1dfa360d-33e3-805f-9e2d-e86d43f29129\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-80b5-8bdf-f65a27574b6d\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">동의 화면도 간결해질 수 있을까 </span></span></span></h3><p id=\"1dfa360d-33e3-805d-8da6-e17eff58f4ee\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Interaction Design </span></span></span></p><p id=\"1dfa360d-33e3-80da-9585-fde46ed3331b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">각종 법적 제한 때문에 자유롭지 않은 동의 화면 디자인. 관성을 깨면 얼마나 달라질 수 있을까요?</span></span></span></p><p id=\"1dfa360d-33e3-8061-b333-f2a1a9a65c93\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-8087-b0cc-f6d492f2f4aa\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">토스가 디자인툴을 만든 이유 </span></span></span></h3><p id=\"1dfa360d-33e3-80d2-aeba-f0cc092ba3dd\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">UX Engineering </span></span></span></p><p id=\"1dfa360d-33e3-808a-a25b-c118e173f2e3\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">스케치, 피그마, 프레이머… 모두 써봤지만 우리에게 딱 맞는 건 없었어요. 그래서 만들었습니다. 토스만의 디자인 툴, 데우스.</span></span></span></p><p id=\"1dfa360d-33e3-8004-9948-f10a2a6e75a1\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dfa360d-33e3-8081-bef9-cd7aafdc1c43\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">아무도 쓰지 않는 디자인 시스템 </span></span></span></h3><p id=\"1dfa360d-33e3-80be-8f05-c6f1d675e204\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Platform Design</span></span></span></p><p id=\"1dfa360d-33e3-805e-84a9-c76549300340\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">새로운 컴포넌트를 배포했는데, 왜 아무도 안 쓰지? 컴포넌트를 넘어서, 일하는 방식 자체를 바꿔보기로 했어요.</span></span></span></p><p id=\"1dfa360d-33e3-8096-9c87-dd9ec018d586\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><hr class=\"css-1ifza5r\"/><h2 id=\"1dfa360d-33e3-80e1-8642-feb3243c665b\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">Vision Driven Design</span></span></span></h2><p id=\"1dfa360d-33e3-8015-a245-f249ba1b62bd\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Simplicity 4는 거창한 해답보다는, </span><span class=\"css-q3ktjb\">현실 속에서도 이상을 놓지 않으려 한 태도에 대해 이야기 하려고 해요. </span><span class=\"css-1kxrhf3\">&quot;정말 이런 게 가능할까?&quot; 싶은 순간에도 끝까지 답을 찾으려고 한 사람들의 이야기. 그리고 그 집요함이 만들어낸 </span><span class=\"css-q3ktjb\">변화</span><span class=\"css-1kxrhf3\">를 들려드리고 싶었어요. 토스는 어떻게 상상 속에만 있던 UX를 현실로 만들어냈는지, 그 과정을 함께 즐겨주세요. </span></span></span></p><p id=\"1dfa360d-33e3-801d-b1af-c1940ec918a5\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dfa360d-33e3-80f3-bff1-e2f42f59df4a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css 1b8s8vi\">.css-1b8s8vi{white-space:pre-wrap;cursor:pointer;color:#fe9800;-webkit-text-decoration:underline!important;text-decoration:underline!important;font-weight:bold;}</style><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-1b8s8vi\" href=\"https://toss.im/simplicity-register\">Simplicity 알림 신청하기 &gt;&gt; </a></span></span></p><p id=\"1dfa360d-33e3-8070-81e1-eb04a6c249d9\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dfa360d-33e3-808c-8ca8-ec56d7885674\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">여러분이 가장 기대되는 세션은 무엇인가요? 댓글로 남겨주세요 !</span></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-p4abj2{display:contents;line-height:1.55;}.css-1kxrhf3{white-space:pre-wrap;}토스 디자인 컨퍼런스 네 번째 이야기, .css-q3ktjb{white-space:pre-wrap;font-weight:bold;}Simplicity 4\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1iisb9p{display:contents;line-height:1.6;}\n일하면서 한 번쯤, 이상을 꿈꿔본 적이 있나요? \n빠른 문제해결이 중요한 토스에서도, 그 너머의 이상을 그리는 사람들이 있어요. 디자이너, 리서처, 라이터, 엔지니어링 등 다양한 분야에서 정교하고 아름다운 UX를 실현하기 위해 새로운 시도를 이어가고 있죠.하지만 현실은 쉽지만은 않아요. \n이번 시즌에서는, 일하는 누구나 꿈꿔본 이상을 현실로 만들기 위해 고군분투한 토스팀의 여정을 들려드려요. 우리는 어떤 고민을 했고, 어떻게 답을 찾았을까요? \n그래픽, 인터랙션, 엔지니어링, UX 라이팅, 리서치, 플랫폼 디자인까지, 총 14개의 이야기가 준비되어 있어요. 잠깐 들여다보실래요?\n\n\n.css-1ifza5r{border:0;margin-top:0;margin-bottom:0;height:1px;opacity:1;background:var(--tHairlineBackground);margin:0;}\n\n토스다움을 완성하는 순간들\n\n.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}\n이토록 아름다운 새로고침 \nGraphic Design\n화면을 아래로 당기면 나오는 그래픽, Pull To Refresh. 그 짧은 찰나에 아름다움을 담기 위한 고민을 들려드려요.\n\n인터랙션으로 첫인상 만들기 \nInteraction Design \n토스를 처음 써보는 외국인에게 토스를 어떻게 소개해야 할까? 모두가 감탄한 온보딩, 그 중심에는 인터랙션이 있었어요.\n\n토스 그래픽 더 토스답게 만들기 \nGraphic Design\nIT 업계에 3D 그래픽이 넘쳐나는 시대. 토스는 어떻게 '토스다움'을 만들어냈을까요? 그 여정을 보여드려요.\n\n디자인 조직의 개발자들 \nAndroid, FE, iOS \n인터랙션 개발의 매력은 무엇일까요? 아름다움과 감각을 설계하는 세 명의 인터랙션 개발자가 답해드릴게요.\n\n\n\n\n진짜 ‘모두’를 위한 유니버셜 UX\n\n진짜 모두를 위한 금융 \nUniversal Design\n2,800만 명이 쓰는 앱에서 7,000명의 스크린 리더 사용자 경험까지 챙기기 위해, 토스는 어떤 노력을 하고 있을까요?\n\n우리가 몰랐던 시각 장애인의 UX \nUX Research\n시각 장애인이 토스를 더 쉽게 쓰려면, 무엇이 달라져야 할까요? 리서치를 통해 얻은 세 가지 인사이트를 공유할게요.\n\n\n\n\n토스가 사용자 경험과 마주하는 법\n\n경험을 수치화하는 방법 \nUX Research\n사용자가 원하는 기능을 잘 찾는지, 정성적인 경험도 이제 수치로 말할 수 있어요. 토스만의 새로운 기준으로요.\n\n모두가 유저를 만나는 순간까지 \nUX Research\n일하느라 사용자를 만날 시간이 없다면, 점심시간은 어떨까요? 식사하며 사용자의 목소리를 듣는 토스 팀의 이야기를 들려드릴게요.\n\n\n\n\nUX가 AI를 만났을 때\n\nAI시대에 라이터로 살아남기 \nUX Writing\nAI는 UX라이터에게 위기이자 기회예요.\n다크패턴을 계기로, 라이터에서 프롬프트 엔지니어로 성장한 이야기를 들려드려요.\n\nAI봇을 만들면서 배운 3가지 \nUX Research\n사용자를 만나기 전에 가볍게 의견을 물어볼 수 있는 AI UT봇. ‘휴리봇’ 을 만들면서 배운 3가지들 알려드릴게요.\n\n토스 그래픽을 10초 만에 그리는 AI \nGraphic Design\n‘토스트’를 소개합니다. 인간이 3일 걸려 만드는 3D 그래픽을 10초 만에 만든다니, 퀄리티까지 따라올 수 있을까요? \n\n\n\n\n익숙함 너머, 본질을 보다\n\n동의 화면도 간결해질 수 있을까 \nInteraction Design \n각종 법적 제한 때문에 자유롭지 않은 동의 화면 디자인. 관성을 깨면 얼마나 달라질 수 있을까요?\n\n토스가 디자인툴을 만든 이유 \nUX Engineering \n스케치, 피그마, 프레이머… 모두 써봤지만 우리에게 딱 맞는 건 없었어요. 그래서 만들었습니다. 토스만의 디자인 툴, 데우스.\n\n아무도 쓰지 않는 디자인 시스템 \nPlatform Design\n새로운 컴포넌트를 배포했는데, 왜 아무도 안 쓰지? 컴포넌트를 넘어서, 일하는 방식 자체를 바꿔보기로 했어요.\n\n\nVision Driven Design\nSimplicity 4는 거창한 해답보다는, 현실 속에서도 이상을 놓지 않으려 한 태도에 대해 이야기 하려고 해요. \"정말 이런 게 가능할까?\" 싶은 순간에도 끝까지 답을 찾으려고 한 사람들의 이야기. 그리고 그 집요함이 만들어낸 변화를 들려드리고 싶었어요. 토스는 어떻게 상상 속에만 있던 UX를 현실로 만들어냈는지, 그 과정을 함께 즐겨주세요. \n\n.css-1b8s8vi{white-space:pre-wrap;cursor:pointer;color:#fe9800;-webkit-text-decoration:underline!important;text-decoration:underline!important;font-weight:bold;}Simplicity 알림 신청하기 >> \n\n여러분이 가장 기대되는 세션은 무엇인가요? 댓글로 남겨주세요 !",
        "content": "토스 디자인 컨퍼런스 Simplicity가 돌아왔어요.",
        "contentSnippet": "토스 디자인 컨퍼런스 Simplicity가 돌아왔어요.",
        "guid": "https://toss.tech/article/35921",
        "isoDate": "2025-04-24T13:30:00.000Z"
      },
      {
        "title": "토스는 어떻게 광고를 보여줄까? 토스애즈 ML 톺아보기",
        "link": "https://toss.tech/article/ads-ml",
        "pubDate": "Mon, 21 Apr 2025 13:13:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1dca360d-33e3-80b9-8a35-ec779b9eeeb5\" class=\"css-14on8x8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">안녕하세요, 토스 Ads Performance 팀 ML Engineer 김영호입니다.</span></span></span></p><p id=\"1dca360d-33e3-80c5-bed2-e12e9086597a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스앱 진입 시 확인하실 수 있는 다양한 광고들은 어떤 과정을 거쳐 유저에게 노출될까요? 이 글에서는 토스 광고 추천 시스템의 전체 흐름과 그 안의 머신러닝 활용 방식을 소개해 드리겠습니다.</span></span></span></p><p id=\"1dca360d-33e3-80b7-9d34-feec8ee1cd09\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dca360d-33e3-80d9-a23d-db0b7bc99bb4\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">웹사이트나 앱에서 볼 수 있는 대부분의 광고는 실시간 입찰 방식을 통해 노출됩니다. 매체에서 광고 지면에 노출 기회가 발생하면 해당 정보를 광고주에게 전달하고, 광고주는 기회에 대한 가치를 평가해 자신이 지불할 금액을 산정하여 입찰에 참여하죠. 제출된 입찰가 중 가장 높은 금액을 제시한 광고주의 광고가 최종적으로 해당 지면에 노출됩니다.</span></span></span></p><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1dda360d-33e3-8027-97ac-de1b4f48331f\" class=\"css-of5acw\"><style data-emotion=\"css 1pgssrp\">.css-1pgssrp{max-width:100%;border-radius:16px;}</style><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/1fd7b63a-8bdf-4a8f-87f6-24eb94938121/tech-0422-tech-ad-inner-1.png\" alt=\"\" class=\"css-1pgssrp\"/><style data-emotion=\"css wgpbp3\">.css-wgpbp3{display:block;margin-top:6px;}</style><figcaption class=\"css-wgpbp3\"><style data-emotion=\"css 18442ym\">.css-18442ym{font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}</style><style data-emotion=\"css jfs1hr\">.css-jfs1hr{white-space:pre-wrap;font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}</style><span class=\"css-jfs1hr\">[그림 1] 실시간 입찰 (출처: </span><style data-emotion=\"css 114ityv\">.css-114ityv{white-space:pre-wrap;cursor:pointer;-webkit-text-decoration:underline!important;text-decoration:underline!important;font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}</style><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-114ityv\" href=\"https://www.appsflyer.com/ko/glossary/real-time-bidding/\">appsflyer</a><span class=\"css-jfs1hr\">)</span></figcaption></figure><p id=\"1dca360d-33e3-8069-a04e-d0ec93ae0a81\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">실시간 입찰에는 여러 광고 플랫폼이 관여하는데요, 대표적으로 SSP(Supply-Side Platform)와 DSP(Demand-Side Platform)가 있습니다. 이 둘은 실시간 입찰 과정에서 유기적으로 연동되어 매체에 안정적인 수익을, 광고주에는 효율적인 광고 집행 및 성과 최적화를 제공합니다.</span></span></span></p><style data-emotion=\"css uswsmm\">.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ul class=\"css-uswsmm\"><style data-emotion=\"css 1hwiibq\">.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}</style><li id=\"1dca360d-33e3-8019-a24d-f89ea43b817e\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">SSP</span><span class=\"css-1kxrhf3\">: 매체가 보유한 지면을 효율적으로 관리・판매하도록 돕는 플랫폼입니다. 광고 노출 기회마다 자동으로 여러 DSP를 연결하여 최적의 입찰을 유도함으로써 매체 수익을 극대화합니다. </span></span></span></li><li id=\"1dca360d-33e3-806f-8c62-f1467420c969\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">DSP</span><span class=\"css-1kxrhf3\">: 광고주를 대신해 실시간 입찰에 참여하며, 설정된 예산과 목표에 따라 최소 비용으로 최대 광고 성과를 달성하도록 돕는 플랫폼입니다.</span></span></span></li></ul><p id=\"1dca360d-33e3-80d6-bd05-ec231718f67b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스는 리스트・모먼트 배너 등 다양한 광고 지면을 보유한 매체이자, 토스애즈 플랫폼을 통해 광고주가 토스 앱 내에서 손쉽게 광고를 집행하고 최적화할 수 있는 환경을 제공합니다. 따라서 광고 요청부터 노출까지의 모든 과정이 토스 내에서 이루어지죠.</span></span></span></p><p id=\"1dca360d-33e3-80b1-adb8-f681077beee7\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css 1feg9au\">.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}</style><h3 id=\"1dca360d-33e3-80bf-ab4b-c2dd82f64b1c\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">유저 접속부터 광고 노출까지</span></span></span></h3><p id=\"1dca360d-33e3-805c-a981-ccc7e32cc777\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">유저가 광고 지면이 있는 토스 앱 화면에 접속하면 광고 요청이 발생하고, 입찰을 통해 최적의 광고가 선정되어 노출됩니다. 이 과정은 크게 </span><span class=\"css-q3ktjb\">Targeting, Filtering, Ranking</span><span class=\"css-1kxrhf3\">의 세 단계로 이루어지며, 각 단계에서 머신러닝이 활용돼요.</span></span></span></p><p id=\"1dca360d-33e3-80e2-816d-f9b106cd3b66\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dca360d-33e3-80cb-881b-c3935f32f94d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">1. Targeting</span></span></span></p><p id=\"1dca360d-33e3-80cd-ab30-daac52b78263\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">유저 정보를 기반으로 노출할 광고를 선별하는 과정이에요. 광고주마다 캠페인 목표와 원하는 타겟 유저가 다르기 때문에, 광고 노출 대상인 유저가 설정된 타겟에 포함되는지 확인합니다. 포함되지 않을 경우 해당 광고는 제외돼요.</span></span></span></p><p id=\"1dca360d-33e3-806a-aef1-ca94f61fb71a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">성별, 연령대, 직업 등의 특성을 바탕으로 유저를 세분화하여 광고를 집행하는 전략을 </span><span class=\"css-q3ktjb\">오디언스 타겟팅(Audience Targeting)</span><span class=\"css-1kxrhf3\">이라고 합니다. 광고주는 인구통계학적 정보만으로도 타겟팅 그룹을 만들 수 있지만, 많은 광고주들은 자신의 상품을 구매한 유저와 유사한 특성을 지닌 잠재 고객을 타겟팅하고 싶어하죠.</span></span></span></p><p id=\"1dca360d-33e3-8028-a855-e1d5335afb6f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이러한 니즈를 충족시키기 위해 </span><span class=\"css-q3ktjb\">Lookalike 모델</span><span class=\"css-1kxrhf3\">을 활용해 광고주가 타겟으로 설정한 오디언스와 행동 패턴이 유사한 잠재 고객을 찾습니다. 유저의 행동 로그를 학습하거나 Two-tower 모델을 통해 유저와 광고 간의 상호작용을 학습하여 유저 임베딩을 생성하고, 주어진 오디언스와의 임베딩 유사도를 계산해 잠재 고객을 선별해요.</span></span></span></p><figure id=\"1dda360d-33e3-80e7-95a6-c44f6494176d\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/b0f0fac2-172c-4165-9ca3-fdec19bb5c3e/tech-0422-tech-ad-inner-2.png\" alt=\"\" class=\"css-1pgssrp\"/><figcaption class=\"css-wgpbp3\"><span class=\"css-jfs1hr\">[그림 2] Lookalike 모델 (출처: </span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-114ityv\" href=\"https://blog.developer.adobe.com/look-alike-audiences-ai-enabled-audience-expansion-in-real-time-cdp-e143a1ce93de\">Adobe Tech Blog</a><span class=\"css-jfs1hr\">)</span></figcaption></figure><p id=\"1dda360d-33e3-80d3-8e3b-e5cc104ff1ad\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dca360d-33e3-80bb-ba24-e5a3d8562fea\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">2. Filtering</span></span></span></p><p id=\"1dca360d-33e3-80af-8858-ce5fe7911083\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이 단계에서는 유저에게 제공할 광고 후보를 선별하고, 광고주의 예산 및 광고 품질을 고려한 필터링 과정을 수행합니다.</span></span></span></p><ul class=\"css-uswsmm\"><li id=\"1dca360d-33e3-8016-866f-d0c09a43489a\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">광고 후보군 선정(Candidate Selection)</span><span class=\"css-1kxrhf3\">: 유저를 타겟팅하는 수십만~수백만 개의 광고 중에서 사용자가 관심을 가질 만한 광고를 빠르게 선택해야 해요. 모든 광고를 실시간으로 개별 평가하면 지연 시간이 늘고 연산 비용이 크게 증가하므로, 유저의 관심사를 기반으로 광고 후보군을 선별합니다. 이 과정에서는 정확성도 중요하지만 대규모 광고 풀에서 알맞은 후보군을 빠르게 추출하는 것이 중요한데요. 이 단계에서는 주로 </span><span class=\"css-q3ktjb\">Two-tower 모델</span><span class=\"css-1kxrhf3\">을 활용해 유저와 광고에 대한 임베딩을 생성하고, 유사도 검색을 통해 관련 광고를 빠르게 탐색합니다.</span></span></span></li><li id=\"1dca360d-33e3-8026-bfe0-d8872cc5df19\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">예산 소진 조절(Pacing)</span><span class=\"css-1kxrhf3\">: 광고주가 설정한 캠페인 예산을 기간 내에 균등하고 안정적으로 소진하도록 광고 노출 및 입찰을 제어합니다. 과거 입찰 로그를 바탕으로 시간대・요일 등 컨텍스트에 따른 트래픽을 예측하고, 이를 바탕으로 사용 가능한 예산을 산정하고 실시간으로 소진 속도를 조절해요.</span></span></span></li><li id=\"1dca360d-33e3-805f-909c-e30fae01fb7d\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">노출 빈도 제한(Frequency Capping)</span><span class=\"css-1kxrhf3\">: 동일한 광고가 한 유저에게 일정 기간 내에 노출될 최대 횟수를 설정하여 광고 피로도를 줄입니다. 하루 최대 3회와 같이 고정 캡을 설정할 수 있지만, 유저의 행동 패턴에 따른 최적 빈도를 예측해 적용할 수 있어요.</span></span></span></li></ul><p id=\"1dca360d-33e3-80b8-9626-d768137d336c\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dca360d-33e3-8082-9efc-f3e470c37b5b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">3. Ranking</span></span></span></p><p id=\"1dca360d-33e3-80ef-bb69-f545fb1903a6\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이전 단계에서 선별된 후보 광고의 입찰가를 산출해 노출될 광고를 결정합니다. 입찰가는 매체의 기대 수익을 의미하는 </span><span class=\"css-q3ktjb\">eCPM(effective Cost Per Mille, 1,000회 노출당 비용)</span><span class=\"css-1kxrhf3\">으로 표현하며, 이 값을 기준으로 광고 순위를 매겨요. eCPM은 광고주가 클릭당 지불하는 비용(CPC, Cost Per Click)과 광고의 클릭률(CTR, Click-Through Rate)을 기반으로 계산합니다.</span></span></span></p><style data-emotion=\"css nv7vyi\">.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}</style><aside class=\"css-nv7vyi\"><style data-emotion=\"css 123co55\">.css-123co55{font-size:19px;letter-spacing:0em;line-height:1.6;margin:24px 0 0;font-weight:400;color:var(--adaptiveGrey900);background-color:transparent;}</style><h4 class=\"css-123co55\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css 120saye\">.css-120saye{white-space:pre-wrap;font-style:italic;font-weight:bold;}</style><span class=\"css-120saye\">eCPM</span><style data-emotion=\"css 1odxvuk\">.css-1odxvuk{white-space:pre-wrap;font-style:italic;}</style><span class=\"css-1odxvuk\">(1,000회 노출당 비용)</span><span class=\"css-120saye\"> = CPC</span><span class=\"css-1odxvuk\">(클릭당 지불 비용) </span><span class=\"css-120saye\">* CTR</span><span class=\"css-1odxvuk\">(클릭률) </span><span class=\"css-120saye\">* 1,000</span></span></span></h4></aside><p id=\"1dca360d-33e3-80af-a389-f401088c916a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이때 실제 CTR은 광고가 실제로 노출된 후에야 알 수 있기 때문에, 노출 전 단계에서는 유저, 광고, 컨텍스트 정보를 기반으로 CTR을 예측하여 사용합니다. CTR 예측 모델은 광고 ID, 유저 속성 등 고차원의 희소 특징(Sparse Feature) 간의 상호작용을 효과적으로 학습해야 하기 때문에, 주로 </span><span class=\"css-q3ktjb\">FM(Factorization Machine), DeepFM, DCN(Deep &amp; Cross Network)</span><span class=\"css-1kxrhf3\"> 구조를 사용해요. </span></span></span></p><p id=\"1dca360d-33e3-8097-90ee-fbf417287ea3\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">또한, 광고주는 각 노출 기회마다 전환율(CVR, Conversion Rate)을 예측해 입찰가를 조절할 수 있습니다. 전환율이 낮다고 예상되는 상황에서는 클릭당 비용을 낮춰 불필요한 지출을 최소화하고, 전환율이 높다고 예상될 때 클릭당 비용을 높여 경쟁 우위를 차지할 수 있어요. </span></span></span></p><p id=\"1dca360d-33e3-8084-bd70-f468e3b23e98\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1dca360d-33e3-802e-b07c-f61333f514a9\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">결론</span></span></span></h3><p id=\"1dca360d-33e3-80af-a7bd-e08470ac1b8b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">앞서 살펴본 광고 노출 과정 이외에도 머신러닝은 광고 운영 전반에서 다양하게 활용될 수 있습니다.</span></span></span></p><ul class=\"css-uswsmm\"><li id=\"1dca360d-33e3-80c5-86a8-d50ebc45a427\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">동적 입찰가 조절</span><span class=\"css-1kxrhf3\">: 광고주가 설정한 클릭당 비용은 고정된 값이기 때문에 실시간으로 변화하는 경쟁 상황에 빠르게 대응하지 못해요. 이를 보완하기 위해 DQN(Deep Q-Network)와 같은 강화학습 모델을 사용하여 광고 운영 현황에 따라 클릭당 비용을 동적으로 조절함으로써 광고 효율 저하를 방지합니다.</span></span></span></li><li id=\"1dca360d-33e3-8079-8b6e-e864c691c97c\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">광고 소재 최적화</span><span class=\"css-1kxrhf3\">: 사용자에게 노출되는 광고 소재의 성과를 향상시키기 위해 생성형 AI를 활용하여 다양한 소재를 자동 생성・테스트하고 최적의 소재를 찾습니다.</span></span></span></li></ul><p id=\"1dca360d-33e3-807a-a84f-d3e5339eb925\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1dca360d-33e3-804e-8fab-c49f1954865b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css iynyr0\">.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}</style><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://tossads.toss.im/?utm_source=toss&amp;utm_medium=post&amp;utm_campaign=2504_techblog_ml\">토스애즈</a><span class=\"css-1kxrhf3\">는 광고 플랫폼의 기반을 만들어가는 단계로, 광고 시스템 전반에 필요한 머신러닝 모델을 초기부터 설계하고 고도화할 수 있어요. 광고는 머신러닝 모델의 작은 변화가 바로 비즈니스 성과로 이어지는 분야입니다. 다양한 실험을 통해 머신러닝 모델로 비즈니스 성과를 만들어가고 싶으신 분들의 많은 지원을 기다립니다.</span></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-1kxrhf3{white-space:pre-wrap;}안녕하세요, 토스 Ads Performance 팀 ML Engineer 김영호입니다.\n토스앱 진입 시 확인하실 수 있는 다양한 광고들은 어떤 과정을 거쳐 유저에게 노출될까요? 이 글에서는 토스 광고 추천 시스템의 전체 흐름과 그 안의 머신러닝 활용 방식을 소개해 드리겠습니다.\n\n웹사이트나 앱에서 볼 수 있는 대부분의 광고는 실시간 입찰 방식을 통해 노출됩니다. 매체에서 광고 지면에 노출 기회가 발생하면 해당 정보를 광고주에게 전달하고, 광고주는 기회에 대한 가치를 평가해 자신이 지불할 금액을 산정하여 입찰에 참여하죠. 제출된 입찰가 중 가장 높은 금액을 제시한 광고주의 광고가 최종적으로 해당 지면에 노출됩니다.\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}.css-wgpbp3{display:block;margin-top:6px;}.css-18442ym{font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}.css-jfs1hr{white-space:pre-wrap;font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}[그림 1] 실시간 입찰 (출처: .css-114ityv{white-space:pre-wrap;cursor:pointer;-webkit-text-decoration:underline!important;text-decoration:underline!important;font-size:13px;line-height:1.7;word-break:keep-all;letter-spacing:0em;color:var(--adaptiveGrey600);white-space:pre-wrap;}appsflyer)\n실시간 입찰에는 여러 광고 플랫폼이 관여하는데요, 대표적으로 SSP(Supply-Side Platform)와 DSP(Demand-Side Platform)가 있습니다. 이 둘은 실시간 입찰 과정에서 유기적으로 연동되어 매체에 안정적인 수익을, 광고주에는 효율적인 광고 집행 및 성과 최적화를 제공합니다.\n.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\n.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}SSP: 매체가 보유한 지면을 효율적으로 관리・판매하도록 돕는 플랫폼입니다. 광고 노출 기회마다 자동으로 여러 DSP를 연결하여 최적의 입찰을 유도함으로써 매체 수익을 극대화합니다. \nDSP: 광고주를 대신해 실시간 입찰에 참여하며, 설정된 예산과 목표에 따라 최소 비용으로 최대 광고 성과를 달성하도록 돕는 플랫폼입니다.\n\n토스는 리스트・모먼트 배너 등 다양한 광고 지면을 보유한 매체이자, 토스애즈 플랫폼을 통해 광고주가 토스 앱 내에서 손쉽게 광고를 집행하고 최적화할 수 있는 환경을 제공합니다. 따라서 광고 요청부터 노출까지의 모든 과정이 토스 내에서 이루어지죠.\n\n.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}\n유저 접속부터 광고 노출까지\n유저가 광고 지면이 있는 토스 앱 화면에 접속하면 광고 요청이 발생하고, 입찰을 통해 최적의 광고가 선정되어 노출됩니다. 이 과정은 크게 Targeting, Filtering, Ranking의 세 단계로 이루어지며, 각 단계에서 머신러닝이 활용돼요.\n\n1. Targeting\n유저 정보를 기반으로 노출할 광고를 선별하는 과정이에요. 광고주마다 캠페인 목표와 원하는 타겟 유저가 다르기 때문에, 광고 노출 대상인 유저가 설정된 타겟에 포함되는지 확인합니다. 포함되지 않을 경우 해당 광고는 제외돼요.\n성별, 연령대, 직업 등의 특성을 바탕으로 유저를 세분화하여 광고를 집행하는 전략을 오디언스 타겟팅(Audience Targeting)이라고 합니다. 광고주는 인구통계학적 정보만으로도 타겟팅 그룹을 만들 수 있지만, 많은 광고주들은 자신의 상품을 구매한 유저와 유사한 특성을 지닌 잠재 고객을 타겟팅하고 싶어하죠.\n이러한 니즈를 충족시키기 위해 Lookalike 모델을 활용해 광고주가 타겟으로 설정한 오디언스와 행동 패턴이 유사한 잠재 고객을 찾습니다. 유저의 행동 로그를 학습하거나 Two-tower 모델을 통해 유저와 광고 간의 상호작용을 학습하여 유저 임베딩을 생성하고, 주어진 오디언스와의 임베딩 유사도를 계산해 잠재 고객을 선별해요.\n[그림 2] Lookalike 모델 (출처: Adobe Tech Blog)\n\n2. Filtering\n이 단계에서는 유저에게 제공할 광고 후보를 선별하고, 광고주의 예산 및 광고 품질을 고려한 필터링 과정을 수행합니다.\n\n광고 후보군 선정(Candidate Selection): 유저를 타겟팅하는 수십만~수백만 개의 광고 중에서 사용자가 관심을 가질 만한 광고를 빠르게 선택해야 해요. 모든 광고를 실시간으로 개별 평가하면 지연 시간이 늘고 연산 비용이 크게 증가하므로, 유저의 관심사를 기반으로 광고 후보군을 선별합니다. 이 과정에서는 정확성도 중요하지만 대규모 광고 풀에서 알맞은 후보군을 빠르게 추출하는 것이 중요한데요. 이 단계에서는 주로 Two-tower 모델을 활용해 유저와 광고에 대한 임베딩을 생성하고, 유사도 검색을 통해 관련 광고를 빠르게 탐색합니다.\n예산 소진 조절(Pacing): 광고주가 설정한 캠페인 예산을 기간 내에 균등하고 안정적으로 소진하도록 광고 노출 및 입찰을 제어합니다. 과거 입찰 로그를 바탕으로 시간대・요일 등 컨텍스트에 따른 트래픽을 예측하고, 이를 바탕으로 사용 가능한 예산을 산정하고 실시간으로 소진 속도를 조절해요.\n노출 빈도 제한(Frequency Capping): 동일한 광고가 한 유저에게 일정 기간 내에 노출될 최대 횟수를 설정하여 광고 피로도를 줄입니다. 하루 최대 3회와 같이 고정 캡을 설정할 수 있지만, 유저의 행동 패턴에 따른 최적 빈도를 예측해 적용할 수 있어요.\n\n\n3. Ranking\n이전 단계에서 선별된 후보 광고의 입찰가를 산출해 노출될 광고를 결정합니다. 입찰가는 매체의 기대 수익을 의미하는 eCPM(effective Cost Per Mille, 1,000회 노출당 비용)으로 표현하며, 이 값을 기준으로 광고 순위를 매겨요. eCPM은 광고주가 클릭당 지불하는 비용(CPC, Cost Per Click)과 광고의 클릭률(CTR, Click-Through Rate)을 기반으로 계산합니다.\n.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}.css-123co55{font-size:19px;letter-spacing:0em;line-height:1.6;margin:24px 0 0;font-weight:400;color:var(--adaptiveGrey900);background-color:transparent;}\n.css-120saye{white-space:pre-wrap;font-style:italic;font-weight:bold;}eCPM.css-1odxvuk{white-space:pre-wrap;font-style:italic;}(1,000회 노출당 비용) = CPC(클릭당 지불 비용) * CTR(클릭률) * 1,000\n\n이때 실제 CTR은 광고가 실제로 노출된 후에야 알 수 있기 때문에, 노출 전 단계에서는 유저, 광고, 컨텍스트 정보를 기반으로 CTR을 예측하여 사용합니다. CTR 예측 모델은 광고 ID, 유저 속성 등 고차원의 희소 특징(Sparse Feature) 간의 상호작용을 효과적으로 학습해야 하기 때문에, 주로 FM(Factorization Machine), DeepFM, DCN(Deep & Cross Network) 구조를 사용해요. \n또한, 광고주는 각 노출 기회마다 전환율(CVR, Conversion Rate)을 예측해 입찰가를 조절할 수 있습니다. 전환율이 낮다고 예상되는 상황에서는 클릭당 비용을 낮춰 불필요한 지출을 최소화하고, 전환율이 높다고 예상될 때 클릭당 비용을 높여 경쟁 우위를 차지할 수 있어요. \n\n결론\n앞서 살펴본 광고 노출 과정 이외에도 머신러닝은 광고 운영 전반에서 다양하게 활용될 수 있습니다.\n\n동적 입찰가 조절: 광고주가 설정한 클릭당 비용은 고정된 값이기 때문에 실시간으로 변화하는 경쟁 상황에 빠르게 대응하지 못해요. 이를 보완하기 위해 DQN(Deep Q-Network)와 같은 강화학습 모델을 사용하여 광고 운영 현황에 따라 클릭당 비용을 동적으로 조절함으로써 광고 효율 저하를 방지합니다.\n광고 소재 최적화: 사용자에게 노출되는 광고 소재의 성과를 향상시키기 위해 생성형 AI를 활용하여 다양한 소재를 자동 생성・테스트하고 최적의 소재를 찾습니다.\n\n\n.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}토스애즈는 광고 플랫폼의 기반을 만들어가는 단계로, 광고 시스템 전반에 필요한 머신러닝 모델을 초기부터 설계하고 고도화할 수 있어요. 광고는 머신러닝 모델의 작은 변화가 바로 비즈니스 성과로 이어지는 분야입니다. 다양한 실험을 통해 머신러닝 모델로 비즈니스 성과를 만들어가고 싶으신 분들의 많은 지원을 기다립니다.",
        "content": "토스앱의 다양한 광고는 어떤 과정을 거쳐 유저에게 노출될까요?",
        "contentSnippet": "토스앱의 다양한 광고는 어떤 과정을 거쳐 유저에게 노출될까요?",
        "guid": "https://toss.tech/article/ads-ml",
        "isoDate": "2025-04-21T13:13:00.000Z"
      },
      {
        "title": "🛒 토스 쇼핑 추천 시스템: 수백만 사용자와 상품을 잇는 멀티 스테이지 접근법",
        "link": "https://toss.tech/article/toss-shopping-recommendation-system",
        "pubDate": "Thu, 17 Apr 2025 03:40:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1d8a360d-33e3-817e-8a76-f3a3edba6d8e\" class=\"css-14on8x8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">안녕하세요, 토스 커머스 개인화팀의 ML Engineer 김정오입니다.</span></span></span></p><p id=\"1d8a360d-33e3-80a2-8f20-f2f318d09706\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">현재 토스 앱 하단 메뉴의 중앙은 저희팀에서 만들어가고 있는 </span><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">토스 쇼핑</span><span class=\"css-1kxrhf3\">이 자리하고 있는데요. 토스 쇼핑은 사용자 데이터를 기반으로 사용자에게 가장 필요한 상품을 추천해주게 되어있어요. 이 글을 통해서 토스 쇼핑은 어떻게 개인화 추천 시스템을 만들고 있는지 간략히 설명해 드리고자 합니다.</span></span></span></p><style data-emotion=\"css 1c1qox8\">.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}</style><h2 id=\"1d8a360d-33e3-80f2-bd55-e677bf8e989e\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><style data-emotion=\"css p4abj2\">.css-p4abj2{display:contents;line-height:1.55;}</style><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">🔍 목적형 사용자와 탐색형 사용자</span></span></span></h2><p id=\"1d8a360d-33e3-8071-aa0d-c3b2edbeaac9\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스 쇼핑은 다양한 소비자 유형을 다루고 있어요. 이 중 특히 중요한 두 가지 유형은 </span><span class=\"css-q3ktjb\">목적형 사용자</span><span class=\"css-1kxrhf3\">와 </span><span class=\"css-q3ktjb\">탐색형 사용자</span><span class=\"css-1kxrhf3\">인데요, 그 정의는 아래와 같습니다.</span></span></span></p><style data-emotion=\"css uswsmm\">.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ul class=\"css-uswsmm\"><style data-emotion=\"css 1hwiibq\">.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}</style><li id=\"1d8a360d-33e3-80fb-8373-ea2cdb7967ca\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">목적형 사용자 (Goal-Oriented User)</span></span></span><div class=\"css-1vn47db\"><p id=\"1d8a360d-33e3-80a2-8f50-cd7b7bc6a7cf\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">명확한 구매 목표 또는 특정 상품에 대한 수요를 가지고 플랫폼에 방문하는 사용자입니다. \n이들은 구체적인 상품명, 카테고리, 가격대 등의 기준을 기반으로 검색 및 탐색 활동을 수행하며, 최대한 빠르게 원하는 상품을 발견하고 구매하는 것을 목표로 해요.</span></span></span></p></div></li><li id=\"1d8a360d-33e3-80bd-be45-db13761835dc\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">탐색형 사용자 (Exploratory User)</span></span></span><div class=\"css-1vn47db\"><p id=\"1d8a360d-33e3-8005-bfa6-e48a1cdafd29\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">명시적인 구매 목적 없이 플랫폼을 탐색하며 다양한 상품을 둘러보는 사용자입니다.\n이들은 우연히 발견한 상품 및 정보를 통해 흥미를 느끼고, 구매로 이어질 가능성을 높이는 행동 패턴을 보여요. 탐색형 사용자는 상품 카테고리에 대한 관심이 광범위하며, 구매 결정까지 상대적으로 긴 경로를 거치는 경향이 있습니다.</span></span></span></p></div></li></ul><p id=\"1d8a360d-33e3-8014-9432-e42ce9d20020\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">→ 토스 쇼핑은 탐색형 사용자의 비중이 높습니다. 따라서, 사용자가 자연스럽게 흥미를 느끼고 구매 행동으로 이어지도록 돕는 개인화 추천 시스템이 필수적이에요.</span></span></span></p><p id=\"1d8a360d-33e3-801b-b260-ed85ba144207\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1d8a360d-33e3-803a-a54d-ee03cb612959\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">📈 추천 시스템의 필요성</span></span></span></h2><ul class=\"css-uswsmm\"><li id=\"1d8a360d-33e3-802d-8bee-f871561ae069\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">수백만 명의 사용자와 수백만 건의 상품이 존재하는 대규모 플랫폼에서는, 사용자와 상품 간의 최적 매칭을 수작업으로 제공하는 것은 불가능합니다.</span></span></span></li><li id=\"1d8a360d-33e3-807c-9012-dc0cf7e12a33\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">특히 탐색형 사용자의 경우, 명확한 검색 키워드 없이도 매력적인 상품을 발견할 수 있도록 돕는 </span><span class=\"css-q3ktjb\">개인화 추천 시스템</span><span class=\"css-1kxrhf3\">이 핵심 역할을 합니다.</span></span></span></li><li id=\"1d8a360d-33e3-802e-80c5-c95e2baf84c6\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">추천 시스템은 사용자 경험을 향상시키고, 구매 전환율을 높이며, 서비스 체류 시간을 증가시키는 데 직접적인 영향을 미칩니다.</span></span></span></li></ul><p id=\"1d8a360d-33e3-8044-b50f-e8fc3cf6fa6e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1d8a360d-33e3-8060-9bf9-e9b048eb002f\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">🛠 멀티 스테이지 추천 시스템</span></span></span></h2><p id=\"1d8a360d-33e3-8019-9e09-fcc2e5307f15\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">대규모 추천 문제를 해결하기 위해, 저희는 성능과 속도를 모두 고려하여 </span><span class=\"css-q3ktjb\">멀티 스테이지(Multi-Stage)</span><span class=\"css-1kxrhf3\"> 구조를 채택했어요. 이 구조는 크게 다음과 같은 단계로 이루어집니다.</span></span></span></p><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1d8a360d-33e3-80a0-872b-fd4a11428ef4\" class=\"css-of5acw\"><style data-emotion=\"css 1pgssrp\">.css-1pgssrp{max-width:100%;border-radius:16px;}</style><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/5f439a77-5414-4444-a064-644136069b6d/tech-250417-세로.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><h2 id=\"1d8a360d-33e3-80ff-90c8-c1d80ae509c1\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">1. Retrieval</span></span></span></h2><p id=\"1d8a360d-33e3-80c8-a432-ee1ed7b1022f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Retrieval 단계에서는 수백만 개의 상품 중에서 사용자에게 어울릴 가능성이 높은 수천 개의 상품을 빠르게 후보로 뽑아내요.\n이 단계는 매우 빠른 응답 속도가 요구되며, 아래와 같이 다양한 방법론이 활용됩니다.</span></span></span></p><ul class=\"css-uswsmm\"><li id=\"1d8a360d-33e3-8063-8418-e9edd8438d5b\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Two-Tower 모델</span><span class=\"css-1kxrhf3\">: 사용자와 아이템 각각을 임베딩하여 벡터 공간에 매핑하고, 벡터 검색(Nearest Neighbor Search)을 통해 유사한 상품을 빠르게 검색합니다. DNN 기반 인코딩을 사용하며, 두 타워의 임베딩 결과를 내적(Dot Product)하여 유사도를 계산합니다.</span></span></span></li><li id=\"1d8a360d-33e3-805b-b826-f5f95869f434\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Graph 기반 모델</span><span class=\"css-1kxrhf3\">: 사용자-상품 상호작용 데이터를 그래프 형태로 표현하여, Graph Neural Network(GNN)를 통해 잠재적 연관성을 학습합니다. GraphSAGE, PinSage, LightGCN 등의 기술이 활용돼요.</span></span></span></li><li id=\"1d8a360d-33e3-80bf-bd67-d0f5b4ee0906\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Sequence 모델</span><span class=\"css-1kxrhf3\">: 사용자의 행동 이력을 시퀀스로 모델링하고, Transformer 기반 모델(SASRec, BERT4Rec 등)을 통해 시계열 관계를 포착하여 다음 상호작용 상품을 예측합니다.</span></span></span></li></ul><p id=\"1d8a360d-33e3-8095-a82f-deee4ea47ebd\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Retrieval 단계는 정확성과 효율성의 균형을 맞추는 것이 중요하며, 이후 Ranking 단계로 넘어가기 위해 충분히 다양한 후보를 확보하는 역할을 합니다.</span></span></span></p><p id=\"1d8a360d-33e3-8004-bf38-ef97520c9992\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1d8a360d-33e3-806f-bedb-db6253e6d99a\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">2. Ranking</span></span></span></h2><p id=\"1d8a360d-33e3-80b6-b272-d8755b149836\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Ranking 단계에서는 Retrieval 단계에서 얻은 수천 개의 후보군을 받아 </span><span class=\"css-q3ktjb\">개인화 모델</span><span class=\"css-1kxrhf3\">을 통해 점수를 매기고 정렬해요. \n주요 목표는 </span><span class=\"css-q3ktjb\">pCTR(predicted Click-Through Rate)</span><span class=\"css-1kxrhf3\"> 및 </span><span class=\"css-q3ktjb\">pCVR(predicted Conversion Rate)</span><span class=\"css-1kxrhf3\">을 정확히 예측하는 것입니다. 이 단계 역시 아래와 같이 다양한 방법론이 사용됩니다.</span></span></span></p><ul class=\"css-uswsmm\"><li id=\"1d8a360d-33e3-807e-b69c-f648d7cd7c0b\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">DeepFM</span><span class=\"css-1kxrhf3\">: FM(Factorization Machine)으로 특징 간의 이차 상호작용을 포착하고, DNN으로 비선형 관계를 학습하는 구조입니다.</span></span></span></li><li id=\"1d8a360d-33e3-80b3-8dbc-c6c5253f2ebc\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">DLRM(Deep Learning Recommendation Model)</span><span class=\"css-1kxrhf3\">: 조밀 특징(Dense features)과 희소 특징(Sparse features)을 통합하여 복잡한 사용자-상품 관계를 모델링합니다.</span></span></span></li><li id=\"1d8a360d-33e3-80cf-8b02-d74c34882fce\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">DCN(Deep &amp; Cross Network)</span><span class=\"css-1kxrhf3\">: 특징 간의 조합(Cross Feature Interactions)을 명시적으로 학습하여 고차원적인 특징 조합을 효과적으로 반영합니다.</span></span></span></li><li id=\"1d8a360d-33e3-8064-afe8-c32316fc38b0\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">ESMM(Entire Space Multi-Task Model)</span><span class=\"css-1kxrhf3\">: 클릭(Click)과 전환(Conversion) 확률을 함께 학습하는 Multi-Task Learning 기반 모델로, pCTR과 pCVR을 동시에 고려하여 학습 효율성과 일반화를 높입니다.</span></span></span></li></ul><p id=\"1d8a360d-33e3-804f-bf3f-d806d3a4876d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이러한 모델들은 개별 예측 성능을 높이는 것뿐만 아니라, 서비스의 핵심 지표(GMV, Orders 등) 최적화에도 큰 기여를 합니다.</span></span></span></p><h2 id=\"1d8a360d-33e3-8088-a986-e4b3aa007034\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">3. Re-ranking</span></span></span></h2><p id=\"1d8a360d-33e3-8097-9a4a-d53c2e44753e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">최종 단계인 Re-ranking에서는 초기 모델 점수 외에도 다양한 비즈니스 로직과 사용자 경험 향상을 위한 요소를 반영하여 결과를 조정합니다.\n주요 목표는 추천 결과의 </span><span class=\"css-q3ktjb\">다양성(Diversity)</span><span class=\"css-1kxrhf3\">, </span><span class=\"css-q3ktjb\">신선도(Novelty)</span><span class=\"css-1kxrhf3\">, </span><span class=\"css-q3ktjb\">비즈니스 지표 최적화</span><span class=\"css-1kxrhf3\">를 동시에 만족시키는 것이에요.</span></span></span></p><ul class=\"css-uswsmm\"><li id=\"1d8a360d-33e3-806e-9a5c-df849ed0b7fa\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">신선도(Novelty) 보장</span><span class=\"css-1kxrhf3\">: 사용자에게 새로운 경험을 제공하기 위해, Cold-Start 아이템(최근 등록된 신상품 또는 상호작용 데이터가 적은 상품)을 일정 비율 포함시킵니다.</span></span></span></li><li id=\"1d8a360d-33e3-80f3-a590-f3144680fe91\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">광고 상품과 비광고 상품의 혼합</span><span class=\"css-1kxrhf3\">: 광고 성과를 극대화하기 위해, 광고 상품과 비광고 상품을 자연스럽게 섞어 노출해요. 광고 상품이 과도하게 몰리지 않도록 조정하여 사용자 경험을 해치지 않으면서 높은 ROI를 기대할 수 있도록 합니다.</span></span></span></li><li id=\"1d8a360d-33e3-8024-b80c-fb9a96641a3d\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">다양성 및 카테고리 균형 고려</span><span class=\"css-1kxrhf3\">: 다양한 카테고리와 상품 타입을 고르게 배치하여 추천 품질을 높입니다.</span></span></span></li></ul><p id=\"1d8a360d-33e3-8084-8c80-f0c3484ef58a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이렇게 다양한 요소를 반영한 Re-ranking은 단순 예측 점수에 기반한 정렬보다 실제 사용자 경험과 비즈니스 목표 모두를 동시에 만족시키는 데 중요한 역할을 합니다.</span></span></span></p><p id=\"1d8a360d-33e3-8008-b0ec-d06c495a2ab5\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1d8a360d-33e3-80ba-864d-cd3966517db8\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">📝 결론</span></span></span></h2><p id=\"1d8a360d-33e3-80ca-8414-e4d9385e2624\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스 쇼핑의 홈 피드 추천 시스템은 탐색형 사용자의 특성을 고려하여 설계된 </span><span class=\"css-q3ktjb\">멀티 스테이지 추천 시스템</span><span class=\"css-1kxrhf3\">입니다.</span></span></span></p><p id=\"1d8a360d-33e3-80e8-902f-ce91ad505db3\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">수백만 명의 사용자와 수백만 건의 상품을 다루는 환경에서, Retrieval, Ranking, Re-ranking을 통한 점진적인 후보군 정제가 핵심 전략이죠. 이를 통해 사용자는 명확한 구매 목표 없이도 자연스럽게 흥미로운 상품을 발견하고, 구매로 이어질 수 있습니다.</span></span></span></p><p id=\"1d8a360d-33e3-802b-8fa5-eaefd656ec2c\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스 쇼핑에서는 각 스테이지(Retrieval, Ranking, Re-ranking)별 추천 모델을 지속적으로 개선하고 고도화할 ML Engineer를 찾고 있어요. 토스 쇼핑의 추천 시스템을 함께 만들어가실 분들의 많은 지원을 기다립니다!</span></span></span></p><p id=\"1d8a360d-33e3-81db-a1b4-e2a74320d3f8\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-1kxrhf3{white-space:pre-wrap;}안녕하세요, 토스 커머스 개인화팀의 ML Engineer 김정오입니다.\n현재 토스 앱 하단 메뉴의 중앙은 저희팀에서 만들어가고 있는 .css-q3ktjb{white-space:pre-wrap;font-weight:bold;}토스 쇼핑이 자리하고 있는데요. 토스 쇼핑은 사용자 데이터를 기반으로 사용자에게 가장 필요한 상품을 추천해주게 되어있어요. 이 글을 통해서 토스 쇼핑은 어떻게 개인화 추천 시스템을 만들고 있는지 간략히 설명해 드리고자 합니다.\n.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}\n.css-p4abj2{display:contents;line-height:1.55;}🔍 목적형 사용자와 탐색형 사용자\n토스 쇼핑은 다양한 소비자 유형을 다루고 있어요. 이 중 특히 중요한 두 가지 유형은 목적형 사용자와 탐색형 사용자인데요, 그 정의는 아래와 같습니다.\n.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\n목적형 사용자 (Goal-Oriented User)\n명확한 구매 목표 또는 특정 상품에 대한 수요를 가지고 플랫폼에 방문하는 사용자입니다. \n이들은 구체적인 상품명, 카테고리, 가격대 등의 기준을 기반으로 검색 및 탐색 활동을 수행하며, 최대한 빠르게 원하는 상품을 발견하고 구매하는 것을 목표로 해요.\n\n탐색형 사용자 (Exploratory User)\n명시적인 구매 목적 없이 플랫폼을 탐색하며 다양한 상품을 둘러보는 사용자입니다.\n이들은 우연히 발견한 상품 및 정보를 통해 흥미를 느끼고, 구매로 이어질 가능성을 높이는 행동 패턴을 보여요. 탐색형 사용자는 상품 카테고리에 대한 관심이 광범위하며, 구매 결정까지 상대적으로 긴 경로를 거치는 경향이 있습니다.\n\n\n→ 토스 쇼핑은 탐색형 사용자의 비중이 높습니다. 따라서, 사용자가 자연스럽게 흥미를 느끼고 구매 행동으로 이어지도록 돕는 개인화 추천 시스템이 필수적이에요.\n\n📈 추천 시스템의 필요성\n\n수백만 명의 사용자와 수백만 건의 상품이 존재하는 대규모 플랫폼에서는, 사용자와 상품 간의 최적 매칭을 수작업으로 제공하는 것은 불가능합니다.\n특히 탐색형 사용자의 경우, 명확한 검색 키워드 없이도 매력적인 상품을 발견할 수 있도록 돕는 개인화 추천 시스템이 핵심 역할을 합니다.\n추천 시스템은 사용자 경험을 향상시키고, 구매 전환율을 높이며, 서비스 체류 시간을 증가시키는 데 직접적인 영향을 미칩니다.\n\n\n🛠 멀티 스테이지 추천 시스템\n대규모 추천 문제를 해결하기 위해, 저희는 성능과 속도를 모두 고려하여 멀티 스테이지(Multi-Stage) 구조를 채택했어요. 이 구조는 크게 다음과 같은 단계로 이루어집니다.\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}\n1. Retrieval\nRetrieval 단계에서는 수백만 개의 상품 중에서 사용자에게 어울릴 가능성이 높은 수천 개의 상품을 빠르게 후보로 뽑아내요.\n이 단계는 매우 빠른 응답 속도가 요구되며, 아래와 같이 다양한 방법론이 활용됩니다.\n\nTwo-Tower 모델: 사용자와 아이템 각각을 임베딩하여 벡터 공간에 매핑하고, 벡터 검색(Nearest Neighbor Search)을 통해 유사한 상품을 빠르게 검색합니다. DNN 기반 인코딩을 사용하며, 두 타워의 임베딩 결과를 내적(Dot Product)하여 유사도를 계산합니다.\nGraph 기반 모델: 사용자-상품 상호작용 데이터를 그래프 형태로 표현하여, Graph Neural Network(GNN)를 통해 잠재적 연관성을 학습합니다. GraphSAGE, PinSage, LightGCN 등의 기술이 활용돼요.\nSequence 모델: 사용자의 행동 이력을 시퀀스로 모델링하고, Transformer 기반 모델(SASRec, BERT4Rec 등)을 통해 시계열 관계를 포착하여 다음 상호작용 상품을 예측합니다.\n\nRetrieval 단계는 정확성과 효율성의 균형을 맞추는 것이 중요하며, 이후 Ranking 단계로 넘어가기 위해 충분히 다양한 후보를 확보하는 역할을 합니다.\n\n2. Ranking\nRanking 단계에서는 Retrieval 단계에서 얻은 수천 개의 후보군을 받아 개인화 모델을 통해 점수를 매기고 정렬해요. \n주요 목표는 pCTR(predicted Click-Through Rate) 및 pCVR(predicted Conversion Rate)을 정확히 예측하는 것입니다. 이 단계 역시 아래와 같이 다양한 방법론이 사용됩니다.\n\nDeepFM: FM(Factorization Machine)으로 특징 간의 이차 상호작용을 포착하고, DNN으로 비선형 관계를 학습하는 구조입니다.\nDLRM(Deep Learning Recommendation Model): 조밀 특징(Dense features)과 희소 특징(Sparse features)을 통합하여 복잡한 사용자-상품 관계를 모델링합니다.\nDCN(Deep & Cross Network): 특징 간의 조합(Cross Feature Interactions)을 명시적으로 학습하여 고차원적인 특징 조합을 효과적으로 반영합니다.\nESMM(Entire Space Multi-Task Model): 클릭(Click)과 전환(Conversion) 확률을 함께 학습하는 Multi-Task Learning 기반 모델로, pCTR과 pCVR을 동시에 고려하여 학습 효율성과 일반화를 높입니다.\n\n이러한 모델들은 개별 예측 성능을 높이는 것뿐만 아니라, 서비스의 핵심 지표(GMV, Orders 등) 최적화에도 큰 기여를 합니다.\n3. Re-ranking\n최종 단계인 Re-ranking에서는 초기 모델 점수 외에도 다양한 비즈니스 로직과 사용자 경험 향상을 위한 요소를 반영하여 결과를 조정합니다.\n주요 목표는 추천 결과의 다양성(Diversity), 신선도(Novelty), 비즈니스 지표 최적화를 동시에 만족시키는 것이에요.\n\n신선도(Novelty) 보장: 사용자에게 새로운 경험을 제공하기 위해, Cold-Start 아이템(최근 등록된 신상품 또는 상호작용 데이터가 적은 상품)을 일정 비율 포함시킵니다.\n광고 상품과 비광고 상품의 혼합: 광고 성과를 극대화하기 위해, 광고 상품과 비광고 상품을 자연스럽게 섞어 노출해요. 광고 상품이 과도하게 몰리지 않도록 조정하여 사용자 경험을 해치지 않으면서 높은 ROI를 기대할 수 있도록 합니다.\n다양성 및 카테고리 균형 고려: 다양한 카테고리와 상품 타입을 고르게 배치하여 추천 품질을 높입니다.\n\n이렇게 다양한 요소를 반영한 Re-ranking은 단순 예측 점수에 기반한 정렬보다 실제 사용자 경험과 비즈니스 목표 모두를 동시에 만족시키는 데 중요한 역할을 합니다.\n\n📝 결론\n토스 쇼핑의 홈 피드 추천 시스템은 탐색형 사용자의 특성을 고려하여 설계된 멀티 스테이지 추천 시스템입니다.\n수백만 명의 사용자와 수백만 건의 상품을 다루는 환경에서, Retrieval, Ranking, Re-ranking을 통한 점진적인 후보군 정제가 핵심 전략이죠. 이를 통해 사용자는 명확한 구매 목표 없이도 자연스럽게 흥미로운 상품을 발견하고, 구매로 이어질 수 있습니다.\n토스 쇼핑에서는 각 스테이지(Retrieval, Ranking, Re-ranking)별 추천 모델을 지속적으로 개선하고 고도화할 ML Engineer를 찾고 있어요. 토스 쇼핑의 추천 시스템을 함께 만들어가실 분들의 많은 지원을 기다립니다!",
        "content": "토스 쇼핑은 어떻게 수백만 사용자에게 개인화된 상품 추천을 제공할까요? 그 접근법을 소개해 드릴게요.",
        "contentSnippet": "토스 쇼핑은 어떻게 수백만 사용자에게 개인화된 상품 추천을 제공할까요? 그 접근법을 소개해 드릴게요.",
        "guid": "https://toss.tech/article/toss-shopping-recommendation-system",
        "isoDate": "2025-04-17T03:40:00.000Z"
      },
      {
        "title": "UX 리서처가 양말 파는 사장님이 된 이유",
        "link": "https://toss.tech/article/34899",
        "pubDate": "Thu, 10 Apr 2025 06:52:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1caa360d-33e3-80d5-8500-e5c3a0193955\" class=\"css-14on8x8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">토스페이먼츠는 온라인 결제를 담당하는 PG(Payment Gateway)사예요. 토스페이먼츠가 사장님 대신 결제를 처리하고 정산까지 도와주죠. 온라인 쇼핑몰과 카드사를 연결하는 ‘결제의 중간 다리’ 역할을 한다고 볼 수 있어요.</span></span></span></p><p id=\"1caa360d-33e3-80ad-a2c7-d94bf6062142\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">처음 몇 달은 PG 서비스를 중심으로 유저 리서치를 진행했어요. 사장님들이 웹/앱 서비스를 어떻게 만드는지, PG사를 선택할 때 가장 중요한 요소는 무엇인지, 매출과 정산은 어떻게 관리하는지 등을 깊게 파고들었어요. 인터뷰에서 만난 어떤 사장님의 말을 듣기 전까지는요.</span></span></span></p><style data-emotion=\"css 2sk6rv\">.css-2sk6rv{font-size:19px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);white-space:pre-wrap;margin:24px 0;padding-left:20px;position:relative;}.css-2sk6rv::before{content:'';display:block;position:absolute;top:4px;left:0;width:2px;height:calc(100% - 4px * 2);padding:4px 0;background-color:var(--adaptiveGrey800);}</style><blockquote id=\"1caa360d-33e3-8043-ae59-d711cf2e9b78\" class=\"css-2sk6rv\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">“처음 온라인 결제를 준비할 때 </span><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">필수 신고 절차를 몰랐어요</span><span class=\"css-1kxrhf3\">. 홈페이지를 다 만들고 나서야 그 절차를 알아서 시간 낭비를 많이 했죠. 이런 과정을 한눈에 따라갈 수 있는 흐름이 있었으면 좋겠다고 생각했어요.”  </span></span></span><style data-emotion=\"css 7mseny\">.css-7mseny>*{margin-left:0;margin-right:0;}.css-7mseny>:last-child{margin-bottom:0;}blockquote>.css-7mseny:first-child>:first-child{margin-top:0;}</style></blockquote><p id=\"1caa360d-33e3-80af-8ed3-ff5bee21355f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1caa360d-33e3-8053-8de8-c70e35b396cd\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">직접 만나서 이야기를 들어보니 제가 몰랐던 다른 세계가 있더라고요. 사장님들이 실제로 겪는 문제들이 얼마나 중요한 문제인지, 사장님들이 말하지 않는 숨겨진 고충은 없는지 파악하는 것도 쉽지 않았어요. 저는 사업을 해본 적이 없었으니까요. </span></span></span></p><p id=\"1caa360d-33e3-80a4-ba0f-fa29a1b76fd5\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그때 단순히 결제 프로세스를 넘어, </span><span class=\"css-q3ktjb\">사업 운영 전반의 니즈와 문제를 더 깊이 이해할 필요가 있다고 느꼈어요. </span><span class=\"css-1kxrhf3\">B2C 서비스는 리서처가 직접 써보며 공감대를 형성할 수 있지만 B2B는 그 자체를</span><span class=\"css-q3ktjb\"> </span><span class=\"css-1kxrhf3\">직접 경험하기 어려운 한계가 있잖아요.</span></span></span></p><p id=\"1caa360d-33e3-8069-a1e0-d6827e06da44\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">사장님들의 어려움을 제대로 이해하려면 직접 겪어보는 수밖에 없겠더라고요. </span><span class=\"css-q3ktjb\">그래서 결심했죠. 진짜 사장님이 되어보기로요.</span></span></span></p><p id=\"1caa360d-33e3-8084-ae5f-cdbdf26875e0\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1caa360d-33e3-800b-a006-ff84ac028290\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css 1c1qox8\">.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}</style><h2 id=\"1caa360d-33e3-806d-9bca-ff9c1de43c6c\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><style data-emotion=\"css p4abj2\">.css-p4abj2{display:contents;line-height:1.55;}</style><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">UX리서처, 진짜 사장님이 되다</span></span></span></h2><p id=\"1caa360d-33e3-8081-9d94-d1c70c61b82a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1caa360d-33e3-801a-9bd6-c21527525131\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">1단계: 사업자 등록하기</span></span></span></p><p id=\"1caa360d-33e3-805a-95de-d64c54c72606\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">사업을 시작하는 것부터 쉽지 않았어요. 진행해야 할 행정 절차가 참 많더라고요. 사업자 유형, 업종 정의, 사업장 주소, 사업용 전화번호 등을 하나하나 입력해 사업자 등록을 마쳐야 했고, 온라인 판매를 위해선 구매안전서비스 이용 확인증을 발급받고, 통신판매업 신고도 별도로 진행해야 했어요.</span></span></span></p><p id=\"1caa360d-33e3-80d7-aca1-eb419ea23f28\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">예상치 못한 절차들이 계속 나와서, </span><span class=\"css-q3ktjb\">사업을 시작하기도 전에 이미 벅찬 느낌이 들었어요. </span><span class=\"css-1kxrhf3\">사장님들도 처음 사업을 시작할 때 비슷한 어려움을 겪겠구나 싶었어요.</span></span></span></p><p id=\"1caa360d-33e3-8045-b563-eeac84280dba\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1caa360d-33e3-800b-b846-f794d2d01cdf\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">2단계: 판매 아이템 정하기</span></span></span></p><p id=\"1caa360d-33e3-80c1-9336-df06118edab3\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">판매할 아이템을 찾기 위해 동대문 새벽시장에도 가봤는데요. 사장님들의 포스에 눌려 말 한마디도 쉽게 못 꺼내겠더라고요. ‘깔(컬러)’, ‘장끼(영수증)’, ‘미송(품절 시 선결제 후 예약)’ 같은 거래 용어를 하나도 모르니까요.</span></span></span></p><p id=\"1caa360d-33e3-80c3-b2a3-e46e045db8fe\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">몇 번 시장을 오가다 보니, 말투나 준비물도 점점 현장에 맞춰졌어요. 처음엔 회사원 복장으로 갔다가, 나중엔 현금 가방과 사입 가방까지 챙기는 사장님 모드가 됐죠. 그렇게 시장을 돌아다니다가 드디어 아이템을 정했어요.</span></span></span></p><p id=\"1caa360d-33e3-80d0-9b1c-d13ac71552d9\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">양말. 뜬금없이 들릴 수도 있겠지만, 단가가 낮고 판매가 쉬울 거라 생각했거든요.</span></span></span></p><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1d1a360d-33e3-8035-a797-c26e5015aba0\" class=\"css-of5acw\"><style data-emotion=\"css 1pgssrp\">.css-1pgssrp{max-width:100%;border-radius:16px;}</style><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/5db4bb59-bbd3-468f-a716-c6c39f83864b/0410-contents-inner1_(1).png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1caa360d-33e3-8083-8a09-f49b69a3981a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css 1odxvuk\">.css-1odxvuk{white-space:pre-wrap;font-style:italic;}</style><span class=\"css-1odxvuk\">동대문 새벽시장의 풍경</span></span></span></p><p id=\"1caa360d-33e3-8046-8766-ff47e9c24932\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1caa360d-33e3-8020-a368-c02c79c67c88\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">3단계: 쇼핑몰 구축하기</span></span></span></p><p id=\"1caa360d-33e3-80b7-aaaa-faf2b16276be\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">양말을 팔아야겠다고 결정하면서 쇼핑몰도 함께 준비했어요. 비용을 아끼려고 직접 촬영 공간을 만들고, 지인을 모델로 섭외해 촬영을 진행했는데 생각보다 훨씬 어려운 과정이더라고요. 조명 세팅, 구도 잡기, 보정 작업… </span><span class=\"css-q3ktjb\">모든 게 처음이어서 예상보다 시간과 에너지가 많이 들어갔죠.</span><span class=\"css-1kxrhf3\"> 초기 예산에서도 큰 비중을 차지했고요.\n그렇게 우여곡절 끝에 상세페이지 구성, 상품 등록, 가격 설정 등을 하나씩 해나갔고, 약 한 달 만에 쇼핑몰을 오픈했어요.</span></span></span></p><figure id=\"1d1a360d-33e3-8049-bf72-eb20be851e3d\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/6bbf62c3-0576-43e8-b496-ce43e0efad4a/0410-contents-inner2_(2).png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1caa360d-33e3-80bc-a023-d5042e6dee79\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1odxvuk\">제품 촬영 과정</span></span></span></p><p id=\"1caa360d-33e3-80ff-8914-d4eef9a8a11b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1caa360d-33e3-8068-9017-e1d93935ad56\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1caa360d-33e3-80bf-bb6e-c91bde3945c7\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-q3ktjb\">드디어, 첫 주문이 들어오다</span></span></span></h2><p id=\"1caa360d-33e3-80c1-bbbe-d3c2bbf92415\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">첫 주문이 들어왔을 때의 기쁨이 아직도 생생해요. 상품을 포장해 택배로 보내고, 정산 금액을 직접 받고 나니 </span><span class=\"css-q3ktjb\">“아, 내가 진짜로 양말을 팔았구나”</span><span class=\"css-1kxrhf3\"> 하는 실감이 났죠. </span></span></span></p><p id=\"1caa360d-33e3-809f-9b5b-db3a95002b52\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">하지만 막상 판매를 해보니, 양말은 단가가 낮은 만큼 정말 많이 팔아야 수익이 남는 구조였어요</span><span class=\"css-q3ktjb\">.</span><span class=\"css-1kxrhf3\"> 이 아이템을 잘 선택한 게 맞을까 고민되고 혼란스럽더라고요.</span></span></span></p><p id=\"1caa360d-33e3-80db-8068-d81285e0111a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">여러 채널에서 판매한 정산 금액을 확인하고 데이터를 관리하는 과정도 번거로웠어요. 리서치 과정에서 사장님들이 “여러 판매처의 정산 내역을 일일이 확인하는 게 너무 불편하다”고 자주 이야기해주셨는데요. </span><span class=\"css-q3ktjb\">직접 경험해보니, 왜 그런 이야기가 나왔는지 알겠더라고요.</span></span></span></p><figure id=\"1caa360d-33e3-80f2-929a-ecc93bd70e56\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/7b3e4d04-4931-41f7-9ebd-8c69e9073a46/스크린샷_2025-02-03_오후_5.18.03.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1caa360d-33e3-802f-9e1c-c45cd6c953fa\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1odxvuk\">오픈한 실제 쇼핑몰 </span></span></span></p><p id=\"1caa360d-33e3-8058-89f3-d959f8153657\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1caa360d-33e3-8008-9436-c28800899f2b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1caa360d-33e3-8065-b44a-d57d44299519\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">물건 판매는 끝이 아니라 시작이다</span></span></span></h2><p id=\"1caa360d-33e3-80df-93f8-dcd861d2a93a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">쇼핑몰을 준비할 땐 “일단 오픈하는 게 목표다”라는 마음으로 달렸는데, 막상 오픈하고 나니 너무 당연하게도 그게 끝이 아니라 진짜 시작이더라고요. </span><span class=\"css-q3ktjb\">이제는 어떻게 하면 상품을 잘 팔 수 있을지 고민하고 방법을 찾아야 했죠.</span></span></span></p><p id=\"1caa360d-33e3-804a-b0cb-e336407ff22d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">우선 </span><span class=\"css-q3ktjb\">상품이 팔리려면 ‘노출’이 돼야 했고</span><span class=\"css-1kxrhf3\">, </span><span class=\"css-q3ktjb\">광고와 홍보가 필수</span><span class=\"css-1kxrhf3\">였거든요. 그래서 유튜브, 블로그, 사장님들 커뮤니티 등을 참고해가며 키워드별·상품별·타겟별로 광고를 직접 집행하고, 성과를 분석하면서 전략도 조금씩 조정해 나갔어요.</span></span></span></p><p id=\"1caa360d-33e3-80a1-bff3-e3ae12f9e1c4\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">모든 게 처음이다 보니, 온라인에서 정보를 찾는 데에도 시간이 많이 들었어요. 검색해보면 오래됐거나 부정확한 정보가 대부분이었고, 구체적인 설명보다는 흐름만 짚는 자료가 많았거든요. 같은 키워드로 여러 번 검색하고, 여러 자료를 비교해가며 겨우 내용을 파악했죠.</span></span></span></p><p id=\"1caa360d-33e3-800f-8ac9-f0baa47171d8\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이렇게 처음부터 끝까지 부딪혀보면서, </span><span class=\"css-q3ktjb\">사업을 운영하는 데는 생각보다 훨씬 많은 단계와 결정이 필요하다는 걸 절실히 깨달았어요. </span><span class=\"css-1kxrhf3\">사업자 등록, 상품 소싱, 쇼핑몰 제작, 마케팅, 정산 관리까지 — 어느 하나 단순하거나 중요도가 낮은 과정은 없었고, 한 단계라도 꼬이면 그 여파가 다음 단계에 고스란히 이어졌어요.</span></span></span></p><p id=\"1caa360d-33e3-80e5-b4f4-cb503b46b629\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1caa360d-33e3-800f-bcc9-f42c258f26b6\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1caa360d-33e3-8037-9625-d8fd6d722736\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">맨 땅에 헤딩으로 이뤄낸 결과물</span></span></span></h2><p id=\"1caa360d-33e3-8082-97df-fb17f5d31d0a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">직접 사업을 준비하면서 단순한 인터뷰만으로는 파악하기 어려웠던 사장님들의 ‘진짜 고충’을 훨씬 더 깊이 이해할 수 있었어요. 사업자의 여정을 단계별로 분석하면서 제품이나 콘텐츠를 기획할 때 어떤 기준을 세워야 하는지 더욱 명확해졌고요. 다음 리서치를 더 깊고 실제적인 방향으로 이끌 수 있는 중요한 발판이 되어주기도 했죠.</span></span></span></p><p id=\"1caa360d-33e3-80b4-8eec-c52bab8537ab\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">무엇보다 온라인 사업을 시작할 때 PG 서비스 연결 뿐만 아니라, 사업자 등록, 통신판매업 신고 등 필수 절차들이 훨씬 더 간편해져야 한다는 점을 절실히 느꼈어요. 실제로 이후 리서치에서도, 사장님들이 여러 사이트를 오가며 각각의 신고 절차를 따로 진행해야 하는 불편함을 겪고 있다는 걸 확인할 수 있었어요.</span></span></span></p><p id=\"1caa360d-33e3-80ca-9156-ce05aba59b2f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이 문제를 해결하기 위해, </span><span class=\"css-q3ktjb\">토스페이먼츠에서는 사업자 등록과 통신판매업 신고를 한 번에 처리할 수 있는 서비스를 새롭게 개발</span><span class=\"css-1kxrhf3\">했고, 사장님들이 더 쉽고 빠르게 사업을 시작할 수 있도록 지원할 수 있었어요.</span></span></span></p><p id=\"1caa360d-33e3-801e-88da-d8a11d0baefd\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">또한, 사업자 등록 전·후로 알아야 할 정보 — 예를 들어 세금 신고, 택배 계약, 가격 설정, 절세 전략 등 사업 운영에 꼭 필요한 지식들을 담은 콘텐츠 100여 개도 함께 제작했어요. 이 콘텐츠들이 사장님들의 막막함을 덜어주고, 실제로 도움이 되는 출발점이 되길 바라면서요.</span></span></span></p><p id=\"1caa360d-33e3-80d7-84ab-e5d8436f7cee\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1caa360d-33e3-80e0-b605-f91803346d21\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1odxvuk\">해당 리서치 과정에서 발행된 콘텐츠 (일부)</span></span></span></p><p id=\"1caa360d-33e3-80c7-a1e2-cfb8906ceafd\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">사업자 등록과 신고</span></span></span></p><style data-emotion=\"css uswsmm\">.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ul class=\"css-uswsmm\"><style data-emotion=\"css 1hwiibq\">.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}</style><li id=\"1d1a360d-33e3-80fb-ab5b-f8448674d408\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css iynyr0\">.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}</style><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.tosspayments.com/blog/articles/semo-44?from=category\">쇼핑몰 창업 준비하는 사장님이 사업자 등록 신청하기 전 꼭 해야 할 일 총정리</a></span></span></li><li id=\"1d1a360d-33e3-80c9-9755-e79053c33368\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.tosspayments.com/blog/articles/semo-1?from=main\">사업자등록 신청, 제대로 하고 절세하기</a></span></span></li></ul><p id=\"1caa360d-33e3-80c4-ba11-f700117d65df\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">사입과 가격 책정</span></span></span></p><ul class=\"css-uswsmm\"><li id=\"1d1a360d-33e3-8089-9213-e5d4b954018f\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.tosspayments.com/blog/articles/semo-130\">사입이 처음인 사장님을 위한 사입 용어와 준비물 알아보기</a></span></span></li><li id=\"1d1a360d-33e3-8023-9c21-e716cd0d3981\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.tosspayments.com/blog/articles/semo-34\">초보 사장님이 꼭 알아야 할 상품 가격 결정 방법 총정리</a></span></span></li></ul><p id=\"1caa360d-33e3-802c-910a-e31f19225356\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">마케팅</span></span></span></p><ul class=\"css-uswsmm\"><li id=\"1d1a360d-33e3-80ee-af7c-d44ca876bed2\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.tosspayments.com/blog/articles/semo-9?from=search\">눈길을 사로잡는 상품 썸네일 제작 방법 5가지</a></span></span></li><li id=\"1d1a360d-33e3-8014-b3a8-c752443775b2\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.tosspayments.com/blog/articles/semo-40?from=search\">쇼핑몰 사장님을 위한 인스타그램 마케팅 총정리</a></span></span></li></ul><p id=\"1d1a360d-33e3-8083-ab7d-f26d8575b2cb\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1d1a360d-33e3-80a4-93ac-c593b210cf8d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1caa360d-33e3-804e-b049-ee12899337f7\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">B2B 리서처들에게 하고 싶은 말</span></span></span></h2><p id=\"1caa360d-33e3-8007-91d4-d09c4db296da\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">리서처는 도메인 지식이 필요한 리서치를 맡게 되는 일이 많죠. 이럴 때 </span><span class=\"css-q3ktjb\">작게라도 빠르게 직접 경험해보는 것만으로도 초기 이해도가 눈에 띄게 높아질 수 있어요.</span><span class=\"css-1kxrhf3\"> 그리고 그렇게 높아진 이해도는, 리서치가 얼마나 깊이 있는 인사이트로 이어질 수 있는지를 좌우하더라고요. </span></span></span></p><p id=\"1caa360d-33e3-8067-bdfd-edf98baca7fc\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">특히 B2B 리서치에서는 인사이트의 깊이나 제안의 실효성에 대해 아쉬움을 느낄 때가 많을텐데요. 이럴 땐 </span><span class=\"css-q3ktjb\">작은 단위라도 직접 경험해보는 과정이 도움이 될 수 있어요. </span><span class=\"css-1kxrhf3\">사용자를 더 입체적으로 이해할 수 있고, 리서치 방향을 훨씬 정교하게 설계할 수 있거든요.</span></span></span></p><p id=\"1caa360d-33e3-80b0-b945-dd31b5a29805\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">물론 이 접근이 </span><span class=\"css-q3ktjb\">모든 프로젝트에 무조건 적용될 수 있는 건 아니에요. </span><span class=\"css-1kxrhf3\">리서치의 목적, 서비스의 특성, 그리고 리서처가 실제로 사용자와 유사한 상황에 놓일 수 있는지를 함께 고려해 선택적으로 시도해보는 것이 중요하죠.</span></span></span></p><p id=\"1caa360d-33e3-8074-83a4-eac489fda681\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">그럼에도 분명한 건, 직접 부딪혀본 경험이 리서치의 깊이를 바꿀 수 있다는 거예요.</span></span></span></p><p id=\"1caa360d-33e3-808a-b100-d886de549cc1\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-1kxrhf3{white-space:pre-wrap;}토스페이먼츠는 온라인 결제를 담당하는 PG(Payment Gateway)사예요. 토스페이먼츠가 사장님 대신 결제를 처리하고 정산까지 도와주죠. 온라인 쇼핑몰과 카드사를 연결하는 ‘결제의 중간 다리’ 역할을 한다고 볼 수 있어요.\n처음 몇 달은 PG 서비스를 중심으로 유저 리서치를 진행했어요. 사장님들이 웹/앱 서비스를 어떻게 만드는지, PG사를 선택할 때 가장 중요한 요소는 무엇인지, 매출과 정산은 어떻게 관리하는지 등을 깊게 파고들었어요. 인터뷰에서 만난 어떤 사장님의 말을 듣기 전까지는요.\n.css-2sk6rv{font-size:19px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);white-space:pre-wrap;margin:24px 0;padding-left:20px;position:relative;}.css-2sk6rv::before{content:'';display:block;position:absolute;top:4px;left:0;width:2px;height:calc(100% - 4px * 2);padding:4px 0;background-color:var(--adaptiveGrey800);}\n“처음 온라인 결제를 준비할 때 .css-q3ktjb{white-space:pre-wrap;font-weight:bold;}필수 신고 절차를 몰랐어요. 홈페이지를 다 만들고 나서야 그 절차를 알아서 시간 낭비를 많이 했죠. 이런 과정을 한눈에 따라갈 수 있는 흐름이 있었으면 좋겠다고 생각했어요.”  .css-7mseny>*{margin-left:0;margin-right:0;}.css-7mseny>:last-child{margin-bottom:0;}blockquote>.css-7mseny:first-child>:first-child{margin-top:0;}\n\n직접 만나서 이야기를 들어보니 제가 몰랐던 다른 세계가 있더라고요. 사장님들이 실제로 겪는 문제들이 얼마나 중요한 문제인지, 사장님들이 말하지 않는 숨겨진 고충은 없는지 파악하는 것도 쉽지 않았어요. 저는 사업을 해본 적이 없었으니까요. \n그때 단순히 결제 프로세스를 넘어, 사업 운영 전반의 니즈와 문제를 더 깊이 이해할 필요가 있다고 느꼈어요. B2C 서비스는 리서처가 직접 써보며 공감대를 형성할 수 있지만 B2B는 그 자체를 직접 경험하기 어려운 한계가 있잖아요.\n사장님들의 어려움을 제대로 이해하려면 직접 겪어보는 수밖에 없겠더라고요. 그래서 결심했죠. 진짜 사장님이 되어보기로요.\n\n\n.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}\n.css-p4abj2{display:contents;line-height:1.55;}UX리서처, 진짜 사장님이 되다\n\n1단계: 사업자 등록하기\n사업을 시작하는 것부터 쉽지 않았어요. 진행해야 할 행정 절차가 참 많더라고요. 사업자 유형, 업종 정의, 사업장 주소, 사업용 전화번호 등을 하나하나 입력해 사업자 등록을 마쳐야 했고, 온라인 판매를 위해선 구매안전서비스 이용 확인증을 발급받고, 통신판매업 신고도 별도로 진행해야 했어요.\n예상치 못한 절차들이 계속 나와서, 사업을 시작하기도 전에 이미 벅찬 느낌이 들었어요. 사장님들도 처음 사업을 시작할 때 비슷한 어려움을 겪겠구나 싶었어요.\n\n2단계: 판매 아이템 정하기\n판매할 아이템을 찾기 위해 동대문 새벽시장에도 가봤는데요. 사장님들의 포스에 눌려 말 한마디도 쉽게 못 꺼내겠더라고요. ‘깔(컬러)’, ‘장끼(영수증)’, ‘미송(품절 시 선결제 후 예약)’ 같은 거래 용어를 하나도 모르니까요.\n몇 번 시장을 오가다 보니, 말투나 준비물도 점점 현장에 맞춰졌어요. 처음엔 회사원 복장으로 갔다가, 나중엔 현금 가방과 사입 가방까지 챙기는 사장님 모드가 됐죠. 그렇게 시장을 돌아다니다가 드디어 아이템을 정했어요.\n양말. 뜬금없이 들릴 수도 있겠지만, 단가가 낮고 판매가 쉬울 거라 생각했거든요.\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}\n.css-1odxvuk{white-space:pre-wrap;font-style:italic;}동대문 새벽시장의 풍경\n\n3단계: 쇼핑몰 구축하기\n양말을 팔아야겠다고 결정하면서 쇼핑몰도 함께 준비했어요. 비용을 아끼려고 직접 촬영 공간을 만들고, 지인을 모델로 섭외해 촬영을 진행했는데 생각보다 훨씬 어려운 과정이더라고요. 조명 세팅, 구도 잡기, 보정 작업… 모든 게 처음이어서 예상보다 시간과 에너지가 많이 들어갔죠. 초기 예산에서도 큰 비중을 차지했고요.\n그렇게 우여곡절 끝에 상세페이지 구성, 상품 등록, 가격 설정 등을 하나씩 해나갔고, 약 한 달 만에 쇼핑몰을 오픈했어요.\n\n제품 촬영 과정\n\n\n드디어, 첫 주문이 들어오다\n첫 주문이 들어왔을 때의 기쁨이 아직도 생생해요. 상품을 포장해 택배로 보내고, 정산 금액을 직접 받고 나니 “아, 내가 진짜로 양말을 팔았구나” 하는 실감이 났죠. \n하지만 막상 판매를 해보니, 양말은 단가가 낮은 만큼 정말 많이 팔아야 수익이 남는 구조였어요. 이 아이템을 잘 선택한 게 맞을까 고민되고 혼란스럽더라고요.\n여러 채널에서 판매한 정산 금액을 확인하고 데이터를 관리하는 과정도 번거로웠어요. 리서치 과정에서 사장님들이 “여러 판매처의 정산 내역을 일일이 확인하는 게 너무 불편하다”고 자주 이야기해주셨는데요. 직접 경험해보니, 왜 그런 이야기가 나왔는지 알겠더라고요.\n\n오픈한 실제 쇼핑몰 \n\n\n물건 판매는 끝이 아니라 시작이다\n쇼핑몰을 준비할 땐 “일단 오픈하는 게 목표다”라는 마음으로 달렸는데, 막상 오픈하고 나니 너무 당연하게도 그게 끝이 아니라 진짜 시작이더라고요. 이제는 어떻게 하면 상품을 잘 팔 수 있을지 고민하고 방법을 찾아야 했죠.\n우선 상품이 팔리려면 ‘노출’이 돼야 했고, 광고와 홍보가 필수였거든요. 그래서 유튜브, 블로그, 사장님들 커뮤니티 등을 참고해가며 키워드별·상품별·타겟별로 광고를 직접 집행하고, 성과를 분석하면서 전략도 조금씩 조정해 나갔어요.\n모든 게 처음이다 보니, 온라인에서 정보를 찾는 데에도 시간이 많이 들었어요. 검색해보면 오래됐거나 부정확한 정보가 대부분이었고, 구체적인 설명보다는 흐름만 짚는 자료가 많았거든요. 같은 키워드로 여러 번 검색하고, 여러 자료를 비교해가며 겨우 내용을 파악했죠.\n이렇게 처음부터 끝까지 부딪혀보면서, 사업을 운영하는 데는 생각보다 훨씬 많은 단계와 결정이 필요하다는 걸 절실히 깨달았어요. 사업자 등록, 상품 소싱, 쇼핑몰 제작, 마케팅, 정산 관리까지 — 어느 하나 단순하거나 중요도가 낮은 과정은 없었고, 한 단계라도 꼬이면 그 여파가 다음 단계에 고스란히 이어졌어요.\n\n\n맨 땅에 헤딩으로 이뤄낸 결과물\n직접 사업을 준비하면서 단순한 인터뷰만으로는 파악하기 어려웠던 사장님들의 ‘진짜 고충’을 훨씬 더 깊이 이해할 수 있었어요. 사업자의 여정을 단계별로 분석하면서 제품이나 콘텐츠를 기획할 때 어떤 기준을 세워야 하는지 더욱 명확해졌고요. 다음 리서치를 더 깊고 실제적인 방향으로 이끌 수 있는 중요한 발판이 되어주기도 했죠.\n무엇보다 온라인 사업을 시작할 때 PG 서비스 연결 뿐만 아니라, 사업자 등록, 통신판매업 신고 등 필수 절차들이 훨씬 더 간편해져야 한다는 점을 절실히 느꼈어요. 실제로 이후 리서치에서도, 사장님들이 여러 사이트를 오가며 각각의 신고 절차를 따로 진행해야 하는 불편함을 겪고 있다는 걸 확인할 수 있었어요.\n이 문제를 해결하기 위해, 토스페이먼츠에서는 사업자 등록과 통신판매업 신고를 한 번에 처리할 수 있는 서비스를 새롭게 개발했고, 사장님들이 더 쉽고 빠르게 사업을 시작할 수 있도록 지원할 수 있었어요.\n또한, 사업자 등록 전·후로 알아야 할 정보 — 예를 들어 세금 신고, 택배 계약, 가격 설정, 절세 전략 등 사업 운영에 꼭 필요한 지식들을 담은 콘텐츠 100여 개도 함께 제작했어요. 이 콘텐츠들이 사장님들의 막막함을 덜어주고, 실제로 도움이 되는 출발점이 되길 바라면서요.\n\n해당 리서치 과정에서 발행된 콘텐츠 (일부)\n사업자 등록과 신고\n.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\n.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}쇼핑몰 창업 준비하는 사장님이 사업자 등록 신청하기 전 꼭 해야 할 일 총정리\n사업자등록 신청, 제대로 하고 절세하기\n\n사입과 가격 책정\n\n사입이 처음인 사장님을 위한 사입 용어와 준비물 알아보기\n초보 사장님이 꼭 알아야 할 상품 가격 결정 방법 총정리\n\n마케팅\n\n눈길을 사로잡는 상품 썸네일 제작 방법 5가지\n쇼핑몰 사장님을 위한 인스타그램 마케팅 총정리\n\n\n\nB2B 리서처들에게 하고 싶은 말\n리서처는 도메인 지식이 필요한 리서치를 맡게 되는 일이 많죠. 이럴 때 작게라도 빠르게 직접 경험해보는 것만으로도 초기 이해도가 눈에 띄게 높아질 수 있어요. 그리고 그렇게 높아진 이해도는, 리서치가 얼마나 깊이 있는 인사이트로 이어질 수 있는지를 좌우하더라고요. \n특히 B2B 리서치에서는 인사이트의 깊이나 제안의 실효성에 대해 아쉬움을 느낄 때가 많을텐데요. 이럴 땐 작은 단위라도 직접 경험해보는 과정이 도움이 될 수 있어요. 사용자를 더 입체적으로 이해할 수 있고, 리서치 방향을 훨씬 정교하게 설계할 수 있거든요.\n물론 이 접근이 모든 프로젝트에 무조건 적용될 수 있는 건 아니에요. 리서치의 목적, 서비스의 특성, 그리고 리서처가 실제로 사용자와 유사한 상황에 놓일 수 있는지를 함께 고려해 선택적으로 시도해보는 것이 중요하죠.\n그럼에도 분명한 건, 직접 부딪혀본 경험이 리서치의 깊이를 바꿀 수 있다는 거예요.",
        "content": "사장님들을 더 깊게 이해하고 싶어, 직접 사장님이 되어봤습니다. 사업자 등록부터 판매까지 여정을 통해 배운 점들을 들려드릴게요.",
        "contentSnippet": "사장님들을 더 깊게 이해하고 싶어, 직접 사장님이 되어봤습니다. 사업자 등록부터 판매까지 여정을 통해 배운 점들을 들려드릴게요.",
        "guid": "https://toss.tech/article/34899",
        "isoDate": "2025-04-10T06:52:00.000Z"
      },
      {
        "title": "토스 프론트엔드에 이력서 없이 리포지토리 링크로 지원하세요 (~5/31)",
        "link": "https://toss.tech/article/frontend-apply-without-resume",
        "pubDate": "Tue, 08 Apr 2025 02:00:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1cfa360d-33e3-80bb-9231-de4ff71eed38\" class=\"css-of5acw\"><style data-emotion=\"css 1pgssrp\">.css-1pgssrp{max-width:100%;border-radius:16px;}</style><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/554e25b2-9d59-4609-a5f1-07e0eecad8bd/bg.jpg\" alt=\"\" class=\"css-1pgssrp\"/></figure><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1c9a360d-33e3-80f1-b11c-cd1e244d458a\" class=\"css-14on8x8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">안녕하세요, 토스 프론트엔드 엔지니어링 헤드 박서진입니다.</span></span></span></p><p id=\"1c9a360d-33e3-8076-8a92-e54953941cda\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스에서 이력서 없이 &quot;GitHub 리포지토리 링크로 지원하기&quot; 메뉴가 열렸어요. 이력서 작성에 고민해보신 적이 있나요? 이력서를 다듬고 최신화하는 것이 쉽지 않죠. 토스에는 여러분의 고민한 내용이 남긴 GitHub 저장소 링크 하나만 제출하면 돼요. 저희 프론트엔드 리더들은 오직 코드를 기준으로 평가할게요.</span></span></span></p><p id=\"1c9a360d-33e3-801b-82f0-c034fb43e174\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">새로운 전형은 </span><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">2025년 5월 31일 23:59</span><span class=\"css-1kxrhf3\">까지 열려 있어요. 이력서가 아니라 코드만으로 평가받고 싶으신 분은 이번 기회를 놓치지 마세요.</span></span></span></p><p id=\"1c9a360d-33e3-80e7-b6b9-f6cc4b3749bc\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css 1c1qox8\">.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}</style><h2 id=\"1c9a360d-33e3-8075-a7a9-fdd6e535a0ed\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><style data-emotion=\"css p4abj2\">.css-p4abj2{display:contents;line-height:1.55;}</style><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">이런 리포지토리를 찾아요</span></span></span></h2><p id=\"1c9a360d-33e3-808f-8f45-d2644c30b642\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스가 중요하게 생각하는 요소들을 다음 “리포지토리 제출 가이드” 에 담았어요.</span></span></span></p><style data-emotion=\"css nv7vyi\">.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}</style><aside class=\"css-nv7vyi\"><style data-emotion=\"css 123co55\">.css-123co55{font-size:19px;letter-spacing:0em;line-height:1.6;margin:24px 0 0;font-weight:400;color:var(--adaptiveGrey900);background-color:transparent;}</style><h4 class=\"css-123co55\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">리포지토리 제출 가이드</span></span></span></h4><div class=\"css-1vn47db\"><style data-emotion=\"css hokoge\">.css-hokoge{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;counter-reset:numberedList;}.css-hokoge ul,.css-hokoge ol{margin:16px 0 0;}.css-hokoge>li{counter-increment:numberedList;margin-bottom:16px;padding-left:24px;}.css-hokoge>li:last-of-type{margin-bottom:0;}.css-hokoge>li>span{position:relative;}.css-hokoge>li>span>:first-child::before{content:counter(numberedList) '.';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ol class=\"css-hokoge\"><style data-emotion=\"css 1hwiibq\">.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}</style><li id=\"1c9a360d-33e3-80d7-be85-f8ecb6e3aabe\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">모듈화 및 코드 품질을 지키기 위해 고민한 리포지토리면 좋아요. </span></span></span></li><li id=\"1c9a360d-33e3-80df-be26-dbf1950483d9\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">명확한 디렉토리 구조로 코드 파일을 찾고 수정하기 쉽도록 고민한 리포지토리면 좋아요.</span></span></span></li><li id=\"1c9a360d-33e3-806e-98a4-fcd6b7296746\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">TypeScript를 정확하게 사용하기 위해 고민한 리포지토리면 좋아요.</span></span></span></li><li id=\"1c9a360d-33e3-8083-9779-d69284f3a763\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">제품의 완성도(성능 또는 사용 경험)를 끌어올리기 위해 고민한 리포지토리면 좋아요.</span></span></span></li><li id=\"1c9a360d-33e3-8090-93ff-ef5fa3dab0ec\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">커밋이나 Pull Request를 읽기 쉽게 나눠서 협업을 쉽게 한 리포지토리면 좋아요.</span></span></span></li><li id=\"1c9a360d-33e3-807e-a21d-ec64ed222166\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">화려한 기술이나 코드 패턴보다는 본질적인 코드의 고민이 드러나는 리포지토리면 좋아요.</span></span></span></li><li id=\"1c9a360d-33e3-8072-a3f4-d53ddecf0c0c\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">프로젝트가 어떤 것을 구현하는지 알 수 있는 README가 있는 리포지토리가 좋아요.</span></span></span></li></ol></div></aside><style data-emotion=\"css 1feg9au\">.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}</style><h3 id=\"1c9a360d-33e3-8071-8962-f5e765130de3\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">코드 품질, 모듈화, 디렉토리 구조</span></span></span></h3><p id=\"1c9a360d-33e3-803c-8f07-dd4dab99bf4d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스는 프론트엔드 코드의 품질, 모듈화, 디렉토리 구조를 제일 중요하게 생각해요. 토스에서는 소스 코드가 하루에 수십 번 업데이트되고 있는 만큼, 수정하기 쉬운 코드를 작성하는 것이 필수예요. 이런 핵심적인 요소들은 </span><style data-emotion=\"css iynyr0\">.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}</style><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://frontend-fundamentals.com/\">Frontend Fundamentals의 “변경하기 쉬운 코드”</a><span class=\"css-1kxrhf3\"> 에서도 다루고 있어요.</span></span></span></p><p id=\"1c9a360d-33e3-8037-9e42-c18b85803738\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">여러분의 리포지토리에 “변경하기 쉬운 코드”, “재사용하기 쉬운 모듈”, “소스 코드를 쉽게 찾을 수 있는 디렉토리 구조”에 대한 고민이 담겨 있다면, 자신 있게 공유해 보세요.</span></span></span></p><h3 id=\"1c9a360d-33e3-808a-8d93-ee6125e0aaae\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">TypeScript</span></span></span></h3><p id=\"1c9a360d-33e3-8028-bc57-dd0eb4fd5330\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스에서는 모든 코드베이스가 TypeScript로 작성되어 있어요. 코드를 실행하기 전에 오류를 미리 감지하기 위해서는, 함수나 컴포넌트의 입출력 형식을 정확하게 TypeScript로 표현하는 능력이 중요해요. </span></span></span></p><p id=\"1c9a360d-33e3-8001-9341-f8a4adba17ca\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">여러분이 TypeScript 타입을 정확하고 엄격하게 작성하기 위해 노력한 경험이 있는 코드라면, 꼭 공유해 주세요.</span></span></span></p><h3 id=\"1c9a360d-33e3-805c-8eb2-ef82765d55e9\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">제품의 완성도: 성능 또는 사용자 경험</span></span></span></h3><p id=\"1c9a360d-33e3-80cf-9646-d28527f21f6d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스는 플랫폼 기업으로서, 최고의 사용자 경험이 비즈니스의 핵심이에요. 모바일 제품은 네이티브 앱과 구별하기 어려운 정도를 목표로 완성도를 높이려고 노력하고 있어요. 데스크톱 제품은 </span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://toss.tech/article/firesidechat_frontend_11\">DEUS 에디터</a><span class=\"css-1kxrhf3\">처럼 성능이 중요한 제품들이 계속 등장하고 있어요.</span></span></span></p><p id=\"1c9a360d-33e3-80ff-a32e-f3b112ad64f3\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">사용자가 로딩 화면을 오래 기다리지 않고, 화면이 끊기거나 부자연스럽게 느껴지지 않도록 고민한 코드가 있으면 보여 주세요.</span></span></span></p><h3 id=\"1c9a360d-33e3-801a-8ab7-ddb4c770325a\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">협업</span></span></span></h3><p id=\"1c9a360d-33e3-8052-b27b-f5d260451d6a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스에서는 프론트엔드 개발자들이 “챕터” 라고 하는 직군을 이루어 서로의 코드를 리뷰하고 지식을 공유하며 협업하고 있어요. 코드 컨벤션을 지키고 함께 성장하는 개발 문화를 만들기 위해 협업 능력은 필수예요.</span></span></span></p><p id=\"1c9a360d-33e3-8015-8a7d-cd2d930751ce\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">다른 개발자와 효율적으로 협업하기 위해 Pull Request나 커밋의 단위, 커밋 메시지 등에 신경쓴 리포지토리가 있다면, 공유해 주세요.</span></span></span></p><p id=\"1c9a360d-33e3-8040-aa04-d0752a5580ce\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1c9a360d-33e3-8086-a29d-f9596ab13712\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">화려한 기술이나 코드 패턴은 중요하지 않아요</span></span></span></h2><p id=\"1c9a360d-33e3-8075-bac6-f4e7eb6fe0b6\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">최근 프론트엔드 생태계에는 새로운 기술과 코드 패턴이 계속 등장하고 있어요. TanStack의 라우터나 폼, 기능 분할 설계(FSD) 같은 새로운 패턴도 제안되고 있죠.</span></span></span></p><p id=\"1c9a360d-33e3-801e-a879-c60570d93e47\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">하지만 토스 프론트엔드에서는 이런 새로운 기술이나 패턴을 아는지 여부를 중요하게 생각하지 않아요. 대신 수정하기 쉬운 코드에 대한 여러분만의 고민과 철학, 제품 완성도에 몰입해 본 경험, 다른 프론트엔드 개발자들과 효율적으로 협업할 수 있는 능력 같은 것들을 중요하게 보고 있어요.</span></span></span></p><p id=\"1c9a360d-33e3-809e-9975-cf5d8b969e13\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">특정 기술의 사용 여부보다는, 여러분의 고민과 철학이 담긴 코드를 보여주세요.</span></span></span></p><p id=\"1c9a360d-33e3-8056-9798-e8968013ec50\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1c9a360d-33e3-8056-a936-e9cc1ff9f8e1\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">이런 부분은 주의해 주세요</span></span></span></h2><p id=\"1c9a360d-33e3-803b-8f39-c719b1776e1e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">전체에게 공개되어 있는 리포지토리 링크를 공유해 주세요. 재직하고 있는 회사의 리포지토리처럼, 비공개로 개발하고 있는 리포지토리는 공유하지 마세요. </span></span></span></p><p id=\"1c9a360d-33e3-8018-a0b8-cd3e5f0f0e3c\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1c9a360d-33e3-80ed-8028-ff23fcb8964b\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">토스 프론트엔드 챕터와 함께해요</span></span></span></h2><p id=\"1c9a360d-33e3-80bd-bb40-dcb90c79bda1\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스의 프론트엔드 개발자들은 단순히 비즈니스 요구사항을 구현해 내는 것을 넘어, 프론트엔드 기술이 회사의 승리 전략이 될 수 있도록 탁월한 프론트엔드 개발 역량을 갖추기 위해 노력하고 있어요.</span></span></span></p><style data-emotion=\"css uswsmm\">.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ul class=\"css-uswsmm\"><li id=\"1c9a360d-33e3-8048-ac80-ff8812b07c21\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://github.com/toss\">프론트엔드 기술에 대한 고민을 오픈 소스로 공개</a><span class=\"css-1kxrhf3\">하며, 1년만에 1만 개 이상의 GitHub 스타와 NPM 기준 주간 수십만 회 이상의 다운로드를 기록했어요. Storybook, Ink와 같은 유명 오픈소스 프로젝트들에서도 토스의 라이브러리들을 채택하고 있어요.</span></span></span></li><li id=\"1c9a360d-33e3-8066-ae8c-dd1a30fd28e7\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스의 프론트엔드 개발환경을 연내에 공개하여, 더 넓은 프론트엔드 개발에 대해서도 함께 고민하려고 해요. (</span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://toss.tech/article/react-native-2024\">참고 아티클 1</a><span class=\"css-1kxrhf3\">, </span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://toss.tech/article/rn-toss-bedrock\">참고 아티클 2</a><span class=\"css-1kxrhf3\">)</span></span></span></li><li id=\"1c9a360d-33e3-804b-8e73-f2627653ec44\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">좋은 프론트엔드 코드란 무엇일까? 이런 고민을 </span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://frontend-fundamentals.com/\">“Frontend Fundamentals”</a><span class=\"css-1kxrhf3\"> 라고 하는 프로젝트로 출범시켜, 1천명 이상의 개발자와 함께 소통하고 있어요.</span></span></span></li><li id=\"1c9a360d-33e3-80ef-b9fe-cdf6158a57f2\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">올해부터는 한국의 개발 컨퍼런스를 넘어 </span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://x.com/TossFrontend/status/1907936087106027728\">세계적인 컨퍼런스</a><span class=\"css-1kxrhf3\">에 참여하며 프론트엔드 생태계에 지속적으로 기여하려고 해요.</span></span></span></li></ul><p id=\"1c9a360d-33e3-802f-83b5-e5583e039746\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1c9a360d-33e3-8025-b952-d802e5d5e1a9\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">여러분의 코드로 지원해 보세요</span></span></span></h2><p id=\"1c9a360d-33e3-80bb-a48e-e581931dd940\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">지금까지 프론트엔드 개발에 진심이었고, 앞으로 프론트엔드 개발을 회사의 승리 전략으로 만드는 여정에 함께하고 싶다면, 부담 없이 “이력서 없이 리포지토리 링크로 지원하기” 전형으로 지원해 보세요. </span></span></span></p><p id=\"1c9a360d-33e3-8063-85f4-e93ba6ef2a0f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">여러분의 리포지토리 링크에서 보이는 열정과 고민의 깊이를 기대할게요.</span></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-1kxrhf3{white-space:pre-wrap;}안녕하세요, 토스 프론트엔드 엔지니어링 헤드 박서진입니다.\n토스에서 이력서 없이 \"GitHub 리포지토리 링크로 지원하기\" 메뉴가 열렸어요. 이력서 작성에 고민해보신 적이 있나요? 이력서를 다듬고 최신화하는 것이 쉽지 않죠. 토스에는 여러분의 고민한 내용이 남긴 GitHub 저장소 링크 하나만 제출하면 돼요. 저희 프론트엔드 리더들은 오직 코드를 기준으로 평가할게요.\n새로운 전형은 .css-q3ktjb{white-space:pre-wrap;font-weight:bold;}2025년 5월 31일 23:59까지 열려 있어요. 이력서가 아니라 코드만으로 평가받고 싶으신 분은 이번 기회를 놓치지 마세요.\n\n.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}\n.css-p4abj2{display:contents;line-height:1.55;}이런 리포지토리를 찾아요\n토스가 중요하게 생각하는 요소들을 다음 “리포지토리 제출 가이드” 에 담았어요.\n.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}.css-123co55{font-size:19px;letter-spacing:0em;line-height:1.6;margin:24px 0 0;font-weight:400;color:var(--adaptiveGrey900);background-color:transparent;}\n리포지토리 제출 가이드\n.css-hokoge{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;counter-reset:numberedList;}.css-hokoge ul,.css-hokoge ol{margin:16px 0 0;}.css-hokoge>li{counter-increment:numberedList;margin-bottom:16px;padding-left:24px;}.css-hokoge>li:last-of-type{margin-bottom:0;}.css-hokoge>li>span{position:relative;}.css-hokoge>li>span>:first-child::before{content:counter(numberedList) '.';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\n모듈화 및 코드 품질을 지키기 위해 고민한 리포지토리면 좋아요. \n명확한 디렉토리 구조로 코드 파일을 찾고 수정하기 쉽도록 고민한 리포지토리면 좋아요.\nTypeScript를 정확하게 사용하기 위해 고민한 리포지토리면 좋아요.\n제품의 완성도(성능 또는 사용 경험)를 끌어올리기 위해 고민한 리포지토리면 좋아요.\n커밋이나 Pull Request를 읽기 쉽게 나눠서 협업을 쉽게 한 리포지토리면 좋아요.\n화려한 기술이나 코드 패턴보다는 본질적인 코드의 고민이 드러나는 리포지토리면 좋아요.\n프로젝트가 어떤 것을 구현하는지 알 수 있는 README가 있는 리포지토리가 좋아요.\n\n.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}\n코드 품질, 모듈화, 디렉토리 구조\n토스는 프론트엔드 코드의 품질, 모듈화, 디렉토리 구조를 제일 중요하게 생각해요. 토스에서는 소스 코드가 하루에 수십 번 업데이트되고 있는 만큼, 수정하기 쉬운 코드를 작성하는 것이 필수예요. 이런 핵심적인 요소들은 .css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}Frontend Fundamentals의 “변경하기 쉬운 코드” 에서도 다루고 있어요.\n여러분의 리포지토리에 “변경하기 쉬운 코드”, “재사용하기 쉬운 모듈”, “소스 코드를 쉽게 찾을 수 있는 디렉토리 구조”에 대한 고민이 담겨 있다면, 자신 있게 공유해 보세요.\nTypeScript\n토스에서는 모든 코드베이스가 TypeScript로 작성되어 있어요. 코드를 실행하기 전에 오류를 미리 감지하기 위해서는, 함수나 컴포넌트의 입출력 형식을 정확하게 TypeScript로 표현하는 능력이 중요해요. \n여러분이 TypeScript 타입을 정확하고 엄격하게 작성하기 위해 노력한 경험이 있는 코드라면, 꼭 공유해 주세요.\n제품의 완성도: 성능 또는 사용자 경험\n토스는 플랫폼 기업으로서, 최고의 사용자 경험이 비즈니스의 핵심이에요. 모바일 제품은 네이티브 앱과 구별하기 어려운 정도를 목표로 완성도를 높이려고 노력하고 있어요. 데스크톱 제품은 DEUS 에디터처럼 성능이 중요한 제품들이 계속 등장하고 있어요.\n사용자가 로딩 화면을 오래 기다리지 않고, 화면이 끊기거나 부자연스럽게 느껴지지 않도록 고민한 코드가 있으면 보여 주세요.\n협업\n토스에서는 프론트엔드 개발자들이 “챕터” 라고 하는 직군을 이루어 서로의 코드를 리뷰하고 지식을 공유하며 협업하고 있어요. 코드 컨벤션을 지키고 함께 성장하는 개발 문화를 만들기 위해 협업 능력은 필수예요.\n다른 개발자와 효율적으로 협업하기 위해 Pull Request나 커밋의 단위, 커밋 메시지 등에 신경쓴 리포지토리가 있다면, 공유해 주세요.\n\n화려한 기술이나 코드 패턴은 중요하지 않아요\n최근 프론트엔드 생태계에는 새로운 기술과 코드 패턴이 계속 등장하고 있어요. TanStack의 라우터나 폼, 기능 분할 설계(FSD) 같은 새로운 패턴도 제안되고 있죠.\n하지만 토스 프론트엔드에서는 이런 새로운 기술이나 패턴을 아는지 여부를 중요하게 생각하지 않아요. 대신 수정하기 쉬운 코드에 대한 여러분만의 고민과 철학, 제품 완성도에 몰입해 본 경험, 다른 프론트엔드 개발자들과 효율적으로 협업할 수 있는 능력 같은 것들을 중요하게 보고 있어요.\n특정 기술의 사용 여부보다는, 여러분의 고민과 철학이 담긴 코드를 보여주세요.\n\n이런 부분은 주의해 주세요\n전체에게 공개되어 있는 리포지토리 링크를 공유해 주세요. 재직하고 있는 회사의 리포지토리처럼, 비공개로 개발하고 있는 리포지토리는 공유하지 마세요. \n\n토스 프론트엔드 챕터와 함께해요\n토스의 프론트엔드 개발자들은 단순히 비즈니스 요구사항을 구현해 내는 것을 넘어, 프론트엔드 기술이 회사의 승리 전략이 될 수 있도록 탁월한 프론트엔드 개발 역량을 갖추기 위해 노력하고 있어요.\n.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n프론트엔드 기술에 대한 고민을 오픈 소스로 공개하며, 1년만에 1만 개 이상의 GitHub 스타와 NPM 기준 주간 수십만 회 이상의 다운로드를 기록했어요. Storybook, Ink와 같은 유명 오픈소스 프로젝트들에서도 토스의 라이브러리들을 채택하고 있어요.\n토스의 프론트엔드 개발환경을 연내에 공개하여, 더 넓은 프론트엔드 개발에 대해서도 함께 고민하려고 해요. (참고 아티클 1, 참고 아티클 2)\n좋은 프론트엔드 코드란 무엇일까? 이런 고민을 “Frontend Fundamentals” 라고 하는 프로젝트로 출범시켜, 1천명 이상의 개발자와 함께 소통하고 있어요.\n올해부터는 한국의 개발 컨퍼런스를 넘어 세계적인 컨퍼런스에 참여하며 프론트엔드 생태계에 지속적으로 기여하려고 해요.\n\n\n여러분의 코드로 지원해 보세요\n지금까지 프론트엔드 개발에 진심이었고, 앞으로 프론트엔드 개발을 회사의 승리 전략으로 만드는 여정에 함께하고 싶다면, 부담 없이 “이력서 없이 리포지토리 링크로 지원하기” 전형으로 지원해 보세요. \n여러분의 리포지토리 링크에서 보이는 열정과 고민의 깊이를 기대할게요.",
        "content": "이력서 작성에 고민해보신 적이 있나요? 토스에는 여러분의 고민한 내용이 남긴 GitHub 저장소 링크 하나만 제출하면 돼요.",
        "contentSnippet": "이력서 작성에 고민해보신 적이 있나요? 토스에는 여러분의 고민한 내용이 남긴 GitHub 저장소 링크 하나만 제출하면 돼요.",
        "guid": "https://toss.tech/article/frontend-apply-without-resume",
        "isoDate": "2025-04-08T02:00:00.000Z"
      },
      {
        "title": "캐시를 적용하기 까지의 험난한 길 (TPS 1만 안정적으로 서비스하기)",
        "link": "https://toss.tech/article/34481",
        "pubDate": "Mon, 31 Mar 2025 02:32:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1baa360d-33e3-806a-b40f-df5511c211dc\" class=\"css-14on8x8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">안녕하세요, 토스뱅크 Server Developer 김경윤 입니다.</span></span></span></p><p id=\"1c7a360d-33e3-8071-8b19-d87f77327073\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스 커뮤니티, 그리고 토스뱅크에서는 하루에 수 백번의 라이브 배포가 일어나고 있으며 다양한 개선점과 신규 제품들이 빠르게 출시되고 있어요. 이렇게 많은 배포를 기반으로 토스뱅크가 성장하면서 토스뱅크를 이용하는 사용자도 많아졌는데요. 이로 인해서 TPS가 평균 1만, 최대 2만까지 늘어난 약관(terms) 서버에 안정적인 서비스 제공을 위해 캐시를 적용한 이야기를 들려드리려고 해요.</span></span></span></p><style data-emotion=\"css 1c1qox8\">.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}</style><h2 id=\"1baa360d-33e3-8037-a07e-dfd084f588b9\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><style data-emotion=\"css p4abj2\">.css-p4abj2{display:contents;line-height:1.55;}</style><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">Database: 더 이상 버틸 수 없다!</span></span></span></h2><p id=\"1baa360d-33e3-802c-af29-c8c30a9c32ae\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">약관 서버는 사용자가 동의 또는 철회한 약관 및 동의서 동의 여부를 기록하고 조회할 수 있는 서비스예요. 사용자가 동의 그리고 철회하는 경우는 그렇게 많지 않지만, 동의 여부에 따라서 개인 정보를 제3자에게 제공해도 되는지, 토스뱅크가 사용해도 되는지 등 다양한 비지니스에서 약관 및 동의서 동의 여부를 확인해요. </span></span></span></p><p id=\"1c3a360d-33e3-8088-94f7-eacf0282f641\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">(앞으로는 ‘약관 및 동의서’를 간단히 ‘약관’이라고 부를게요.)</span></span></span></p><p id=\"1bda360d-33e3-808e-8068-dcc51f348f8f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1bda360d-33e3-80f0-805a-ca38e6f8ba2e\" class=\"css-of5acw\"><style data-emotion=\"css 1pgssrp\">.css-1pgssrp{max-width:100%;border-radius:16px;}</style><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/7feb8944-5dee-4996-903c-d9db84387ab7/image.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1c7a360d-33e3-805c-a669-fc32ed3b9857\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">어느 날, 토스뱅크에서 새로운 서비스를 배포하면서 TPS가 급증했고, 이로 인해 DB 조회량이 급증하여 DB 부하가 심각해졌었어요. 이 트래픽이 유지될 경우 다른 서비스에도 문제가 생길 수 있다고 판단했고, 급히 롤백을 진행하며 DB 부하를 줄일 방안을 고민하게 되었어요. 그 결과, 많은 분들이 알고 계신 ‘캐시’를 적용하기로 했지만, 막상 시도해 보니 생각보다 간단치 않았어요.</span></span></span></p><p id=\"1baa360d-33e3-8002-a974-d075f222a900\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1baa360d-33e3-8069-8da9-c031ca4b0d95\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">캐시 적용은 보다 신중하게</span></span></span></h2><p id=\"1baa360d-33e3-8001-a565-e0b8751ccd66\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이 글을 읽으면서, “어? 그럼 Replication된 Database를 두고 부하를 분산하면 되는거 아니야?” 라고 생각할 수 있어요. 약관은 토스뱅크 고객의 개인정보와 밀접한 연관성이 있어요. 약관 동의 여부는 사용자의 정보를 특정 목적으로 이용해도 되는지, 제3자에게 공유가 되도 되는지 결정하는 기준이기 때문이에요. </span></span></span></p><p id=\"1baa360d-33e3-80ca-ac4a-c4b7ec207d3f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그래서 약관 동의 여부는 값이 DB에 Commit 되는 순간, 바로 다음 요청에 DB에 저장된 값이 정확하게 응답되어야해요. 이를 </span><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">Strong Consistency</span><span class=\"css-1kxrhf3\">라고 부르며, 데이터의 무결성을 보장하기 위해 필수적이에요. 만약, 잘못된 응답을 한 번이라도 발생하면, 고객이 약관을 철회한 이후에도 개인정보가 공유되는 등의 보안 문제가 발생할 수 있어요. 따라서 데이터 신뢰성과 정확성을 보장하기 위해 Replication Database는 사용하지 않기로 했어요. Replication 구조에서는 복제 지연(Replication Delay)이 발생할 가능성이 있기 때문이에요. 대신, Strong Consistency를 유지하면서도 빠르게 조회가 가능한 Redis Cache를 활용해 고객의 약관 동의 상태를 안전하게 관리하기로 결정했어요.</span></span></span></p><style data-emotion=\"css nv7vyi\">.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}</style><aside class=\"css-nv7vyi\"><style data-emotion=\"css 123co55\">.css-123co55{font-size:19px;letter-spacing:0em;line-height:1.6;margin:24px 0 0;font-weight:400;color:var(--adaptiveGrey900);background-color:transparent;}</style><h4 class=\"css-123co55\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">복제 지연(Replication Delay)?</span><span class=\"css-1kxrhf3\">\n\n주 DB(Primary)와 보조 DB(Replica) 간의 데이터 동기화가 지연되는 현상</span></span></span></h4></aside><p id=\"1baa360d-33e3-80be-8df9-fe05dfb2a84a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css 1feg9au\">.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}</style><h3 id=\"1baa360d-33e3-804e-a4ab-e8585037e40d\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이러한 방식으로 캐시를 적용했어요!</span></span></span></h3><figure id=\"1bda360d-33e3-80b4-a332-c0deed03a56d\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/cb4390cc-0d43-4d98-998f-ff21a1d7102d/image.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1baa360d-33e3-80cc-b17f-eb7cd6d25287\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">약관 서버는 대부분 조회성으로 캐시를 접근하므로, DB의 정보가 자주 변경되지 않고, 대부분의 케이스는 Cache Hit를 하기 때문에, Look-aside 전략을 사용했어요. Look-aside 전략은 캐시에 원하는 데이터가 있는지 먼저 확인하고, 데이터가 없다면 DB에 접근한 후에 캐시에 저장하고 응답하는 방식이예요. 만약 DB 정보가 자주 변경된다면 다른 방식을 고민해야해요.</span></span></span></p><p id=\"1baa360d-33e3-80c5-8bbf-d642d3bd138a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1baa360d-33e3-807b-bd7c-ecfee3c8e153\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">캐시 만료처리는 Spring의 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><style data-emotion=\"css 1mjnzsq\">.css-1mjnzsq{white-space:pre-wrap;color:var(--adaptiveGrey800);}</style><span class=\"css-1mjnzsq\">@EntityListener</span></code><span class=\"css-1kxrhf3\">와 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">@TransactionalEventListener</span></code><span class=\"css-1kxrhf3\"> 를 사용해서, DB에 Commit된 이후에 캐시가 만료되도록 했어요. DB에 Commit 전에 만료처리를 한다면, 다른 요청에서 Commit 전 데이터를 다시 캐시에 적재하는 아래와 같은 케이스가 발생할 수 있기 때문이에요.</span></span></span></p><p id=\"1baa360d-33e3-8034-8b19-f695da5c7d59\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h3 id=\"1baa360d-33e3-803b-b68d-e3a5535e649b\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">[과거 버전이 다시 적재되는 케이스]</span></span></span></h3><style data-emotion=\"css hokoge\">.css-hokoge{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;counter-reset:numberedList;}.css-hokoge ul,.css-hokoge ol{margin:16px 0 0;}.css-hokoge>li{counter-increment:numberedList;margin-bottom:16px;padding-left:24px;}.css-hokoge>li:last-of-type{margin-bottom:0;}.css-hokoge>li>span{position:relative;}.css-hokoge>li>span>:first-child::before{content:counter(numberedList) '.';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ol class=\"css-hokoge\"><style data-emotion=\"css 1hwiibq\">.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}</style><li id=\"1baa360d-33e3-801a-96b2-cffc06cfdbdf\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread: 약관 동의 여부가 변경되어, Entity Version이 1에서 2로 올라감</span></span></span></li><li id=\"1baa360d-33e3-80c8-a956-e64547a600a0\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread: Entity Version 1 캐시가 Evict 처리 됨 (아직 Commit 전)</span></span></span></li><li id=\"1baa360d-33e3-807a-a807-ce44b175c544\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">B Thread: Cache Miss로 Database에서 ⚠️ </span><span class=\"css-q3ktjb\">Entity Version 1을 다시 Cache에 적재함 </span><span class=\"css-1kxrhf3\">⚠️</span></span></span></li><li id=\"1baa360d-33e3-8079-9e81-d99a08eaa127\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread: Entity Version 2 Commit</span></span></span></li><li id=\"1baa360d-33e3-8093-84ab-eee5d5220cd1\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">C Thread: Cache Hit로 ⚠️ </span><span class=\"css-q3ktjb\">잘못된 Entity Version 1을 응답함 </span><span class=\"css-1kxrhf3\">⚠️</span></span></span></li></ol><p id=\"1baa360d-33e3-808d-8dfc-ccee75080337\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1baa360d-33e3-8040-a3ca-e2571c551812\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이렇게 보면, 완벽한 것 같지만, </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">@TransactionalEventListener</span></code><span class=\"css-1kxrhf3\"> 가 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">AFTER_COMMIT</span></code><span class=\"css-1kxrhf3\"> 으로 설정되어 있어, Cache Evict 처리가 실패해도, 이미 Commit 된 상태이기 때문에 Transaction이 Rollback 되지 않는 문제가 있어요. 그러면, 과거 캐시 버전이 지속적으로 응답되는 문제가 있죠. </span></span></span></p><p id=\"1baa360d-33e3-80d4-b5f0-fda254141dff\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1baa360d-33e3-80a1-a4e6-f25395610d9b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그러한 문제를 해결하기 위해서, Circuit Breaker를 활용했어요. 만약, Cache Evict을 실패하면, Circuit을 Force Open 해서 자동으로 닫히지 않도록 하고, Cache Get할 때 Circuit이 Open 되어있다면, 모든 트래픽은 바로 Database를 조회하도록 하여, 잘못된 캐시가 응답되지 않도록 방어해두었어요. 이러한 방법</span><span class=\"css-1kxrhf3\">은 </span><span class=\"css-1kxrhf3\">Database에 큰 부하가 부담될 수 있지만, 잘못된 약관 동의 상태가 응답되어 문제가 발생되는 것보다, Database에 부하를 주고 빠르게 캐시에 대한 문제를 파악 및 해결하는 것이 맞다고 생각해서에요. 아직 이러한 경우를 만난 적이 없지만, 문제 발생 시 빠르게 확인, 해결할 수 있도록 상시 모니터링 중입니다!</span></span></span></p><aside class=\"css-nv7vyi\"><h4 class=\"css-123co55\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Circuit Breaker?</span><span class=\"css-1kxrhf3\">\n\n주로 MSA 구조로된 서비스에서 서비스 간의 장애 전파를 미리 차단하고자 사용하는 기술\nCircuit Breaker에 대해 </span><style data-emotion=\"css iynyr0\">.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}</style><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://techblog.woowahan.com/15694/\">자세히 설명되어 있는 글</a><span class=\"css-1kxrhf3\">을 소개드려요.</span></span></span></h4></aside><h2 id=\"1baa360d-33e3-8053-b979-fdf440141403\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">이렇게 열심히 생각했지만 현실은…?</span></span></span></h2><p id=\"1baa360d-33e3-8099-a89d-f084531cca3f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그럼 Strong Consistency를 잘 지키고 있는지 확인을 해야 하는데요. 그러기 위해서 서버에는 캐시를 적용했지만, 응답은 항상 DB에 저장된 데이터를 응답 하도록하고 DB와 캐시 데이터를 비교해서 확인했어요. 열심히 준비했기 때문에 한 번에 테스트를 통과할 줄 알았지만 언제나 그렇듯, 아래와 같은 문제를 만났어요.</span></span></span></p><h3 id=\"1baa360d-33e3-8071-8174-f31fdb60bfc5\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">0.003초 차이로 발생하는 불일치 케이스</span></span></span></h3><p id=\"1baa360d-33e3-805d-9f25-d7264f0fb0ff\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">[문제 과정]</span></span></span></p><style data-emotion=\"css uswsmm\">.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ul class=\"css-uswsmm\"><li id=\"1baa360d-33e3-809f-a662-c6d4759b2ad9\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - 약관 동의 발생</span></span></span></li><li id=\"1baa360d-33e3-8063-98fe-cc9c7791663e\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">TermsAgreement</span></code><span class=\"css-1kxrhf3\"> 값이 변경되어서, ApplicationEvent 발행</span></span></span></li><li id=\"1baa360d-33e3-8027-860b-d48610829c20\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - 약관 동의 여부 변경 Kafka Event Produce</span></span></span></li><li id=\"1baa360d-33e3-80b0-a9e9-e33abd857464\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">TermsAgreement</span></code><span class=\"css-1kxrhf3\">가 DB에 Commit 됨</span></span></span></li><li id=\"1baa360d-33e3-805b-9312-ed75b11f1e9f\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">B Thread - 약관 동의 여부 변경 Kafka Event Consume</span></span></span></li><li id=\"1baa360d-33e3-8095-b218-c9565f596407\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">B Thread - 약관 동의 여부 조회시 캐시로부터 ⚠️ </span><span class=\"css-q3ktjb\">이전 Entity Version 조회 됨</span><span class=\"css-1kxrhf3\"> ⚠️ </span></span></span></li><li id=\"1baa360d-33e3-8030-9544-c8ce447844cc\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">AFTER_COMMIT</span></code><span class=\"css-1kxrhf3\"> 설정이 되어있어, 이때 Cache Evict 됨</span></span></span></li></ul><p id=\"1baa360d-33e3-8031-bbc6-f0e959566cba\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1baa360d-33e3-80d5-bcc6-fa19bdb3b2f6\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread에서 Commit 이후, Cache를 Evict하는 그 0.003초 사이에 Kafka Event를 Consume한 곳에서 잘못된 캐시를 조회한 문제를 발견했어요. 이 케이스는 생각보다 간단히 해결할 수 있었어요. Kafka Event를 Cache Evict 처리 이후에 발행하도록 하면 되죠.</span></span></span></p><p id=\"1baa360d-33e3-8070-b557-fe2c63827614\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1baa360d-33e3-8073-b479-e83cc80d5392\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Cache Evict과 비슷한 방식으로, Database Commit 이후에 처리되도록 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">TransactionSynchronizationManager</span></code><span class=\"css-1kxrhf3\">를 활용했어요. 이때, Cache Evict과 Kafka Event Produce가 Commit 이후에 발생하도록 되어있으므로, 반드시 Cache Evict 이후에 Kafka Event Produce가 되도록 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">@Order</span></code><span class=\"css-1kxrhf3\">와 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">TransactionSynchronization</span></code><span class=\"css-1kxrhf3\"> Interface의 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">getOrder</span></code><span class=\"css-1kxrhf3\">메서드를 Override 하여 순서를 지정하여 처리 순서를 보장되도록 했어요. 자, 이제 그러면 아래와 같이 처리되므로 문제가 해결될거예요.</span></span></span></p><p id=\"1baa360d-33e3-80b7-999f-cdc54d732851\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1baa360d-33e3-8056-a14e-cbdf8aa95e4b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">[문제 해결 후 과정]</span></span></span></p><ul class=\"css-uswsmm\"><li id=\"1baa360d-33e3-8020-b3d2-eaf5b00d4248\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - 약관 동의 발생</span></span></span></li><li id=\"1baa360d-33e3-80b2-9ca0-fefd7725a12d\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">TermsAgreement</span></code><span class=\"css-1kxrhf3\"> 값이 변경되어서, ApplicationEvent 발행</span></span></span></li><li id=\"1baa360d-33e3-80e4-a5c3-e8dcc637fd98\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">TermsAgreement</span></code><span class=\"css-1kxrhf3\">가 DB에 Commit 됨</span></span></span></li><li id=\"1baa360d-33e3-809f-870c-ebd42f7d7ac7\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">AFTER_COMMIT</span></code><span class=\"css-1kxrhf3\"> 설정이 되어있어, 이때 Cache Evict 됨</span></span></span></li><li id=\"1baa360d-33e3-80e4-931b-d6ad5d3f3d9d\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">A Thread - 약관 동의 여부 변경 Kafka Event Produce</span></span></span></li><li id=\"1baa360d-33e3-8022-af99-d89faacd81b9\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">B Thread - 약관 동의 여부 변경 Kafka Event Consume</span></span></span></li><li id=\"1baa360d-33e3-8063-a2db-d5528032b744\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">B Thread - 약관 동의 여부 조회시 캐시로부터 변경 후 Entity Version이 조회 됨</span></span></span></li></ul><h3 id=\"1baa360d-33e3-8002-8440-d1b77ec8cf50\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그래도 Commit 이후 Cache Evict 처리 되기전에 조회하면…?</span></span></span></h3><p id=\"1baa360d-33e3-80aa-bc09-cb5696fd2cca\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Kafka Event가 아니더라도, 발생할 확률은 엄청나게 낮지만, 여전히 Cache Evict 되기 전에 사용자의 요청이 들어온다면, 발생할 수 있어요. 이 경우는 코드로 어떻게든 해결할 수 있지만, 정책으로 해결했어요. “정책??” 이라는 생각이 잠깐 드실 거예요. 다시 처음으로 가보면, 우리는 아래와 같은 목표를 가졌어요.</span></span></span></p><style data-emotion=\"css 2sk6rv\">.css-2sk6rv{font-size:19px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);white-space:pre-wrap;margin:24px 0;padding-left:20px;position:relative;}.css-2sk6rv::before{content:'';display:block;position:absolute;top:4px;left:0;width:2px;height:calc(100% - 4px * 2);padding:4px 0;background-color:var(--adaptiveGrey800);}</style><blockquote id=\"1baa360d-33e3-80f1-bd5a-ee9419704861\" class=\"css-2sk6rv\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">약관 동의 여부는 값이 DB에 Commit 되는 순간, 바로 다음 요청에 DB에 저장된 값이 응답되어야 한다.</span></span></span><style data-emotion=\"css 7mseny\">.css-7mseny>*{margin-left:0;margin-right:0;}.css-7mseny>:last-child{margin-bottom:0;}blockquote>.css-7mseny:first-child>:first-child{margin-top:0;}</style></blockquote><p id=\"1baa360d-33e3-80e7-bc33-d7822778d148\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">중요한 포인트는 “바로 다음 요청에 DB에 저장된 값이 응답되어야 한다” 입니다. </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">@TransactionalEventListener</span></code><span class=\"css-1kxrhf3\"> 로 전달된 이벤트가 모두 처리되기 전에는 아직 API 응답을 하기 전 상태예요. 즉, 약관 동의 또는 철회 요청이 아직 완벽히 처리가 되기 전인 상태입니다. 그래서, Cache Evict 처리 되기 전은 아직 API가 처리 중인 상태인거죠! 그래서, 약관 서버는 아래와 같은 정책을 최종적으로 가지게 됩니다.</span></span></span></p><blockquote id=\"1baa360d-33e3-802b-bfa3-e0e82949c7a4\" class=\"css-2sk6rv\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">약관 동의 여부는 약관 동의 또는 철회 요청 API 처리가 완료된 순간, 바로 다음 요청에 DB에 저장된 값이 응답되어야 한다.</span></span></span></blockquote><p id=\"1baa360d-33e3-808e-82ff-c7f51fdf8000\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이러면, 제가 생각했던 문제가 더 이상 문제가 아니게 되었고, 코드를 작성하는 저와 제품을 담당하는 PO 모두 행복하게 약관을 서비스할 수 있게 되었어요!</span></span></span></p><h2 id=\"1baa360d-33e3-80be-9142-f6d805fb47bd\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">캐시를 적용하면서 느낀점</span></span></span></h2><h3 id=\"1baa360d-33e3-80f6-b7f5-d543b19414f8\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Execution Over Perfection (완벽해지려 하기보다 실행에 집중하라)</span></span></span></h3><p id=\"1baa360d-33e3-80d3-8777-eb990bb0699a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스 커뮤니티의 여러 Core Value 중 하나인데요. 사실 매우 중요한 시스템 중 하나이기 때문에, 캐시를 적용하기 전에 완벽해지기 위해 Legal, Compliance 등 다양한 부분들을 먼저 검토하고 어떤 문제가 발생할지에 대해 다양한 방면을 고민하느라 캐시를 적용하는데 많은 시간이 들었던 것 같아요. 만약 Legal, Compliance 검토 이후 정책을 바로 세우고 캐시를 적용하여 모니터링해가며 만났던 문제들을 하나씩 해결해 나간다면 좀 더 빠르게 적용할 수 있었지 않을까 생각이 들었어요.</span></span></span></p><h3 id=\"1baa360d-33e3-809b-883c-c5b6de077a30\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">코드로 해결할 수 있지만, 정책을 조금만 틀면 더 쉽게 해결할 수 있다</span></span></span></h3><p id=\"1baa360d-33e3-807b-8237-f14605a7d4ad\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">프로그래머는 모든 것을 코드로 해결하려고 하면 안된다고 개인적으로 생각해요. 다양한 문제들이 존재할 때, 코드보다 더 쉬운 방법이 어딘가에는 존재할거에요. 이번에 말씀드린 문제를 해결한 과정은 정말 짧아 보이지만, 그 전에 수 많은 코드를 작성하고, 지웠고, 방법들을 고민했었어요. 결국 정책을 수정하여 코드보다 간단히 해결할 수 있었어요.</span></span></span></p><h3 id=\"1baa360d-33e3-8082-b55a-ef7307693135\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">마무리</span></span></span></h3><p id=\"1baa360d-33e3-8069-80a0-fd79fa069263\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">지금은 DB에 큰 부하 없이, 최대 2만 TPS 트래픽을 든든하게 버텨주는 서비스가 되었어요. 최대 2만 TPS의 트래픽은 사실, 한 번 사용자의 요청에 MSA 서비스들이 여러번 호출해서 수치가 높게 보이는 부분도 있는데요? 이런 불필요한 트래픽을 줄이기 위해, Netflix의 Passport와 비슷한 개념인, TermsPassport 와 같은 기술도 고민하고 있어요. 아직은 트래픽이 그렇게 높지 않아 적용을 하지 않지만, 만약 적용한다면 추후에 다시 글로 찾아뵐께요! </span></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-1kxrhf3{white-space:pre-wrap;}안녕하세요, 토스뱅크 Server Developer 김경윤 입니다.\n토스 커뮤니티, 그리고 토스뱅크에서는 하루에 수 백번의 라이브 배포가 일어나고 있으며 다양한 개선점과 신규 제품들이 빠르게 출시되고 있어요. 이렇게 많은 배포를 기반으로 토스뱅크가 성장하면서 토스뱅크를 이용하는 사용자도 많아졌는데요. 이로 인해서 TPS가 평균 1만, 최대 2만까지 늘어난 약관(terms) 서버에 안정적인 서비스 제공을 위해 캐시를 적용한 이야기를 들려드리려고 해요.\n.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}\n.css-p4abj2{display:contents;line-height:1.55;}Database: 더 이상 버틸 수 없다!\n약관 서버는 사용자가 동의 또는 철회한 약관 및 동의서 동의 여부를 기록하고 조회할 수 있는 서비스예요. 사용자가 동의 그리고 철회하는 경우는 그렇게 많지 않지만, 동의 여부에 따라서 개인 정보를 제3자에게 제공해도 되는지, 토스뱅크가 사용해도 되는지 등 다양한 비지니스에서 약관 및 동의서 동의 여부를 확인해요. \n(앞으로는 ‘약관 및 동의서’를 간단히 ‘약관’이라고 부를게요.)\n\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}\n어느 날, 토스뱅크에서 새로운 서비스를 배포하면서 TPS가 급증했고, 이로 인해 DB 조회량이 급증하여 DB 부하가 심각해졌었어요. 이 트래픽이 유지될 경우 다른 서비스에도 문제가 생길 수 있다고 판단했고, 급히 롤백을 진행하며 DB 부하를 줄일 방안을 고민하게 되었어요. 그 결과, 많은 분들이 알고 계신 ‘캐시’를 적용하기로 했지만, 막상 시도해 보니 생각보다 간단치 않았어요.\n\n캐시 적용은 보다 신중하게\n이 글을 읽으면서, “어? 그럼 Replication된 Database를 두고 부하를 분산하면 되는거 아니야?” 라고 생각할 수 있어요. 약관은 토스뱅크 고객의 개인정보와 밀접한 연관성이 있어요. 약관 동의 여부는 사용자의 정보를 특정 목적으로 이용해도 되는지, 제3자에게 공유가 되도 되는지 결정하는 기준이기 때문이에요. \n그래서 약관 동의 여부는 값이 DB에 Commit 되는 순간, 바로 다음 요청에 DB에 저장된 값이 정확하게 응답되어야해요. 이를 .css-q3ktjb{white-space:pre-wrap;font-weight:bold;}Strong Consistency라고 부르며, 데이터의 무결성을 보장하기 위해 필수적이에요. 만약, 잘못된 응답을 한 번이라도 발생하면, 고객이 약관을 철회한 이후에도 개인정보가 공유되는 등의 보안 문제가 발생할 수 있어요. 따라서 데이터 신뢰성과 정확성을 보장하기 위해 Replication Database는 사용하지 않기로 했어요. Replication 구조에서는 복제 지연(Replication Delay)이 발생할 가능성이 있기 때문이에요. 대신, Strong Consistency를 유지하면서도 빠르게 조회가 가능한 Redis Cache를 활용해 고객의 약관 동의 상태를 안전하게 관리하기로 결정했어요.\n.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}.css-123co55{font-size:19px;letter-spacing:0em;line-height:1.6;margin:24px 0 0;font-weight:400;color:var(--adaptiveGrey900);background-color:transparent;}\n복제 지연(Replication Delay)?\n\n주 DB(Primary)와 보조 DB(Replica) 간의 데이터 동기화가 지연되는 현상\n\n\n.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}\n이러한 방식으로 캐시를 적용했어요!\n\n약관 서버는 대부분 조회성으로 캐시를 접근하므로, DB의 정보가 자주 변경되지 않고, 대부분의 케이스는 Cache Hit를 하기 때문에, Look-aside 전략을 사용했어요. Look-aside 전략은 캐시에 원하는 데이터가 있는지 먼저 확인하고, 데이터가 없다면 DB에 접근한 후에 캐시에 저장하고 응답하는 방식이예요. 만약 DB 정보가 자주 변경된다면 다른 방식을 고민해야해요.\n\n캐시 만료처리는 Spring의 .css-1mjnzsq{white-space:pre-wrap;color:var(--adaptiveGrey800);}@EntityListener와 @TransactionalEventListener 를 사용해서, DB에 Commit된 이후에 캐시가 만료되도록 했어요. DB에 Commit 전에 만료처리를 한다면, 다른 요청에서 Commit 전 데이터를 다시 캐시에 적재하는 아래와 같은 케이스가 발생할 수 있기 때문이에요.\n\n[과거 버전이 다시 적재되는 케이스]\n.css-hokoge{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;counter-reset:numberedList;}.css-hokoge ul,.css-hokoge ol{margin:16px 0 0;}.css-hokoge>li{counter-increment:numberedList;margin-bottom:16px;padding-left:24px;}.css-hokoge>li:last-of-type{margin-bottom:0;}.css-hokoge>li>span{position:relative;}.css-hokoge>li>span>:first-child::before{content:counter(numberedList) '.';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\nA Thread: 약관 동의 여부가 변경되어, Entity Version이 1에서 2로 올라감\nA Thread: Entity Version 1 캐시가 Evict 처리 됨 (아직 Commit 전)\nB Thread: Cache Miss로 Database에서 ⚠️ Entity Version 1을 다시 Cache에 적재함 ⚠️\nA Thread: Entity Version 2 Commit\nC Thread: Cache Hit로 ⚠️ 잘못된 Entity Version 1을 응답함 ⚠️\n\n\n이렇게 보면, 완벽한 것 같지만, @TransactionalEventListener 가 AFTER_COMMIT 으로 설정되어 있어, Cache Evict 처리가 실패해도, 이미 Commit 된 상태이기 때문에 Transaction이 Rollback 되지 않는 문제가 있어요. 그러면, 과거 캐시 버전이 지속적으로 응답되는 문제가 있죠. \n\n그러한 문제를 해결하기 위해서, Circuit Breaker를 활용했어요. 만약, Cache Evict을 실패하면, Circuit을 Force Open 해서 자동으로 닫히지 않도록 하고, Cache Get할 때 Circuit이 Open 되어있다면, 모든 트래픽은 바로 Database를 조회하도록 하여, 잘못된 캐시가 응답되지 않도록 방어해두었어요. 이러한 방법은 Database에 큰 부하가 부담될 수 있지만, 잘못된 약관 동의 상태가 응답되어 문제가 발생되는 것보다, Database에 부하를 주고 빠르게 캐시에 대한 문제를 파악 및 해결하는 것이 맞다고 생각해서에요. 아직 이러한 경우를 만난 적이 없지만, 문제 발생 시 빠르게 확인, 해결할 수 있도록 상시 모니터링 중입니다!\n\nCircuit Breaker?\n\n주로 MSA 구조로된 서비스에서 서비스 간의 장애 전파를 미리 차단하고자 사용하는 기술\nCircuit Breaker에 대해 .css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}자세히 설명되어 있는 글을 소개드려요.\n\n이렇게 열심히 생각했지만 현실은…?\n그럼 Strong Consistency를 잘 지키고 있는지 확인을 해야 하는데요. 그러기 위해서 서버에는 캐시를 적용했지만, 응답은 항상 DB에 저장된 데이터를 응답 하도록하고 DB와 캐시 데이터를 비교해서 확인했어요. 열심히 준비했기 때문에 한 번에 테스트를 통과할 줄 알았지만 언제나 그렇듯, 아래와 같은 문제를 만났어요.\n0.003초 차이로 발생하는 불일치 케이스\n[문제 과정]\n.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\nA Thread - 약관 동의 발생\nA Thread - TermsAgreement 값이 변경되어서, ApplicationEvent 발행\nA Thread - 약관 동의 여부 변경 Kafka Event Produce\nA Thread - TermsAgreement가 DB에 Commit 됨\nB Thread - 약관 동의 여부 변경 Kafka Event Consume\nB Thread - 약관 동의 여부 조회시 캐시로부터 ⚠️ 이전 Entity Version 조회 됨 ⚠️ \nA Thread - AFTER_COMMIT 설정이 되어있어, 이때 Cache Evict 됨\n\n\nA Thread에서 Commit 이후, Cache를 Evict하는 그 0.003초 사이에 Kafka Event를 Consume한 곳에서 잘못된 캐시를 조회한 문제를 발견했어요. 이 케이스는 생각보다 간단히 해결할 수 있었어요. Kafka Event를 Cache Evict 처리 이후에 발행하도록 하면 되죠.\n\nCache Evict과 비슷한 방식으로, Database Commit 이후에 처리되도록 TransactionSynchronizationManager를 활용했어요. 이때, Cache Evict과 Kafka Event Produce가 Commit 이후에 발생하도록 되어있으므로, 반드시 Cache Evict 이후에 Kafka Event Produce가 되도록 @Order와 TransactionSynchronization Interface의 getOrder메서드를 Override 하여 순서를 지정하여 처리 순서를 보장되도록 했어요. 자, 이제 그러면 아래와 같이 처리되므로 문제가 해결될거예요.\n\n[문제 해결 후 과정]\n\nA Thread - 약관 동의 발생\nA Thread - TermsAgreement 값이 변경되어서, ApplicationEvent 발행\nA Thread - TermsAgreement가 DB에 Commit 됨\nA Thread - AFTER_COMMIT 설정이 되어있어, 이때 Cache Evict 됨\nA Thread - 약관 동의 여부 변경 Kafka Event Produce\nB Thread - 약관 동의 여부 변경 Kafka Event Consume\nB Thread - 약관 동의 여부 조회시 캐시로부터 변경 후 Entity Version이 조회 됨\n\n그래도 Commit 이후 Cache Evict 처리 되기전에 조회하면…?\nKafka Event가 아니더라도, 발생할 확률은 엄청나게 낮지만, 여전히 Cache Evict 되기 전에 사용자의 요청이 들어온다면, 발생할 수 있어요. 이 경우는 코드로 어떻게든 해결할 수 있지만, 정책으로 해결했어요. “정책??” 이라는 생각이 잠깐 드실 거예요. 다시 처음으로 가보면, 우리는 아래와 같은 목표를 가졌어요.\n.css-2sk6rv{font-size:19px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);white-space:pre-wrap;margin:24px 0;padding-left:20px;position:relative;}.css-2sk6rv::before{content:'';display:block;position:absolute;top:4px;left:0;width:2px;height:calc(100% - 4px * 2);padding:4px 0;background-color:var(--adaptiveGrey800);}\n약관 동의 여부는 값이 DB에 Commit 되는 순간, 바로 다음 요청에 DB에 저장된 값이 응답되어야 한다..css-7mseny>*{margin-left:0;margin-right:0;}.css-7mseny>:last-child{margin-bottom:0;}blockquote>.css-7mseny:first-child>:first-child{margin-top:0;}\n중요한 포인트는 “바로 다음 요청에 DB에 저장된 값이 응답되어야 한다” 입니다. @TransactionalEventListener 로 전달된 이벤트가 모두 처리되기 전에는 아직 API 응답을 하기 전 상태예요. 즉, 약관 동의 또는 철회 요청이 아직 완벽히 처리가 되기 전인 상태입니다. 그래서, Cache Evict 처리 되기 전은 아직 API가 처리 중인 상태인거죠! 그래서, 약관 서버는 아래와 같은 정책을 최종적으로 가지게 됩니다.\n약관 동의 여부는 약관 동의 또는 철회 요청 API 처리가 완료된 순간, 바로 다음 요청에 DB에 저장된 값이 응답되어야 한다.\n이러면, 제가 생각했던 문제가 더 이상 문제가 아니게 되었고, 코드를 작성하는 저와 제품을 담당하는 PO 모두 행복하게 약관을 서비스할 수 있게 되었어요!\n캐시를 적용하면서 느낀점\nExecution Over Perfection (완벽해지려 하기보다 실행에 집중하라)\n토스 커뮤니티의 여러 Core Value 중 하나인데요. 사실 매우 중요한 시스템 중 하나이기 때문에, 캐시를 적용하기 전에 완벽해지기 위해 Legal, Compliance 등 다양한 부분들을 먼저 검토하고 어떤 문제가 발생할지에 대해 다양한 방면을 고민하느라 캐시를 적용하는데 많은 시간이 들었던 것 같아요. 만약 Legal, Compliance 검토 이후 정책을 바로 세우고 캐시를 적용하여 모니터링해가며 만났던 문제들을 하나씩 해결해 나간다면 좀 더 빠르게 적용할 수 있었지 않을까 생각이 들었어요.\n코드로 해결할 수 있지만, 정책을 조금만 틀면 더 쉽게 해결할 수 있다\n프로그래머는 모든 것을 코드로 해결하려고 하면 안된다고 개인적으로 생각해요. 다양한 문제들이 존재할 때, 코드보다 더 쉬운 방법이 어딘가에는 존재할거에요. 이번에 말씀드린 문제를 해결한 과정은 정말 짧아 보이지만, 그 전에 수 많은 코드를 작성하고, 지웠고, 방법들을 고민했었어요. 결국 정책을 수정하여 코드보다 간단히 해결할 수 있었어요.\n마무리\n지금은 DB에 큰 부하 없이, 최대 2만 TPS 트래픽을 든든하게 버텨주는 서비스가 되었어요. 최대 2만 TPS의 트래픽은 사실, 한 번 사용자의 요청에 MSA 서비스들이 여러번 호출해서 수치가 높게 보이는 부분도 있는데요? 이런 불필요한 트래픽을 줄이기 위해, Netflix의 Passport와 비슷한 개념인, TermsPassport 와 같은 기술도 고민하고 있어요. 아직은 트래픽이 그렇게 높지 않아 적용을 하지 않지만, 만약 적용한다면 추후에 다시 글로 찾아뵐께요!",
        "content": "TPS가 평균 1만, 최대 2만까지 늘어난 약관(terms) 서버에 안정적인 서비스 제공을 위해 캐시를 적용한 이야기를 들려드리려고 해요.",
        "contentSnippet": "TPS가 평균 1만, 최대 2만까지 늘어난 약관(terms) 서버에 안정적인 서비스 제공을 위해 캐시를 적용한 이야기를 들려드리려고 해요.",
        "guid": "https://toss.tech/article/34481",
        "isoDate": "2025-03-31T02:32:00.000Z"
      },
      {
        "title": "토스 피플: 이것도 ‘나니까’ 할 수 있다고 생각하기",
        "link": "https://toss.tech/article/Tosspeople_LeeJiyoon",
        "pubDate": "Thu, 27 Mar 2025 14:28:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1c2a360d-33e3-80b2-b692-d790efccfe64\" class=\"css-14on8x8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-80b0-9572-c552e018eff4\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">이번 토스 피플에서는 Product Designer 이지윤 님의 인터뷰를 공유드려요. 지윤님은 여러 도메인의 회사들을 거쳐 토스에 입사하셨고, 토스 안에서도 총 10 개 내외의 팀을 거치며 다양한 경험을 쌓으셨어요. 토스에서 했던 주요 프로젝트는 함께 토스 켜기, 전체 탭 및 홈 탭 개선 등이 있고, 지금은 새로운 서비스에 유저를 끌어오는 그로스 일을 하고 계세요.</span></span></span></p><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1c2a360d-33e3-80ea-9176-fb76f0fc83dd\" class=\"css-of5acw\"><style data-emotion=\"css 1pgssrp\">.css-1pgssrp{max-width:100%;border-radius:16px;}</style><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/72765c0e-db77-4e8b-8994-cac822d19551/image.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1c2a360d-33e3-801b-89f3-f3772f562db2\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-8094-ab32-ea8e54189ef7\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">Q. 지윤님은 토스에 오시기 전에 4개의 회사에 다니셨다고 들었어요. 가장 기억에 남는 곳은 어디인가요?</span></span></span></p><p id=\"1c2a360d-33e3-80b4-a00f-cdbadf5de947\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">아무래도 A회사였죠. 당시 학교에 다니고 있었을 땐데, 펠로우십 공고를 보고 반드시 지원해야겠다고 생각했어요. 제 전공이 산업 디자인이었는데, 제품 디자인은 진짜 장인 정신과 디테일이 중요한 분야더라고요. 저는 디테일에 강한 타입이 아니라는 걸 스스로 알고 있었고, UX/UI는 학점이 괜찮았어서 이 쪽으로 가야겠다고 생각하고 있었어요. 너무 하고 싶어서, 다른 분들이 이 공고를 못 봤으면 좋겠다고 바랄 정도였죠. </span></span></span></p><p id=\"1c2a360d-33e3-806d-b618-f5b73272e664\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">감사하게도 참여할 기회를 얻게 됐는데, 졸업 전시를 준비하면서 매주 펠로우십 과제를 하는 일정이었거든요. 재미도 있었지만 너무 힘들었어요. 인턴과 정규직 전환 등의 기회가 있었는데, 모두에게 기회가 주어지지 않았기 때문에 분위기가 조금 경쟁적이기도 했고요. 마지막엔 완전히 지쳐서, 결국 정규직에 전환되지 못했었어요. </span></span></span></p><p id=\"1c2a360d-33e3-800b-828e-d25dd1bacfb5\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-8027-8dfa-f79d5de1c156\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><figure id=\"1c2a360d-33e3-808b-913d-e383639b87ed\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/f2fa916d-b08c-40cf-b51c-2a40cd6e8fef/image2.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1c2a360d-33e3-8019-8649-c9c2295cca47\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-80ad-87ea-cd4ceebe6b5a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Q. 졸업 전시에 과제, 경쟁까지… 듣기만 해도 진이 빠지네요. 토스에는 어떻게 오게 되셨나요?</span></span></span></p><p id=\"1c2a360d-33e3-80b3-9eb6-f43b2c67f912\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">인턴 기간이 끝나고, 대기업 준비하는 것보다 작은 회사에 들어가서라도 빨리 경험을 쌓아야 겠다는 생각을 했었어요. 실제로 큰 기업들에 합격하기도 했는데, 뭔가 제가 거기에 다닌다는 게 잘 상상이 안되더라고요. 그래서 서류 합격했는데 더 진행하지 않았었어요. 이후에 두 곳 정도의 스타트업에 다니다가 퇴사하게 됐는데, 우연히 토스에 다니고 있던 디자이너 분께 연락을 받아서 지원하게 됐었죠. </span></span></span></p><p id=\"1c2a360d-33e3-80f7-8b4d-fe11df90a8fd\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">솔직히 처음에는 ‘내가 감히?’라는 생각도 했었어요. 왜냐면 제 경력이 2년도 채 되지 않을 때였고, 토스가 워낙 유명했었으니까요. 실제로 와보니 굉장히 힘들었던 것도 맞는데, 도파민이 장난 아니긴 했었죠. 바로 옆에 승건 님이 일하고 계시고, 저도 제 제품에 욕심이 많았거든요. </span></span></span></p><p id=\"1c2a360d-33e3-803e-8a11-e93c066e9c6f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><figure id=\"1c2a360d-33e3-805a-b165-cdd3257ae2dd\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/445f9044-4131-40e1-bc46-0c5d11565850/image4.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1c2a360d-33e3-80d8-bbe2-cf675e007947\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-80cc-99d3-e6c6be201c8c\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Q. 2년 차 되었을 때는 점수가 엄청 떨어졌네요.</span></span></span></p><p id=\"1c2a360d-33e3-805c-81e7-f1e61b90158e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">네… 저희끼리는 2년 병이라는 말도 하는데요. 허니문</span><span class=\"css-1kxrhf3\"> 기간 동안 </span><span class=\"css-1kxrhf3\">폭발적인 성장을 하고, 끝나고 나서 점점 떨어졌어요. 당시 토스는 인원이 적기도 하고 직급이 뚜렷하게 나뉘어져있던 때가 아니어서, 영향력이 엄청 중요했거든요. 그런데 저는 주니어라 경험도 부족했고, 그러다보니 어쩔 수 없이 제가 다룰 수 없는 영역들이 있다고 생각했던 것 같아요. </span></span></span></p><p id=\"1c2a360d-33e3-8055-8774-f33c45f6faa1\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그러다가 유저 그로스할 때 엄청 올라갔던 것 같아요. 그때 PO가 승건 님이었거든요. 바로 옆에서 승건 님이 일하시는 걸 보면서 엄청 압축적으로 배울 수 있었죠. 가장 충격적이었던 건 승건님은 전체 회사의 대표임에도 완전히 디테일하고 집요하게 사용자에게 집착한다는 점이었어요. 멀리서 보았을 땐 아무래도 대표라는 자리이니 큰 그림 위주로 보는 분인 줄 알았는데 생각보다 사용자의 가치, 사용자가 느끼는 점 등을 굉장히 디테일하게 신경쓰고 해결하려 하시더라고요.</span></span></span></p><p id=\"1c2a360d-33e3-80d5-9f15-fe3ca912e6c4\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-80d8-be8c-dc4bd200ecc7\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-8064-b230-c7adbe51148f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><figure id=\"1c2a360d-33e3-8081-8ccc-df32c1776e44\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/1a7571b9-1df6-411b-996a-2fed8ef5ce86/image5.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1c2a360d-33e3-8054-b107-f847e4aa9241\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Q. 사실 대표랑 한 팀으로 일한다는 게 좀 겁났을 수도 있을 것 같은데… </span></span></span></p><p id=\"1c2a360d-33e3-802d-88c0-f12473cc701e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">아, 겁에 대해서는 저 나름의 전략이 있는데. 모든 일은 겁이 나잖아요, 작은 일이든 큰 일이든. 근데 겁이 나면 일단은 그 감정에서 벗어나려고 해요. 그러니까, 다른 데로 정신을 돌리는 거죠. 그리고 저는 약간 충동적인 성향도 있거든요. 그래서 어느 날 갑자기 ‘하고 싶다’라는 생각이 들 때가 있어요. 그때 확 질러버리는 거죠. ‘저 할게요’하고요. 다시 못 돌아가게. 그렇게 하고 나면 제가 저지른 게 있으니까 어떻게든 하게 되더라고요. 일단 벌려놓고 나면 마무리해야 하는 스타일이라서요. 이상하게 하든 말든 어떻게든 하긴 하는 거죠. </span></span></span></p><p id=\"1c2a360d-33e3-8070-8a9a-e0ceb8a25fc5\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">사실 이건 제가 첫 회사에서 정규직 전환이 안되고 생긴 습관 같기도 해요. 그때의 저는 통제를 좋아하고 완벽을 추구하는 사람이었거든요. 고민도 진짜 많이 하는데, 사실 저한테 주어진 시간은 한정적인데 그 고민의 굴레에서 벗어나기가 너무 힘들더라고요. 그래서 이후에는 ‘일단 지르고 보자! 미래의 내가 어떻게든 해내겠지.’ 이렇게 되더라고요. </span></span></span></p><p id=\"1c2a360d-33e3-8082-a5ef-c11f0d33ec7c\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-8088-8021-fc1fa95810b6\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><figure id=\"1c2a360d-33e3-800f-84a4-cd0a05b997eb\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/5ce5827f-d4ee-46ed-9ef6-10ddb35c0897/image6.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1c2a360d-33e3-8018-99d4-fce7b7f5f380\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-8016-ad60-d9e510eeca4f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Q. 너무 부지런하다… 그때가 몇 년 차 정도 되셨나요?</span></span></span></p><p id=\"1c2a360d-33e3-80a8-9407-f56a10a639b1\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">아마 3년 조금 넘었을 때였을 거예요. 토스 내에서는 디자이너로서도 꽤 오래 일한 셈이 된 거죠. 그러다가 승건 님이 토스 신용 페이의 PM 역할을 제게 부탁하셨어요. 토스에서는 디자이너들이 보통 PM이나 PO역할도 조금씩 나눠서 하니까, 저는 그 정도로 예상하고 알겠다고 했죠. 그런데 실제로 해보니까 정말 디자인을 거의 할 일이 없는 거예요. 매일 제휴사들이랑 통화하고, 만나서 협상하고 그런 일들을 했어요. 그런데 그때 지금까지 해본 적 없는 완전히 새로운 일을 하니까 나쁘지 않더라고요. 꽤 재미있었어요. </span></span></span></p><p id=\"1c2a360d-33e3-809f-ade1-cbeff7c3245e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그 일을 마친 다음에는 네비게이션 팀에서 일하게 됐어요. 첫 업무는 토스의 전체 탭을 개선하는 일이었죠. 당시 전체 탭이 정말 문제가 많았거든요. 각 제품별로는 디자이너가 있는데, 이렇게 공통으로 쓰는 영역은 회색 지대라서 아무도 맡은 사람이 없었어요. 게다가 전체 탭은 모든 제품의 진입점으로 쓰이는 공간이니까, 맡은 사람은 없지만 모두가 이해 관계자인 복잡한 제품이었죠. 그걸 끝내고 나서도 계속 플랫폼적인 일을 했었어요. 예를 들면 사용자들이 제품별로 진입점을 얼마나 잘 찾는지 점수화한 EVR이라든가… 이것도 디자인만큼이나 팀원들을 설득하는 데에 시간을 많이 써야 하는 일이었어요. 계속 하니까 좀 고되더라고요.</span></span></span></p><p id=\"1c2a360d-33e3-805e-959a-cb432de4e331\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><figure id=\"1c2a360d-33e3-8058-b2e2-d70f44c2f9d2\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/a592689b-dcb4-4371-9408-451c7f648ff7/image7.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1c2a360d-33e3-80fe-bcd8-dd8ce79a7141\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-809d-ae53-fe2e6744314b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Q. 그래서 점수가 좀 떨어졌었네요. 근데, 홈 팀 업무 하시면서 다시 올라갔어요.</span></span></span></p><p id=\"1c2a360d-33e3-8071-9d24-e38366b18b9a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">사실 홈이 저한테는 참… 아픈 손가락이에요. 그때 정말 힘들었거든요. 얼마나 힘들었냐면, 엘리베이터를 타면 사람들이 ‘이지윤 왜 저렇게 못 하냐’ 비난할 것 같다고 혼자서 상상하면서 괴로워할 정도로… 좀 우울이 심했던 것 같아요. 근데 네비게이션 일할 때보다는 좀 더 주도적으로 일할 수 있었기 때문에, (그래서 더 두렵기도 했던 것이지만) 점수는 더 높았던 것 같아요. </span></span></span></p><p id=\"1c2a360d-33e3-80ee-b607-dc26329ad936\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그리고 처음에 홈 일을 시작할 때 ‘해결해야 할 것 10가지’를 정리해놨었거든요? 제가 1번으로 적어놨던 걸 8월에 발의를 했는데, 12월에 해결한 게 몇 개 있었어요. 사실 그 사이에 아무것도 안 했는데, 12월에 돌아보니 되어있었던 거죠. 중간에 한 번 좌절됐었을 때, 그냥 ‘이거 안 되겠다’, ‘못하겠어’하고 그만뒀었는데, 그걸 다시 끌고 와서 제가 12월에 결국 해냈다는 게 되게 고무적이었어요. 저 스스로의 집요함을 알게 된 순간이었다고 해야 하나. </span></span></span></p><p id=\"1c2a360d-33e3-80e1-aace-d8e79af85d09\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><figure id=\"1c2a360d-33e3-804f-9d2c-d98f184c3043\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/c2cb5a29-abe3-4842-bbe0-c4f765221338/image8_(aaaaa).png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1c2a360d-33e3-80e9-8707-debc83a00d4f\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-80c4-b8f6-c850f712aa96\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">Q. 요즘은 좀 어떤 상태인가요? 5년 전의 지윤님에게 해주고 싶은 말이 있다면 그것도 궁금해요.</span></span></span></p><p id=\"1c2a360d-33e3-80ed-9e4f-e36db3d52dc7\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">지금요? 지금은 너무 좋아요. 사실 불안감은 지금까지 겪었던 것 중 가장 크거든요. 과거에 크다고 생각했던 문제들이 별 거 아니었던 것처럼 느껴질 정도로요. 솔직히 하루에도 몇 번씩 그 생각이 들어요. ‘이게 맞나?’ </span></span></span></p><p id=\"1c2a360d-33e3-8087-9520-d1d338be5c87\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">그럴 때 저는 약간의 나르시시즘이 좀 필요하다는 생각을 해요. ‘나니까 버티는 거지.’ 과거에 했던 성공들을 떠올리면서 스스로 다독여보는 거죠. ‘그래도 네가 한 것들이 있는데, 이것도 그렇게 하겠지.’라고 자기 주문을 외는 것 같아요. 실패한 것들 떠올려봤자 좋을 게 없잖아요. ‘나 아니면 누가 하겠어.’ 계속 그렇게 생각해보는 거죠. 과거의 저도 힘들었던 순간에 이렇게 생각했으면 좋겠다 싶어요. </span></span></span></p><p id=\"1c2a360d-33e3-80d6-a77a-d42729944ade\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><style data-emotion=\"css nv7vyi\">.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}</style><aside class=\"css-nv7vyi\"><style data-emotion=\"css 123co55\">.css-123co55{font-size:19px;letter-spacing:0em;line-height:1.6;margin:24px 0 0;font-weight:400;color:var(--adaptiveGrey900);background-color:transparent;}</style><h4 class=\"css-123co55\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">지윤님과 함께 해보고 싶다면?\n</span><span class=\"css-1kxrhf3\">지윤님과 비슷한 커리어 패스를 밟아보고 싶거나, 지윤님이 소속되신 AppsInToss Growth Team에서 일해보고 싶은 분들은 댓글을 남겨주세요! 정성스런 댓글을 남겨주신 분 중 추첨하여 지윤님과 토스 오피스에서 1:1 커피챗(30분)에 초대해드려요. </span><style data-emotion=\"css ksfp3x\">.css-ksfp3x{white-space:pre-wrap;color:#4593fc;}</style><span class=\"css-ksfp3x\">*발행일 1주일 뒤에, 그동안 달린 댓글을 기준으로 결과를 공유드려요.</span></span></span></h4></aside><p id=\"1c2a360d-33e3-80ee-8e74-d1b1a7a0bcff\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c2a360d-33e3-80a3-9b57-ecbfe662054a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Interviewee: 이지윤\nInterviewer &amp; Editor: 김자유, 유아란</span></span></span></p><p id=\"1c2a360d-33e3-809f-8114-e53cb1f786bc\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}\n.css-1kxrhf3{white-space:pre-wrap;}이번 토스 피플에서는 Product Designer 이지윤 님의 인터뷰를 공유드려요. 지윤님은 여러 도메인의 회사들을 거쳐 토스에 입사하셨고, 토스 안에서도 총 10 개 내외의 팀을 거치며 다양한 경험을 쌓으셨어요. 토스에서 했던 주요 프로젝트는 함께 토스 켜기, 전체 탭 및 홈 탭 개선 등이 있고, 지금은 새로운 서비스에 유저를 끌어오는 그로스 일을 하고 계세요.\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}\n\n.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}Q. 지윤님은 토스에 오시기 전에 4개의 회사에 다니셨다고 들었어요. 가장 기억에 남는 곳은 어디인가요?\n아무래도 A회사였죠. 당시 학교에 다니고 있었을 땐데, 펠로우십 공고를 보고 반드시 지원해야겠다고 생각했어요. 제 전공이 산업 디자인이었는데, 제품 디자인은 진짜 장인 정신과 디테일이 중요한 분야더라고요. 저는 디테일에 강한 타입이 아니라는 걸 스스로 알고 있었고, UX/UI는 학점이 괜찮았어서 이 쪽으로 가야겠다고 생각하고 있었어요. 너무 하고 싶어서, 다른 분들이 이 공고를 못 봤으면 좋겠다고 바랄 정도였죠. \n감사하게도 참여할 기회를 얻게 됐는데, 졸업 전시를 준비하면서 매주 펠로우십 과제를 하는 일정이었거든요. 재미도 있었지만 너무 힘들었어요. 인턴과 정규직 전환 등의 기회가 있었는데, 모두에게 기회가 주어지지 않았기 때문에 분위기가 조금 경쟁적이기도 했고요. 마지막엔 완전히 지쳐서, 결국 정규직에 전환되지 못했었어요. \n\n\n\n\nQ. 졸업 전시에 과제, 경쟁까지… 듣기만 해도 진이 빠지네요. 토스에는 어떻게 오게 되셨나요?\n인턴 기간이 끝나고, 대기업 준비하는 것보다 작은 회사에 들어가서라도 빨리 경험을 쌓아야 겠다는 생각을 했었어요. 실제로 큰 기업들에 합격하기도 했는데, 뭔가 제가 거기에 다닌다는 게 잘 상상이 안되더라고요. 그래서 서류 합격했는데 더 진행하지 않았었어요. 이후에 두 곳 정도의 스타트업에 다니다가 퇴사하게 됐는데, 우연히 토스에 다니고 있던 디자이너 분께 연락을 받아서 지원하게 됐었죠. \n솔직히 처음에는 ‘내가 감히?’라는 생각도 했었어요. 왜냐면 제 경력이 2년도 채 되지 않을 때였고, 토스가 워낙 유명했었으니까요. 실제로 와보니 굉장히 힘들었던 것도 맞는데, 도파민이 장난 아니긴 했었죠. 바로 옆에 승건 님이 일하고 계시고, 저도 제 제품에 욕심이 많았거든요. \n\n\n\nQ. 2년 차 되었을 때는 점수가 엄청 떨어졌네요.\n네… 저희끼리는 2년 병이라는 말도 하는데요. 허니문 기간 동안 폭발적인 성장을 하고, 끝나고 나서 점점 떨어졌어요. 당시 토스는 인원이 적기도 하고 직급이 뚜렷하게 나뉘어져있던 때가 아니어서, 영향력이 엄청 중요했거든요. 그런데 저는 주니어라 경험도 부족했고, 그러다보니 어쩔 수 없이 제가 다룰 수 없는 영역들이 있다고 생각했던 것 같아요. \n그러다가 유저 그로스할 때 엄청 올라갔던 것 같아요. 그때 PO가 승건 님이었거든요. 바로 옆에서 승건 님이 일하시는 걸 보면서 엄청 압축적으로 배울 수 있었죠. 가장 충격적이었던 건 승건님은 전체 회사의 대표임에도 완전히 디테일하고 집요하게 사용자에게 집착한다는 점이었어요. 멀리서 보았을 땐 아무래도 대표라는 자리이니 큰 그림 위주로 보는 분인 줄 알았는데 생각보다 사용자의 가치, 사용자가 느끼는 점 등을 굉장히 디테일하게 신경쓰고 해결하려 하시더라고요.\n\n\n\n\nQ. 사실 대표랑 한 팀으로 일한다는 게 좀 겁났을 수도 있을 것 같은데… \n아, 겁에 대해서는 저 나름의 전략이 있는데. 모든 일은 겁이 나잖아요, 작은 일이든 큰 일이든. 근데 겁이 나면 일단은 그 감정에서 벗어나려고 해요. 그러니까, 다른 데로 정신을 돌리는 거죠. 그리고 저는 약간 충동적인 성향도 있거든요. 그래서 어느 날 갑자기 ‘하고 싶다’라는 생각이 들 때가 있어요. 그때 확 질러버리는 거죠. ‘저 할게요’하고요. 다시 못 돌아가게. 그렇게 하고 나면 제가 저지른 게 있으니까 어떻게든 하게 되더라고요. 일단 벌려놓고 나면 마무리해야 하는 스타일이라서요. 이상하게 하든 말든 어떻게든 하긴 하는 거죠. \n사실 이건 제가 첫 회사에서 정규직 전환이 안되고 생긴 습관 같기도 해요. 그때의 저는 통제를 좋아하고 완벽을 추구하는 사람이었거든요. 고민도 진짜 많이 하는데, 사실 저한테 주어진 시간은 한정적인데 그 고민의 굴레에서 벗어나기가 너무 힘들더라고요. 그래서 이후에는 ‘일단 지르고 보자! 미래의 내가 어떻게든 해내겠지.’ 이렇게 되더라고요. \n\n\n\n\nQ. 너무 부지런하다… 그때가 몇 년 차 정도 되셨나요?\n아마 3년 조금 넘었을 때였을 거예요. 토스 내에서는 디자이너로서도 꽤 오래 일한 셈이 된 거죠. 그러다가 승건 님이 토스 신용 페이의 PM 역할을 제게 부탁하셨어요. 토스에서는 디자이너들이 보통 PM이나 PO역할도 조금씩 나눠서 하니까, 저는 그 정도로 예상하고 알겠다고 했죠. 그런데 실제로 해보니까 정말 디자인을 거의 할 일이 없는 거예요. 매일 제휴사들이랑 통화하고, 만나서 협상하고 그런 일들을 했어요. 그런데 그때 지금까지 해본 적 없는 완전히 새로운 일을 하니까 나쁘지 않더라고요. 꽤 재미있었어요. \n그 일을 마친 다음에는 네비게이션 팀에서 일하게 됐어요. 첫 업무는 토스의 전체 탭을 개선하는 일이었죠. 당시 전체 탭이 정말 문제가 많았거든요. 각 제품별로는 디자이너가 있는데, 이렇게 공통으로 쓰는 영역은 회색 지대라서 아무도 맡은 사람이 없었어요. 게다가 전체 탭은 모든 제품의 진입점으로 쓰이는 공간이니까, 맡은 사람은 없지만 모두가 이해 관계자인 복잡한 제품이었죠. 그걸 끝내고 나서도 계속 플랫폼적인 일을 했었어요. 예를 들면 사용자들이 제품별로 진입점을 얼마나 잘 찾는지 점수화한 EVR이라든가… 이것도 디자인만큼이나 팀원들을 설득하는 데에 시간을 많이 써야 하는 일이었어요. 계속 하니까 좀 고되더라고요.\n\n\n\nQ. 그래서 점수가 좀 떨어졌었네요. 근데, 홈 팀 업무 하시면서 다시 올라갔어요.\n사실 홈이 저한테는 참… 아픈 손가락이에요. 그때 정말 힘들었거든요. 얼마나 힘들었냐면, 엘리베이터를 타면 사람들이 ‘이지윤 왜 저렇게 못 하냐’ 비난할 것 같다고 혼자서 상상하면서 괴로워할 정도로… 좀 우울이 심했던 것 같아요. 근데 네비게이션 일할 때보다는 좀 더 주도적으로 일할 수 있었기 때문에, (그래서 더 두렵기도 했던 것이지만) 점수는 더 높았던 것 같아요. \n그리고 처음에 홈 일을 시작할 때 ‘해결해야 할 것 10가지’를 정리해놨었거든요? 제가 1번으로 적어놨던 걸 8월에 발의를 했는데, 12월에 해결한 게 몇 개 있었어요. 사실 그 사이에 아무것도 안 했는데, 12월에 돌아보니 되어있었던 거죠. 중간에 한 번 좌절됐었을 때, 그냥 ‘이거 안 되겠다’, ‘못하겠어’하고 그만뒀었는데, 그걸 다시 끌고 와서 제가 12월에 결국 해냈다는 게 되게 고무적이었어요. 저 스스로의 집요함을 알게 된 순간이었다고 해야 하나. \n\n\n\nQ. 요즘은 좀 어떤 상태인가요? 5년 전의 지윤님에게 해주고 싶은 말이 있다면 그것도 궁금해요.\n지금요? 지금은 너무 좋아요. 사실 불안감은 지금까지 겪었던 것 중 가장 크거든요. 과거에 크다고 생각했던 문제들이 별 거 아니었던 것처럼 느껴질 정도로요. 솔직히 하루에도 몇 번씩 그 생각이 들어요. ‘이게 맞나?’ \n그럴 때 저는 약간의 나르시시즘이 좀 필요하다는 생각을 해요. ‘나니까 버티는 거지.’ 과거에 했던 성공들을 떠올리면서 스스로 다독여보는 거죠. ‘그래도 네가 한 것들이 있는데, 이것도 그렇게 하겠지.’라고 자기 주문을 외는 것 같아요. 실패한 것들 떠올려봤자 좋을 게 없잖아요. ‘나 아니면 누가 하겠어.’ 계속 그렇게 생각해보는 거죠. 과거의 저도 힘들었던 순간에 이렇게 생각했으면 좋겠다 싶어요. \n\n.css-nv7vyi{margin:24px 0 8px;padding:16px 40px 32px;border-radius:16px;background-color:var(--adaptiveGrey100);}.css-123co55{font-size:19px;letter-spacing:0em;line-height:1.6;margin:24px 0 0;font-weight:400;color:var(--adaptiveGrey900);background-color:transparent;}\n지윤님과 함께 해보고 싶다면?\n지윤님과 비슷한 커리어 패스를 밟아보고 싶거나, 지윤님이 소속되신 AppsInToss Growth Team에서 일해보고 싶은 분들은 댓글을 남겨주세요! 정성스런 댓글을 남겨주신 분 중 추첨하여 지윤님과 토스 오피스에서 1:1 커피챗(30분)에 초대해드려요. .css-ksfp3x{white-space:pre-wrap;color:#4593fc;}*발행일 1주일 뒤에, 그동안 달린 댓글을 기준으로 결과를 공유드려요.\n\n\nInterviewee: 이지윤\nInterviewer & Editor: 김자유, 유아란",
        "content": "네비게이션부터 홈, 그로스까지. 토스에서 10개 넘는 팀을 거치며 새로운 역할에 도전해온 지윤님. 해보지 않은 일을 맡을 때마다, 어떤 마음가짐으로 마주하고 해냈는지 그 이야기를 들려드려요.",
        "contentSnippet": "네비게이션부터 홈, 그로스까지. 토스에서 10개 넘는 팀을 거치며 새로운 역할에 도전해온 지윤님. 해보지 않은 일을 맡을 때마다, 어떤 마음가짐으로 마주하고 해냈는지 그 이야기를 들려드려요.",
        "guid": "https://toss.tech/article/Tosspeople_LeeJiyoon",
        "isoDate": "2025-03-27T14:28:00.000Z"
      },
      {
        "title": "React Native에서 타입 안전한 파일 기반 라우팅 구현하기",
        "link": "https://toss.tech/article/rn-toss-bedrock",
        "pubDate": "Wed, 26 Mar 2025 05:18:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1bda360d-33e3-80be-8ab8-f6f6108851a6\" class=\"css-14on8x8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">안녕하세요. React Native Framework Team에 속한 Frontend Platform Engineer 강선규입니다. 오늘 소개해 드릴 이야기는 토스에서 만드는 React Native Framework와 그 기능에 관한 이야기에요.</span></span></span></p><style data-emotion=\"css 1c1qox8\">.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}</style><h2 id=\"1bda360d-33e3-8070-b8df-d70dd4ce2e16\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><style data-emotion=\"css p4abj2\">.css-p4abj2{display:contents;line-height:1.55;}</style><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">Bedrock이란?</span></span></span></h2><p id=\"1bda360d-33e3-80a8-8087-e59e1e177540\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스는 이전 글 </span><style data-emotion=\"css iynyr0\">.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}</style><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://toss.tech/article/react-native-2024\">토스가 꿈꾸는 React Native 기술의 미래</a><span class=\"css-1kxrhf3\">에서 자체적인 React Native 프레임워크를 개발한다고 공개했어요. 이 글을 통해서 해당 프레임워크, Bedrock을 처음 공개해요.</span></span></span></p><p id=\"1bda360d-33e3-804b-a825-fdf97984acb9\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Bedrock은 React Native 프레임워크로, 단단한 기반암을 의미하는 이름처럼 프로젝트 개발에 견고한 기초를 제공해요. Bedrock은 안정적이고 신뢰할 수 있는 구조를 바탕으로, 다양한 플랫폼에서 일관된 성능과 사용자 경험을 제공해요. 아직은 토스 내부 및 일부 협력사만 사용할 수 있지만, 추후에 공개를 목표로 오픈소스를 목표로 하고 있어요.</span></span></span></p><p id=\"1bda360d-33e3-80e8-a014-eaf6f3ffb247\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">기존 React Native 생태계에는 이미 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><style data-emotion=\"css 1mjnzsq\">.css-1mjnzsq{white-space:pre-wrap;color:var(--adaptiveGrey800);}</style><span class=\"css-1mjnzsq\">Expo</span></code><span class=\"css-1kxrhf3\"> 같은 프레임워크가 존재하며, </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">expo-router</span></code><span class=\"css-1kxrhf3\">는 파일 기반 라우팅(File-Based Routing)을 사용해 화면을 정의합니다. Bedrock 역시 이와 유사하게 파일 기반 라우팅을 채택했으며, 이는 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">react-navigation</span></code><span class=\"css-1kxrhf3\"> v6를 기반으로 합니다. </span></span></span></p><p id=\"1bda360d-33e3-8011-801e-f371800b444e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">오늘은 토스 자체 React Native 프레임워크 Bedrock가 어떻게 파일 기반 라우팅의 문제를 해결했는지 소개해드릴게요.</span></span></span></p><h2 id=\"1bda360d-33e3-806f-8d3b-e2d82d4fd58b\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">기존 파일 기반 라우팅의 문제점</span></span></span></h2><p id=\"1bda360d-33e3-8066-9621-c2656dd71960\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">기존 Bedrock의 파일 기반 라우팅은 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">React Navigation</span></code><span class=\"css-1kxrhf3\">을 추상화한 형태로, </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">pages</span></code><span class=\"css-1kxrhf3\"> 폴더에 컴포넌트를 만들고 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">export default</span></code><span class=\"css-1kxrhf3\">로 화면을 자동 등록하는 방식이었어요.</span></span></span></p><p id=\"1bda360d-33e3-80ba-80e4-f523576f8107\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">예제 코드:</span></span></span></p><p id=\"1bda360d-33e3-8018-9e80-cdfc36f0d359\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">하지만 이 방식은 </span><span class=\"css-q3ktjb\">화면 간 이동할 때 필요한 파라미터의 타입을 정의하기 어렵다</span><span class=\"css-1kxrhf3\">는 문제가 있었어요. 그 결과, 어떤 파라미터가 필요한지 명확하게 알기 힘들었어요.</span></span></span></p><p id=\"1bda360d-33e3-809b-a5e0-ffe796c45fda\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1bda360d-33e3-8087-abd5-f33a6cdfa45f\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">1. Type-Safe Routing을 향한 발전</span></span></span></h2><p id=\"1bda360d-33e3-801b-9133-cb884c5f783d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이런 문제 때문에 최근 웹 프론트엔드에서는 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">tanstack router</span></code><span class=\"css-1kxrhf3\">처럼 </span><span class=\"css-q3ktjb\">타입 안정성(Type-Safety)</span><span class=\"css-1kxrhf3\">을 핵심으로 하는 라우터 프레임워크가 인기를 끌고 있어요.</span></span></span></p><p id=\"1bda360d-33e3-80c9-b043-e147a40d3da7\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Bedrock도 기존 방식의 한계를 보완하기 위해 </span><span class=\"css-q3ktjb\">tanstack router의 방식에서 영감을 받아 Type-Safe한 파일 기반 라우팅을 도입했어요.</span></span></span></p><p id=\"1bda360d-33e3-8040-a22b-e5f15826dc10\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이 방식은 </span><span class=\"css-q3ktjb\">co-location 원칙을 적용</span><span class=\"css-1kxrhf3\">해서 각 화면의 타입을 같은 위치에서 정의하도록 했어요. 덕분에 더 명확한 개발 경험을 제공할 수 있어요.</span></span></span></p><style data-emotion=\"css 1feg9au\">.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}</style><h3 id=\"1bda360d-33e3-80db-838b-cb9cf0db6616\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">개선된 방식 예시</span></span></span></h3><p id=\"1bda360d-33e3-802a-a189-d7fc94dc06c4\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이 방식에서는 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">validateParams</span></code><span class=\"css-1kxrhf3\">로 </span><span class=\"css-q3ktjb\">파라미터를 검증</span><span class=\"css-1kxrhf3\">하고, 그 결과를 자동으로 추론해서 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">params</span></code><span class=\"css-1kxrhf3\"> 타입으로 활용할 수 있어요. 그래서 </span><span class=\"css-q3ktjb\">라우팅이 더 명확하고 안전해졌어요.</span></span></span></p><p id=\"1bda360d-33e3-8055-a2be-e2012469ad51\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">기존에는 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">export default</span></code><span class=\"css-1kxrhf3\">를 기준으로 페이지가 등록됐지만, 이제는 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><style data-emotion=\"css 1y26ms3\">.css-1y26ms3{white-space:pre-wrap;color:var(--adaptiveGrey800);font-weight:bold;}</style><span class=\"css-1y26ms3\">export Route</span></code><span class=\"css-q3ktjb\">의 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1y26ms3\">component</span></code><span class=\"css-q3ktjb\"> 속성을 기준으로 페이지가 등록</span><span class=\"css-1kxrhf3\">돼요.</span></span></span></p><p id=\"1bda360d-33e3-80b3-a0eb-f89f3e8e3acd\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">또한, </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">validateParams</span></code><span class=\"css-1kxrhf3\">를 활용해 </span><span class=\"css-q3ktjb\">각 화면의 타입을 명확하게 정의할 수 있도록 개선</span><span class=\"css-1kxrhf3\">됐어요.</span></span></span></p><h3 id=\"1bda360d-33e3-80cd-a74b-d6edc753d3a7\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">🚩 useParams 내부 구현</span></span></span></h3><p id=\"1bda360d-33e3-8089-9046-ec85036a2301\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">화면의 파라미터는 일반적으로 </span><span class=\"css-q3ktjb\">react-navigation의 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1y26ms3\">useRoute().params</span></code><span class=\"css-1kxrhf3\"> 를 통해 가져올 수 있어요.</span></span></span></p><p id=\"1bda360d-33e3-8007-8f92-fc082837ec6d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Bedrock에서는 이를 활용하여 </span><span class=\"css-q3ktjb\">라우팅 로직과 독립적인</span><span class=\"css-1kxrhf3\"> </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">useParams</span></code><span class=\"css-1kxrhf3\">를 별도로 정의하고, 해당 훅을 BedrockRoute에 연결하는 방식을 사용했어요.</span></span></span></p><p id=\"1bda360d-33e3-80ae-a3f8-c3f109ee4dce\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">실제 구현은 복잡할 수 있지만, 이해를 돕기 위해 간소화된 코드로 설명할게요.</span></span></span></p><p id=\"1bda360d-33e3-8071-846a-c1e29599e4d2\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">✅ 1. 독립적인 useParams 구현하기</span></span></span></p><p id=\"1bda360d-33e3-8037-bdb6-d0b08b0db9bf\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이렇게 만든 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">useParams</span></code><span class=\"css-1kxrhf3\">는 현재 활성화된 라우트의 파라미터만 가져오며, 아직 타입 안정성은 없어요.</span></span></span></p><p id=\"1bda360d-33e3-808c-9e38-f3e3662956bc\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">✅ 2. BedrockRoute에 useParams를 연결하기</span></span></span></p><p id=\"1bda360d-33e3-80b2-b51e-eae5a66f830b\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이제 위에서 만든 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">useParams</span></code><span class=\"css-1kxrhf3\">를 BedrockRoute의 반환값에 넣고, </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">validateParams</span></code><span class=\"css-1kxrhf3\">를 통해 타입 추론을 추가했어요.</span></span></span></p><p id=\"1bda360d-33e3-80c6-aee8-dffd7d3a63d6\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">위 코드에서 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">useParams</span></code><span class=\"css-1kxrhf3\">가 호출될 때, </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">validateParams</span></code><span class=\"css-1kxrhf3\">의 반환 타입(T)을 통해 파라미터의 타입이 명확히 추론돼요.</span></span></span></p><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1bda360d-33e3-80a0-a82a-e499c8448167\" class=\"css-of5acw\"><style data-emotion=\"css 1pgssrp\">.css-1pgssrp{max-width:100%;border-radius:16px;}</style><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/9dc9aae0-6af0-4b8d-99e4-9d96ed9424b7/image.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1bda360d-33e3-80b3-a03b-de54b4d58574\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1bda360d-33e3-80ee-ab74-de474167719c\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-q3ktjb\">2. 화면 타입의 중앙 관리</span></span></span></h2><p id=\"1bda360d-33e3-80cc-8ace-e9ea71d6d7ae\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">앞서 설명한 것처럼, </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">Route.useParams()</span></code><span class=\"css-1kxrhf3\">는 각 화면에서 정의한 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">validateParams</span></code><span class=\"css-1kxrhf3\">를 기반으로 파라미터의 타입을 자동 추론해서 제공합니다.</span></span></span></p><p id=\"1bda360d-33e3-802a-924a-fdb026de2872\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이렇게 추론된 각 화면의 타입은 </span><span class=\"css-q3ktjb\">외부 파일에서 중앙 집중적으로 관리</span><span class=\"css-1kxrhf3\">하고 있어요. 이를 위해 </span><span class=\"css-q3ktjb\">타입 선언 병합</span><span class=\"css-1kxrhf3\">(Declaration Merging)을 사용해서, 라이브러리 내부에서도 각 화면의 타입 정보를 명확히 알 수 있게 했어요.</span></span></span></p><p id=\"1bda360d-33e3-8019-b493-d3715733bfbe\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">다음 예시를 살펴볼게요:</span></span></span></p><p id=\"1bda360d-33e3-8073-ba71-f58eeceb7413\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">이 코드가 의미하는 것:</span></span></span></p><style data-emotion=\"css uswsmm\">.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ul class=\"css-uswsmm\"><style data-emotion=\"css 1hwiibq\">.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}</style><li id=\"1bda360d-33e3-801b-b3c0-feac8350b5d8\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">화면 경로(예: /page-a, /page-b)가 타입 등록의 키(Key)가 돼요.</span></span></span></li><li id=\"1bda360d-33e3-8079-9293-e1a3ff9ae7c5\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">각 경로에 해당하는 값(Value)은 Route.useParams()의 반환값으로, 각 페이지에서 정의한 validateParams의 결과 타입이에요.</span></span></span></li><li id=\"1bda360d-33e3-8070-9e19-d334833a9560\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">새로운 페이지를 추가할 때마다 여기에 화면의 경로와 타입을 간단히 추가하면, 전체 앱의 라우팅 타입을 명확하게 관리할 수 있어요.</span></span></span></li></ul><p id=\"1bda360d-33e3-807c-a716-c0e4d4295dfb\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이렇게 하면 모든 페이지에 관해서 모든 타입을 한번에 관리할 수 있어요.</span></span></span></p><p id=\"1bda360d-33e3-80e2-bc63-e7d5116896ab\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1bda360d-33e3-806f-a779-ed9a843fdca8\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-q3ktjb\">3. 컴파일 타임 자동 타입 생성</span></span></span></h2><p id=\"1bda360d-33e3-8079-b720-c9b0f83d4652\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">화면이 많아질수록 수동으로 모든 타입을 관리하는 건 어렵기 때문에, 이를 자동화하는 방식을 도입했어요.</span></span></span></p><p id=\"1bda360d-33e3-80f7-94e8-eb216836aa41\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">토스의 자체 React Native 번들러는 웹 생태계와 유사한 플러그인 구조를 갖추고 있어서, 번들러의 라이프사이클에 접근할 수 있어요. 이를 활용해 </span><span class=\"css-q3ktjb\">자동 타입 생성 플러그인</span><span class=\"css-1kxrhf3\">을 만들었어요.</span></span></span></p><p id=\"1bda360d-33e3-80f9-8a6b-c4c6b4d1c6e8\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">번들러가 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">/pages</span></code><span class=\"css-1kxrhf3\"> 폴더의 변경 사항을 감지하고, </span><span class=\"css-q3ktjb\">새로운 페이지가 추가될 때마다 자동으로 타입을 등록</span><span class=\"css-1kxrhf3\">하도록 만들었어요.</span></span></span></p><h3 id=\"1bda360d-33e3-80e6-a602-cea4617b0ed3\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">설정 파일 예제</span></span></span></h3><p id=\"1bda360d-33e3-8056-a0a3-f8cda6819d05\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">자동 타입 생성을 사용하려면 </span><span class=\"css-q3ktjb\">번들러 설정에 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">RouteGenPlugin</span></code><span class=\"css-q3ktjb\"> 플러그인을 추가</span><span class=\"css-1kxrhf3\">하면 돼요.</span></span></span></p><p id=\"1bda360d-33e3-8008-96f8-c4a240bb9c70\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이제 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">/pages</span></code><span class=\"css-1kxrhf3\"> 폴더에 새로운 파일을 추가하면 </span><span class=\"css-q3ktjb\">자동으로 해당 페이지의 라우트와 타입이 생성돼요.</span></span></span></p><h3 id=\"1bda360d-33e3-80c5-bf38-d0c164393b1d\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">자동 타입 생성 방식</span></span></span></h3><p id=\"1bda360d-33e3-80cb-b94c-db840df5c144\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이 플러그인은 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1y26ms3\">chokidar</span></code><span class=\"css-q3ktjb\"> 나 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1y26ms3\">@parcel/watcher</span></code><span class=\"css-q3ktjb\">를 활용해 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1y26ms3\">/pages</span></code><span class=\"css-q3ktjb\"> 폴더의 변경 사항을 실시간으로 감시할 수 있어요</span><span class=\"css-1kxrhf3\">.</span></span></span></p><p id=\"1bda360d-33e3-806f-8101-f688be64dba4\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">새로운 파일이 추가되면 </span><span class=\"css-q3ktjb\">이를 새로운 페이지로 인식하고, 자동으로 라우트와 타입을 생성</span><span class=\"css-1kxrhf3\">해요. 즉, </span><span class=\"css-q3ktjb\">파일명이 곧 페이지 경로가 되며</span><span class=\"css-1kxrhf3\">, 기본적인 스캐폴딩 코드가 자동으로 생성돼요. 예를 들어, </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">pages/about.tsx</span></code><span class=\"css-1kxrhf3\"> 파일을 만들면 자동으로 아래와 같은 코드가 생성돼요.</span></span></span></p><h3 id=\"1bda360d-33e3-80cd-a74d-e9da403b367a\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">자동 생성되는 페이지 코드</span></span></span></h3><h3 id=\"1c1a360d-33e3-8032-b0eb-db0cb48a54f0\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">자동 생성되는 타입 등록 코드</span></span></span></h3><p id=\"1c1a360d-33e3-800b-b921-d3e3c31bb7ee\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이 플러그인은 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">/pages</span></code><span class=\"css-1kxrhf3\"> 폴더의 변경 사항을 감지해 </span><span class=\"css-q3ktjb\">새로운 페이지가 추가될 때마다 자동으로 타입을 생성</span><span class=\"css-1kxrhf3\">해요. 위에 언급한 대로 파일을(</span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">pages/about.tsx</span></code><span class=\"css-1kxrhf3\">)를 만들면 아래와 같은 코드가 자동으로 등록돼요.</span></span></span></p><p id=\"1c1a360d-33e3-8099-bff9-cdf827b93e9a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">마찬가지로, </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">pages/page-b.tsx</span></code><span class=\"css-1kxrhf3\"> 파일을 추가하면 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">/page-b</span></code><span class=\"css-1kxrhf3\">에 대한 타입도 자동으로 반영돼요.</span></span></span></p><p id=\"1c1a360d-33e3-80aa-9621-e4c9c5ec3c68\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c1a360d-33e3-808d-ae68-cf61a22605bb\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">하지만 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">/pages</span></code><span class=\"css-1kxrhf3\"> 폴더에 새 파일이 추가되었다고 무조건 타입을 추가하면 문제가 생길 수 있어요. 파일 내부에 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">export const Route</span></code><span class=\"css-1kxrhf3\">가 정의되지 않은 경우가 있을 수 있기 때문이에요.</span></span></span></p><p id=\"1c1a360d-33e3-803d-bcbd-f6ccfc494483\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c1a360d-33e3-80b5-a4e2-dc3f512ac49c\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">여기서 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">Route</span></code><span class=\"css-1kxrhf3\">를 내보내는 방법은 크게 두 가지가 있어요.</span></span></span></p><p id=\"1c1a360d-33e3-8066-a00c-e196983bc389\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c1a360d-33e3-8032-a906-f6ee3ae78aea\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">정규 표현식으로 문자열을 검사하면 코드 포맷에 따라 발생하는 예외 케이스(예: 줄바꿈이나 공백 등)를 처리하기 어려워요. 따라서 이를 해결하기 위해 </span><span class=\"css-q3ktjb\">SWC를 활용해 AST(Abstract Syntax Tree)를 분석</span><span class=\"css-1kxrhf3\">해서, 파일이 실제로 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">Route</span></code><span class=\"css-1kxrhf3\">를 내보내고 있는지 정확하게 확인해요.</span></span></span></p><figure id=\"1c1a360d-33e3-8022-85d0-f9f3b9f9041f\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/7c1fe7ed-644b-4019-94c2-8f94b3b8eca3/image.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1c1a360d-33e3-80ad-a67f-c80a047850a9\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c1a360d-33e3-8025-8862-ece582a5ca05\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c1a360d-33e3-80cf-b139-e9e189d5f4b1\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이런 방식을 통해, 개발자는 더 이상 </span><span class=\"css-q3ktjb\">별도로 타입을 수동 정의할 필요가 없어요.</span><span class=\"css-1kxrhf3\"> 단지 새로운 페이지를 추가하는 것만으로도 </span><span class=\"css-q3ktjb\">타입이 자동으로 관리되어 유지보수가 간편하고 라우팅 안정성이 높아져요.</span></span></span></p><h2 id=\"1bda360d-33e3-80ec-9089-d7b4b4890ca1\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">4. 타입-안전한 useNavigation 구현하기</span></span></span></h2><p id=\"1bda360d-33e3-80c9-950e-d16655d9de05\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">기존의 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">react-navigation</span></code><span class=\"css-1kxrhf3\">에서는 네비게이션 사용 시 페이지마다 명시적으로 타입을 선언해주어야 했습니다.</span></span></span></p><p id=\"1bda360d-33e3-801a-bcb9-d5142224a43e\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">예를 들어 기존 방식은 아래와 같습니다:</span></span></span></p><h3 id=\"1bda360d-33e3-80e8-8d35-ea82512228c7\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Bedrock에서의 개선된 접근법</span></span></span></h3><p id=\"1bda360d-33e3-80d5-af90-f8f262e3e5fa\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Bedrock에서는 중앙에서 관리되는 타입 선언(</span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">RegisterScreen</span></code><span class=\"css-1kxrhf3\">)을 선언 병합(declaration merging)하여, 모든 화면에서 자동으로 타입이 제공되도록 개선할 수 있습니다.</span></span></span></p><p id=\"1bda360d-33e3-80f6-bd0b-dc359a77f714\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">아래는 Bedrock의 개선된 </span><code style=\"font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px\"><span class=\"css-1mjnzsq\">useNavigation</span></code><span class=\"css-1kxrhf3\"> 훅 구현입니다:</span></span></span></p><p id=\"1bda360d-33e3-80eb-be13-cc5c383ec05d\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">개발자는 이제 별도의 제네릭을 매번 설정하지 않고도, 각 화면의 타입을 자동으로 정확하게 추론하여 사용할 수 있습니다.</span></span></span></p><h3 id=\"1bda360d-33e3-806c-8b97-d1e66fefe62a\" class=\"css-1feg9au\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">타입 추론을 활용한 화면 이동 예시</span></span></span></h3><p id=\"1bda360d-33e3-8021-b93a-f691918d30ec\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">다음과 같은 화면 이동 시, Bedrock이 제공하는 타입 추론으로 인해 파라미터의 타입이 자동 검증됩니다:</span></span></span></p><p id=\"1bda360d-33e3-8097-bdf2-d3dc43c996e8\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이제 잘못된 파라미터 값을 전달하면 컴파일 단계에서 오류가 즉시 발생하여, 개발자의 타입 안정성을 크게 높일 수 있습니다.</span></span></span></p><figure id=\"1bda360d-33e3-80e8-aba3-cc5d6dba5b44\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/bce8e4f3-c60d-421a-9309-53c4c17af414/image.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><figure id=\"1bda360d-33e3-80dc-88b6-dd873c4c422c\" class=\"css-of5acw\"><img src=\"https://static.toss.im/ipd-tcs/toss_core/live/8902b1ac-48fd-45a3-a2c6-47fc97c2d584/image.png\" alt=\"\" class=\"css-1pgssrp\"/></figure><p id=\"1bda360d-33e3-808b-9147-d288a24effc5\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><h2 id=\"1bda360d-33e3-8067-acb3-f7327a7a4fd1\" class=\"css-1c1qox8\"><span class=\"css-1r3ko7u\"><span class=\"css-p4abj2\"><span class=\"css-1kxrhf3\">마무리하며</span></span></span></h2><p id=\"1bda360d-33e3-80fe-92e8-ed3dc5dc6083\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">이 기능을 활용하면 React Native에서 화면 전환을 훨씬 더 안전하게 관리할 수 있어요. 화면의 경로를 문자열로 직접 입력하지 않고 타입으로 정의하기 때문에, 오타로 엉뚱한 화면으로 이동하는 일을 막을 수 있죠. 어떤 화면으로 이동할 수 있는지도 코드에서 바로 확인할 수 있어서 개발 생산성도 높아져요.</span></span></span></p><p id=\"1bda360d-33e3-8049-9778-e9bf15f93db0\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">Bedrock은 iOS, Android, 프론트엔드 플랫폼 개발자들이 각자의 전문성을 살려 함께 RN Framework Team에서 만든 프로젝트예요. React Native 번들러부터 인프라까지 직접 구축해, 이 모든 걸 누구나 쓸 수 있도록 공개하는 게 목표예요.</span></span></span></p><p id=\"1bda360d-33e3-80a1-9cdc-dd061c8fedde\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">장기적으로는 전 세계 React Native 개발자들이 함께 사용할 수 있는 모범 사례(Best Practice)가 되는 것을 지향하고 있어요. 더 나아가, 웹 개발자들도 네이티브 앱 개발에 쉽게 참여할 수 있도록 확장해 나갈 계획이에요!</span></span></span></p><p id=\"1bda360d-33e3-8037-9a40-ce9d4efa2c53\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-1kxrhf3{white-space:pre-wrap;}안녕하세요. React Native Framework Team에 속한 Frontend Platform Engineer 강선규입니다. 오늘 소개해 드릴 이야기는 토스에서 만드는 React Native Framework와 그 기능에 관한 이야기에요.\n.css-1c1qox8{font-size:30px;letter-spacing:0em;line-height:1.55;font-weight:bold;color:var(--adaptiveGrey900);margin:40px 0 4px;}\n.css-p4abj2{display:contents;line-height:1.55;}Bedrock이란?\n토스는 이전 글 .css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}토스가 꿈꾸는 React Native 기술의 미래에서 자체적인 React Native 프레임워크를 개발한다고 공개했어요. 이 글을 통해서 해당 프레임워크, Bedrock을 처음 공개해요.\nBedrock은 React Native 프레임워크로, 단단한 기반암을 의미하는 이름처럼 프로젝트 개발에 견고한 기초를 제공해요. Bedrock은 안정적이고 신뢰할 수 있는 구조를 바탕으로, 다양한 플랫폼에서 일관된 성능과 사용자 경험을 제공해요. 아직은 토스 내부 및 일부 협력사만 사용할 수 있지만, 추후에 공개를 목표로 오픈소스를 목표로 하고 있어요.\n기존 React Native 생태계에는 이미 .css-1mjnzsq{white-space:pre-wrap;color:var(--adaptiveGrey800);}Expo 같은 프레임워크가 존재하며, expo-router는 파일 기반 라우팅(File-Based Routing)을 사용해 화면을 정의합니다. Bedrock 역시 이와 유사하게 파일 기반 라우팅을 채택했으며, 이는 react-navigation v6를 기반으로 합니다. \n오늘은 토스 자체 React Native 프레임워크 Bedrock가 어떻게 파일 기반 라우팅의 문제를 해결했는지 소개해드릴게요.\n.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}기존 파일 기반 라우팅의 문제점\n기존 Bedrock의 파일 기반 라우팅은 React Navigation을 추상화한 형태로, pages 폴더에 컴포넌트를 만들고 export default로 화면을 자동 등록하는 방식이었어요.\n예제 코드:\n하지만 이 방식은 화면 간 이동할 때 필요한 파라미터의 타입을 정의하기 어렵다는 문제가 있었어요. 그 결과, 어떤 파라미터가 필요한지 명확하게 알기 힘들었어요.\n\n1. Type-Safe Routing을 향한 발전\n이런 문제 때문에 최근 웹 프론트엔드에서는 tanstack router처럼 타입 안정성(Type-Safety)을 핵심으로 하는 라우터 프레임워크가 인기를 끌고 있어요.\nBedrock도 기존 방식의 한계를 보완하기 위해 tanstack router의 방식에서 영감을 받아 Type-Safe한 파일 기반 라우팅을 도입했어요.\n이 방식은 co-location 원칙을 적용해서 각 화면의 타입을 같은 위치에서 정의하도록 했어요. 덕분에 더 명확한 개발 경험을 제공할 수 있어요.\n.css-1feg9au{font-size:24px;letter-spacing:0em;line-height:1.6;font-weight:bold;color:var(--adaptiveGrey900);margin:24px 0 4px;}\n개선된 방식 예시\n이 방식에서는 validateParams로 파라미터를 검증하고, 그 결과를 자동으로 추론해서 params 타입으로 활용할 수 있어요. 그래서 라우팅이 더 명확하고 안전해졌어요.\n기존에는 export default를 기준으로 페이지가 등록됐지만, 이제는 .css-1y26ms3{white-space:pre-wrap;color:var(--adaptiveGrey800);font-weight:bold;}export Route의 component 속성을 기준으로 페이지가 등록돼요.\n또한, validateParams를 활용해 각 화면의 타입을 명확하게 정의할 수 있도록 개선됐어요.\n🚩 useParams 내부 구현\n화면의 파라미터는 일반적으로 react-navigation의 useRoute().params 를 통해 가져올 수 있어요.\nBedrock에서는 이를 활용하여 라우팅 로직과 독립적인 useParams를 별도로 정의하고, 해당 훅을 BedrockRoute에 연결하는 방식을 사용했어요.\n실제 구현은 복잡할 수 있지만, 이해를 돕기 위해 간소화된 코드로 설명할게요.\n✅ 1. 독립적인 useParams 구현하기\n이렇게 만든 useParams는 현재 활성화된 라우트의 파라미터만 가져오며, 아직 타입 안정성은 없어요.\n✅ 2. BedrockRoute에 useParams를 연결하기\n이제 위에서 만든 useParams를 BedrockRoute의 반환값에 넣고, validateParams를 통해 타입 추론을 추가했어요.\n위 코드에서 useParams가 호출될 때, validateParams의 반환 타입(T)을 통해 파라미터의 타입이 명확히 추론돼요.\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-1pgssrp{max-width:100%;border-radius:16px;}\n\n2. 화면 타입의 중앙 관리\n앞서 설명한 것처럼, Route.useParams()는 각 화면에서 정의한 validateParams를 기반으로 파라미터의 타입을 자동 추론해서 제공합니다.\n이렇게 추론된 각 화면의 타입은 외부 파일에서 중앙 집중적으로 관리하고 있어요. 이를 위해 타입 선언 병합(Declaration Merging)을 사용해서, 라이브러리 내부에서도 각 화면의 타입 정보를 명확히 알 수 있게 했어요.\n다음 예시를 살펴볼게요:\n이 코드가 의미하는 것:\n.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\n화면 경로(예: /page-a, /page-b)가 타입 등록의 키(Key)가 돼요.\n각 경로에 해당하는 값(Value)은 Route.useParams()의 반환값으로, 각 페이지에서 정의한 validateParams의 결과 타입이에요.\n새로운 페이지를 추가할 때마다 여기에 화면의 경로와 타입을 간단히 추가하면, 전체 앱의 라우팅 타입을 명확하게 관리할 수 있어요.\n\n이렇게 하면 모든 페이지에 관해서 모든 타입을 한번에 관리할 수 있어요.\n\n3. 컴파일 타임 자동 타입 생성\n화면이 많아질수록 수동으로 모든 타입을 관리하는 건 어렵기 때문에, 이를 자동화하는 방식을 도입했어요.\n토스의 자체 React Native 번들러는 웹 생태계와 유사한 플러그인 구조를 갖추고 있어서, 번들러의 라이프사이클에 접근할 수 있어요. 이를 활용해 자동 타입 생성 플러그인을 만들었어요.\n번들러가 /pages 폴더의 변경 사항을 감지하고, 새로운 페이지가 추가될 때마다 자동으로 타입을 등록하도록 만들었어요.\n설정 파일 예제\n자동 타입 생성을 사용하려면 번들러 설정에 RouteGenPlugin 플러그인을 추가하면 돼요.\n이제 /pages 폴더에 새로운 파일을 추가하면 자동으로 해당 페이지의 라우트와 타입이 생성돼요.\n자동 타입 생성 방식\n이 플러그인은 chokidar 나 @parcel/watcher를 활용해 /pages 폴더의 변경 사항을 실시간으로 감시할 수 있어요.\n새로운 파일이 추가되면 이를 새로운 페이지로 인식하고, 자동으로 라우트와 타입을 생성해요. 즉, 파일명이 곧 페이지 경로가 되며, 기본적인 스캐폴딩 코드가 자동으로 생성돼요. 예를 들어, pages/about.tsx 파일을 만들면 자동으로 아래와 같은 코드가 생성돼요.\n자동 생성되는 페이지 코드\n자동 생성되는 타입 등록 코드\n이 플러그인은 /pages 폴더의 변경 사항을 감지해 새로운 페이지가 추가될 때마다 자동으로 타입을 생성해요. 위에 언급한 대로 파일을(pages/about.tsx)를 만들면 아래와 같은 코드가 자동으로 등록돼요.\n마찬가지로, pages/page-b.tsx 파일을 추가하면 /page-b에 대한 타입도 자동으로 반영돼요.\n\n하지만 /pages 폴더에 새 파일이 추가되었다고 무조건 타입을 추가하면 문제가 생길 수 있어요. 파일 내부에 export const Route가 정의되지 않은 경우가 있을 수 있기 때문이에요.\n\n여기서 Route를 내보내는 방법은 크게 두 가지가 있어요.\n\n정규 표현식으로 문자열을 검사하면 코드 포맷에 따라 발생하는 예외 케이스(예: 줄바꿈이나 공백 등)를 처리하기 어려워요. 따라서 이를 해결하기 위해 SWC를 활용해 AST(Abstract Syntax Tree)를 분석해서, 파일이 실제로 Route를 내보내고 있는지 정확하게 확인해요.\n\n\n\n이런 방식을 통해, 개발자는 더 이상 별도로 타입을 수동 정의할 필요가 없어요. 단지 새로운 페이지를 추가하는 것만으로도 타입이 자동으로 관리되어 유지보수가 간편하고 라우팅 안정성이 높아져요.\n4. 타입-안전한 useNavigation 구현하기\n기존의 react-navigation에서는 네비게이션 사용 시 페이지마다 명시적으로 타입을 선언해주어야 했습니다.\n예를 들어 기존 방식은 아래와 같습니다:\nBedrock에서의 개선된 접근법\nBedrock에서는 중앙에서 관리되는 타입 선언(RegisterScreen)을 선언 병합(declaration merging)하여, 모든 화면에서 자동으로 타입이 제공되도록 개선할 수 있습니다.\n아래는 Bedrock의 개선된 useNavigation 훅 구현입니다:\n개발자는 이제 별도의 제네릭을 매번 설정하지 않고도, 각 화면의 타입을 자동으로 정확하게 추론하여 사용할 수 있습니다.\n타입 추론을 활용한 화면 이동 예시\n다음과 같은 화면 이동 시, Bedrock이 제공하는 타입 추론으로 인해 파라미터의 타입이 자동 검증됩니다:\n이제 잘못된 파라미터 값을 전달하면 컴파일 단계에서 오류가 즉시 발생하여, 개발자의 타입 안정성을 크게 높일 수 있습니다.\n\n\n마무리하며\n이 기능을 활용하면 React Native에서 화면 전환을 훨씬 더 안전하게 관리할 수 있어요. 화면의 경로를 문자열로 직접 입력하지 않고 타입으로 정의하기 때문에, 오타로 엉뚱한 화면으로 이동하는 일을 막을 수 있죠. 어떤 화면으로 이동할 수 있는지도 코드에서 바로 확인할 수 있어서 개발 생산성도 높아져요.\nBedrock은 iOS, Android, 프론트엔드 플랫폼 개발자들이 각자의 전문성을 살려 함께 RN Framework Team에서 만든 프로젝트예요. React Native 번들러부터 인프라까지 직접 구축해, 이 모든 걸 누구나 쓸 수 있도록 공개하는 게 목표예요.\n장기적으로는 전 세계 React Native 개발자들이 함께 사용할 수 있는 모범 사례(Best Practice)가 되는 것을 지향하고 있어요. 더 나아가, 웹 개발자들도 네이티브 앱 개발에 쉽게 참여할 수 있도록 확장해 나갈 계획이에요!",
        "content": "오늘은 토스 자체 React Native 프레임워크 Bedrock가 어떻게 파일 기반 라우팅의 문제를 해결했는지 소개해드릴게요.",
        "contentSnippet": "오늘은 토스 자체 React Native 프레임워크 Bedrock가 어떻게 파일 기반 라우팅의 문제를 해결했는지 소개해드릴게요.",
        "guid": "https://toss.tech/article/rn-toss-bedrock",
        "isoDate": "2025-03-26T05:18:00.000Z"
      },
      {
        "title": "토스의 디자인 편집기 ‘데우스’, 이렇게 만들었어요! | EP.11",
        "link": "https://toss.tech/article/firesidechat_frontend_11",
        "pubDate": "Mon, 24 Mar 2025 12:04:00 GMT",
        "content:encoded": "<style data-emotion=\"css 1vn47db\">.css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}</style><div class=\"css-1vn47db\"><style data-emotion=\"css of5acw\">.css-of5acw{margin:24px 0 8px;text-align:center;}</style><figure id=\"1c0a360d-33e3-8052-960e-c80fd6556187\" class=\"css-of5acw\"><style data-emotion=\"css oni540\">.css-oni540{position:relative;width:100%;height:0;padding-bottom:56.25%;}</style><div class=\"css-oni540\"><style data-emotion=\"css 122y91a\">.css-122y91a{position:absolute;top:0;left:0;width:100%;height:100%;}</style><iframe src=\"https://www.youtube.com/embed/L68YmRoLDvY\" frameBorder=\"0\" allowfullscreen=\"\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" class=\"css-122y91a\"></iframe></div></figure><style data-emotion=\"css 14on8x8\">.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}</style><p id=\"1c0a360d-33e3-8034-a157-fdb8d8bb4660\" class=\"css-14on8x8\"><style data-emotion=\"css 1r3ko7u\">.css-1r3ko7u{line-height:0;display:block;}</style><span class=\"css-1r3ko7u\"><style data-emotion=\"css 1iisb9p\">.css-1iisb9p{display:contents;line-height:1.6;}</style><span class=\"css-1iisb9p\"><style data-emotion=\"css 1kxrhf3\">.css-1kxrhf3{white-space:pre-wrap;}</style><span class=\"css-1kxrhf3\">토스의 디자인 편집기 데우스(Deus)!\n이번 모닥불에서는 토스의 자체 디자인 편집기 데우스(Deus) 프로젝트를 소개합니다!🔥</span></span></span></p><p id=\"1c0a360d-33e3-80c0-98ec-e1601c63d9e7\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">시장에 이미 훌륭한 디자인 툴이 있는데, 토스는 왜 자체 편집기를 만들었을까요?\n데우스(Deus), 성능 최적화를 위해 어떠한 기술적 도전들이 있었고, 어떻게 해결 했을까요?</span></span></span></p><p id=\"1c0a360d-33e3-804f-89de-c4dde00ea451\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">디자인과 개발 사이의 경계를 넘나드는 새로운 가능성을 만나보세요!🔥\n데우스(Deus)가 풀어낸 기술적 도전과 그 여정을 통해, 우리가 함께 만들어갈 미래를 이야기합니다.</span></span></span></p><p id=\"1c0a360d-33e3-801a-a7ae-eabe19d08574\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c0a360d-33e3-8049-b0aa-e89fd1bf1fb7\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css q3ktjb\">.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}</style><span class=\"css-q3ktjb\">타임스탬프</span></span></span></p><style data-emotion=\"css uswsmm\">.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}</style><ul class=\"css-uswsmm\"><style data-emotion=\"css 1hwiibq\">.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}</style><li id=\"1c0a360d-33e3-80b2-bb0d-ebc47bf89f5b\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><style data-emotion=\"css iynyr0\">.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}</style><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.youtube.com/watch?v=L68YmRoLDvY\">00:00</a><span class=\"css-1kxrhf3\"> 인트로</span></span></span></li><li id=\"1c0a360d-33e3-8045-a79f-f5bf19de9b14\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.youtube.com/watch?v=L68YmRoLDvY&amp;t=84s\">01:24</a><span class=\"css-1kxrhf3\"> 데우스(Deus), 무엇인가요?</span></span></span></li><li id=\"1c0a360d-33e3-80be-b37e-ea6959a7d627\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.youtube.com/watch?v=L68YmRoLDvY&amp;t=103s\">01:43</a><span class=\"css-1kxrhf3\"> 토스가 디자인 편집기 &#x27;데우스(Deus)&#x27; 를 직접 만든 이유</span></span></span></li><li id=\"1c0a360d-33e3-80b4-9ef0-cd0f6c160652\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.youtube.com/watch?v=L68YmRoLDvY&amp;t=203s\">03:23</a><span class=\"css-1kxrhf3\"> 지난 개발 과정에서 마주한 수많은 기술적 도전과 과제들</span></span></span></li><li id=\"1c0a360d-33e3-80bf-8486-c9c75c9065a9\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.youtube.com/watch?v=L68YmRoLDvY&amp;t=444s\">07:24</a><span class=\"css-1kxrhf3\"> 상태 관리를 위해 MobX를 선택한 기술적 배경은?</span></span></span></li><li id=\"1c0a360d-33e3-8050-a8a3-e5763a196f20\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.youtube.com/watch?v=L68YmRoLDvY&amp;t=877s\">14:37</a><span class=\"css-1kxrhf3\"> 데우스(Deus)의 무한한 가능성 그리고 앞으로의 목표</span></span></span></li></ul><p id=\"1c0a360d-33e3-8056-8894-e0e8b2b99c66\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c0a360d-33e3-80b1-9bd4-e4fc0cc857bf\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">출연진</span></span></span></p><ul class=\"css-uswsmm\"><li id=\"1c0a360d-33e3-809b-a031-e4563f04b10f\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">박서진, 토스 Head of Frontend</span></span></span></li><li id=\"1c0a360d-33e3-80fd-97e4-e79f5fdb8021\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">임지훈, 토스 Frontend UX Engineer</span></span></span></li><li id=\"1c0a360d-33e3-8091-a52f-fe64f15eb4d2\" class=\"css-1hwiibq\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-1kxrhf3\">조유성, 토스 Frontend UX Engineer</span></span></span></li></ul><p id=\"1c0a360d-33e3-8037-9585-e4edca598112\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c0a360d-33e3-8000-a86f-c9145ac157bb\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">토스 Frontend Developer(Deus) 포지션</span><span class=\"css-1kxrhf3\">\n  📍바로 지원하기 👉 </span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://buly.kr/Coheij\">https://buly.kr/Coheij</a></span></span></p><p id=\"1c0a360d-33e3-81ba-83dd-c80577e69dbb\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p><p id=\"1c0a360d-33e3-812e-a8a5-fb7ee75ca651\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"><span class=\"css-q3ktjb\">다른 모닥불 회차 보러가기</span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://youtu.be/BGZaUpUtY6k\">\n</a><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.youtube.com/watch?v=upUON56UEYo\">EP.9 프론트엔드 서비스 최적화? 토스에서는 &#x27;이렇게&#x27; 합니다!\n</a><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://www.youtube.com/watch?v=Ddy29yiC19A&amp;t=0s\">EP.10 캠프파이어 특집 상편 | 무엇이든 물어보세요 (feat. 프론트엔드 코드, 디렉토리 관리)</a><span class=\"css-1kxrhf3\">\n</span><a target=\"_blank\" rel=\"noreferrer noopener\" class=\"css-iynyr0\" href=\"https://youtu.be/bnWUCFTvM3g\">EP.10 캠프파이어 특집 하편 | 무엇이든 물어보세요 (feat. 테스트 코드, ESLint Rule)</a></span></span></p><p id=\"1c0a360d-33e3-81ed-9898-cf77c1d1104a\" class=\"css-14on8x8\"><span class=\"css-1r3ko7u\"><span class=\"css-1iisb9p\"></span></span></p></div>",
        "content:encodedSnippet": ".css-1vn47db{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;}\n.css-of5acw{margin:24px 0 8px;text-align:center;}.css-oni540{position:relative;width:100%;height:0;padding-bottom:56.25%;}\n.css-122y91a{position:absolute;top:0;left:0;width:100%;height:100%;}\n.css-14on8x8{font-size:17px;letter-spacing:0em;line-height:1.6;font-weight:normal;color:var(--adaptiveGrey800);margin:24px 0 8px;}\n.css-1r3ko7u{line-height:0;display:block;}.css-1iisb9p{display:contents;line-height:1.6;}.css-1kxrhf3{white-space:pre-wrap;}토스의 디자인 편집기 데우스(Deus)!\n이번 모닥불에서는 토스의 자체 디자인 편집기 데우스(Deus) 프로젝트를 소개합니다!🔥\n시장에 이미 훌륭한 디자인 툴이 있는데, 토스는 왜 자체 편집기를 만들었을까요?\n데우스(Deus), 성능 최적화를 위해 어떠한 기술적 도전들이 있었고, 어떻게 해결 했을까요?\n디자인과 개발 사이의 경계를 넘나드는 새로운 가능성을 만나보세요!🔥\n데우스(Deus)가 풀어낸 기술적 도전과 그 여정을 통해, 우리가 함께 만들어갈 미래를 이야기합니다.\n\n.css-q3ktjb{white-space:pre-wrap;font-weight:bold;}타임스탬프\n.css-uswsmm{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex:none;-ms-flex:none;flex:none;margin:24px 0 8px;padding:0;list-style:none;}.css-uswsmm ul,.css-uswsmm ol{margin:16px 0 0;}.css-uswsmm>li{margin-bottom:16px;padding-left:24px;}.css-uswsmm>li:last-of-type{margin-bottom:0;}.css-uswsmm>li>span{position:relative;}.css-uswsmm>li>span>:first-child::before{content:'•';font-weight:500;color:var(--adaptiveGrey800);position:absolute;left:-24px;}\n.css-1hwiibq{font-size:17px;line-height:1.6;word-break:keep-all;letter-spacing:0em;font-weight:400;color:var(--adaptiveGrey800);}\n.css-iynyr0{white-space:pre-wrap;cursor:pointer;color:var(--adaptiveGrey600);-webkit-text-decoration:underline!important;text-decoration:underline!important;}00:00 인트로\n01:24 데우스(Deus), 무엇인가요?\n01:43 토스가 디자인 편집기 '데우스(Deus)' 를 직접 만든 이유\n03:23 지난 개발 과정에서 마주한 수많은 기술적 도전과 과제들\n07:24 상태 관리를 위해 MobX를 선택한 기술적 배경은?\n14:37 데우스(Deus)의 무한한 가능성 그리고 앞으로의 목표\n\n\n출연진\n\n박서진, 토스 Head of Frontend\n임지훈, 토스 Frontend UX Engineer\n조유성, 토스 Frontend UX Engineer\n\n\n토스 Frontend Developer(Deus) 포지션\n  📍바로 지원하기 👉 https://buly.kr/Coheij\n\n다른 모닥불 회차 보러가기\nEP.9 프론트엔드 서비스 최적화? 토스에서는 '이렇게' 합니다!\nEP.10 캠프파이어 특집 상편 | 무엇이든 물어보세요 (feat. 프론트엔드 코드, 디렉토리 관리)\nEP.10 캠프파이어 특집 하편 | 무엇이든 물어보세요 (feat. 테스트 코드, ESLint Rule)",
        "content": "토스의 디자인 편집기 데우스(Deus)!\n이번 모닥불에서는 토스의 자체 디자인 편집기 데우스(Deus) 프로젝트를 소개합니다! \n\n디자인과 개발 사이의 경계를 넘나드는 새로운 가능성을 만나보세요! 데우스(Deus)가 풀어낸 기술적 도전과 그 여정을 통해, 우리가 함께 만들어갈 미래를 이야기합니다.",
        "contentSnippet": "토스의 디자인 편집기 데우스(Deus)!\n이번 모닥불에서는 토스의 자체 디자인 편집기 데우스(Deus) 프로젝트를 소개합니다! \n\n디자인과 개발 사이의 경계를 넘나드는 새로운 가능성을 만나보세요! 데우스(Deus)가 풀어낸 기술적 도전과 그 여정을 통해, 우리가 함께 만들어갈 미래를 이야기합니다.",
        "guid": "https://toss.tech/article/firesidechat_frontend_11",
        "isoDate": "2025-03-24T12:04:00.000Z"
      }
    ]
  },
  {
    "title": "당근 테크 블로그 - Medium",
    "url": "https://medium.com/feed/daangn",
    "items": [
      {
        "creator": "당근",
        "title": "지금의 방식이 최선일까? AI로 임팩트를 바꾸는 당근 운영실",
        "link": "https://medium.com/daangn/%EC%A7%80%EA%B8%88%EC%9D%98-%EB%B0%A9%EC%8B%9D%EC%9D%B4-%EC%B5%9C%EC%84%A0%EC%9D%BC%EA%B9%8C-ai%EB%A1%9C-%EC%9E%84%ED%8C%A9%ED%8A%B8%EB%A5%BC-%EB%B0%94%EA%BE%B8%EB%8A%94-%EB%8B%B9%EA%B7%BC-%EC%9A%B4%EC%98%81%EC%8B%A4-289e6c1ba987?source=rss----4505f82a2dbd---4",
        "pubDate": "Tue, 22 Apr 2025 07:01:01 GMT",
        "content:encoded": "<h3>지금의 방식이 최선일까? AI로 임팩트를 바꾸는 당근 운영실 — 당근 AI Show &amp; Tell #3</h3><blockquote>당근은 매주 ‘AI Show &amp; Tell’을 통해 각 팀의 AI 실험을 전사적으로 공유해요. AI를 업무에 어떻게 적용하고 있는지, 그 과정에서 어떤 시행착오와 인사이트가 있었는지를 가감 없이 나누죠. 당근은 완벽한 정답을 찾기보다 먼저 과감하게 실행하며, AI 전환에 빠르게 몰입하고 있어요. AI로 만드는 생생한 도전의 순간들, 지금 만나보세요.</blockquote><blockquote>✍️ 이 콘텐츠는 생성형 AI를 활용해 제작한 콘텐츠입니다.</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Ql_7q-QpGHVY1Urg7T9tlg.png\" /><figcaption>서비스 운영실 팀 내부 세션 ‘Nextstep for Service Operation’ 발표 자료</figcaption></figure><p>당근 운영실은 최근 AI를 활용해 실행과 학습 속도를 높일 수 있도록 조직 구조와 일하는 방식을 재설계했어요. 그 구체적인 변화는 🔗‘<a href=\"https://medium.com/daangn/%EB%AA%A8%EB%91%90%EA%B0%80-ai-%EB%A1%9C%EC%BC%93%EC%97%90-%EC%98%AC%EB%9D%BC%ED%83%80%EB%8F%84%EB%A1%9D-%EB%8B%B9%EA%B7%BC-%EC%9A%B4%EC%98%81%EC%8B%A4%EC%9D%B4-ai%EB%A1%9C-%EC%9D%BC%ED%95%98%EB%8A%94-%EB%B2%95-b8aaa6713cea\"><strong>모두가 AI 로켓에 올라타도록, 당근 운영실이 AI로 일하는 법</strong></a>’에서 소개해 드렸는데요. 이번에는 ‘당근 AI Show &amp; Tell’ 세션에서 발표된 내용을 바탕으로, 그 전환이 어떤 구체적인 결과물로 이어졌는지 전해드리려 해요.</p><p><strong>이번에 소개할 세 가지 프로젝트는 기존의 문제 해결 방식을 AI를 통해 새롭게 바라본 시도들이에요.</strong> 지금의 방식이 정말 최선인지 근본부터 다시 점검했고, 더 효과적인 해결 방법을 새롭게 기획했죠. 이후 “AI를 활용하면 빠르게 구현할 수 있다”는 확신 아래, 과감하게 실행에 나섰어요. 수개월간 준비하던 프로젝트를 AI 기반 프로덕트로 전면 피봇한 사례부터, 반복 업무를 줄이기 위해 비개발자가 직접 AI 툴을 만들어낸 실험까지 — 그 치열한 몰입의 과정을 지금부터 하나씩 살펴볼게요.</p><h3>Project 1. 누구나 쉽게 조립하는 멀티 AI 에이전트 시스템, ‘KAMP’</h3><p>AI 전환이 본격화되던 시기, 운영개발팀은 여러 차례 논의와 얼라인을 거쳐 팀원 모두가 멀티 AI 에이전트 시스템을 염두에 두고 있다는 점을 확인했어요. 이는 서로 다른 역할의 AI들이 협업해 복잡한 문제를 효율적으로 처리하는 구조인데요. 제재 사유 설명이나 운영 정책 안내처럼 다양한 데이터를 다뤄야 하는 CS 업무에서는 AI 에이전트의 역할을 분리하는 게 응답 정확도와 처리 속도 모두에 유리했어요. 운영개발팀은 서비스별로 필요한 CS 대응 시스템을 누구나 쉽게 구현할 수 있도록, 개발 없이도 에이전트를 조합할 수 있는 플랫폼을 기획했어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UH6a8tPNDfCzqNxa210CLg.png\" /></figure><p>이렇게 탄생한 것이 운영개발팀 Backend Engineer Julius가 개발한 <strong>KAMP(Karrot Agent Management Platform)</strong>예요. KAMP는<strong> ‘프로젝트–에이전트–도구’</strong>라는 세 가지 요소로 구성돼 있어요. 프로젝트는 해결하려는 문제, 에이전트는 LLM 기반으로 역할을 수행하는 AI, 도구는 외부 정보를 조회하거나 특정 행동을 할 수 있도록 해주는 API를 의미하죠.</p><p><strong>이 세 가지를 상황에 맞게 조합하기만 하면, 복잡한 응대 시나리오도 코드 없이 손쉽게 구현할 수 있어요.</strong> 예를 들어 기본적인 사용자 질문에 응대하는 ‘고객지원 상담사’ 에이전트에게는 사용자 정보를 조회할 수 있는 도구를 연결하고, ‘운영정책 전문가’ 에이전트에는 내부 정책 검색 도구를 연결하는 식이에요. 여기에 ‘답변 검토 에이전트’를 추가해 다른 에이전트에 의해 작성된 답변이 사용자의 질문에 충분한 답변이 되는지 검토할 수도 있어요. 이렇게 에이전트는 각자 전문 분야 작업을 수행하고 서로 협업하여 복잡한 사용자의 문제를 해결해요.</p><p>사실 Julius는 한 달 전까지만 해도 룰 베이스 기반의 고객 지원 시스템을 설계 중이었고, 기획과 기본적인 시스템 구조 설계까지 마친 상태였어요. 하지만 AI 전환이 본격화되면서 그 방식이 사용자에게 가장 큰 임팩트를 줄 수 있을지 의문이 생겼고, 고민 끝에 멀티 AI 에이전트 시스템으로 방향을 전환했죠. <strong>이미 많은 설계가 진행된 상황에서 결정을 뒤집는 건 쉽지 않았지만, 오로지 사용자 경험에 집중하며 4일 만에 코어 로직과 UI를 완성했어요.</strong> Julius는 “LLM의 한계를 의심하기보다 빠르게 시도하는 것이 중요하다”는 인사이트를 남겼어요.</p><h3>Project 2. CS 데이터를 가지고 놀 수 있도록, ‘VoC Playground’</h3><p>문의, 신고, 설문, 전화 상담 등 다양한 채널에서 매일 피드백이 들어오지만, 프로덕트 팀이 이 데이터를 직접 활용하기는 어려웠어요. 각 채널별로 데이터는 서로 다른 구조의 DB에 흩어져 있었고, 결국 운영팀이 대신 쿼리를 짜주거나 수작업으로 정리해 전달하는 일이 반복됐어요. 실시간 대응이 중요한 상황에서, 분석 속도는 느려지고 데이터 활용도는 낮아졌어요. 운영개발팀 Backend Engineer Willie는 쌓여만 가는 CS 데이터를 보며, 이 문제를 AI로 해결해 볼 수 있지 않을까 고민했어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*guJx5obqZGKzpsViL59xqA.png\" /></figure><p>그 고민의 결과로 누구나 쉽게 CS 데이터를 탐색하고 분석할 수 있는 플랫폼인 <strong>VoC Playground</strong>가 탄생했어요. VoC는 Voice of Customer의 약자로, 사용자가 우리에게 보내는 모든 의견을 뜻하는데요. VoC Playground는 사용자가 보낸 의견 텍스트를 효율적으로 분석할 수 있도록 도와주는 관리 도구예요. <strong>분석하려는 VoC 유형, 정확도 임계값, 필터링 조건 등만 설정하면, AI가 그에 맞춰 데이터를 정리하죠.</strong> 예를 들어 클릭 몇 번과 짧은 프롬프트만으로 ‘의견 남기기’ CS 데이터 중 ‘기능 개선 및 제안’ 관련 데이터만 추출할 수 있어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*mQ048lW8NAZgJG68f1SA3A.png\" /></figure><p>이후 필터링된 데이터를 다양한 방식으로 분석해 볼 수 있어요. <strong>원하는 LLM 모델을 선택하고 분석 방향을 프롬프트로 입력하면, AI가 리포트를 자동으로 생성해요. </strong>예를 들어 앞서 추출한 ‘기능 개선 및 제안’ 관련 데이터를 기반으로 서비스별 개선 사항과 액션 아이템을 정리할 수 있어요. <strong>복잡한 쿼리 없이도 누구나 구조화된 인사이트를 도출할 수 있게 된 거예요.</strong> VoC Playground는 앞으로도 VoC 감정 분석, 핵심 키워드 도출, 텍스트 요약 등의 기능이 추가되며 계속 고도화될 예정이에요.</p><p><strong>VoC Playground는 운영개발팀이 반년 넘게 준비하던 VoC 파이프라인을 과감히 접고, 단 일주일 만에 피봇해 만든 결과물이에요.</strong> 처음엔 완성도 높은 분석 기능 구현을 목표로 했지만, AI 전환의 흐름 속에서 빠르고 손쉽게 써볼 수 있는 도구가 더 시급하다는 판단을 내렸죠. 클러스터링, 키워드 추출 등 기존 설계를 폐기하고, 프롬프트 기반 분석 구조로 방향을 바꿨어요. 완성도보다 속도가 중요한 순간, 치열하게 결정하고 빠르게 만들어낸 전환이었어요.</p><h3>Project 3. 수작업 6시간을 3분으로, ‘앱 리뷰 자동 라벨링 툴’</h3><p>운영팀의 Operations Manager인 Sofia는 앱 리뷰 데이터를 직접 관리하며, 매월 리포트 형태로 구성원들에게 공유해 왔어요. 이때 필요한 시각화 자료를 만들기 위해, 매일 수기 라벨링 작업을 병행하고 있었는데요. 앱 리뷰는 텍스트가 정돈돼 있지 않아 단순 키워드 매칭이 어려웠어요. 하나하나 맥락을 판단해 라벨을 붙여야만 했죠. 이 반복 작업은 매월 6시간 이상 소요됐는데, 이 업무를 하는 동안 다른 기획 업무를 병행하기에도 어려웠어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*23KjOr-vUP7VAjz_2BH9kA.png\" /></figure><p>문제를 해결하기 위해 Sofia는 Cursor를 활용해 <strong>자동 라벨링 툴</strong>을 완성했어요. 라벨링된 예시 데이터와 라벨링할 대상 데이터를 임베딩하면, 예시 데이터와의 유사도 분석을 통해 앱 리뷰 데이터의 ‘관련 서비스’, ‘유형’, ‘세부 유형’을 자동으로 라벨링해요. <strong>수작업으로 6시간 걸리던 업무는 3분으로 줄었고, 검수 시간을 포함하더라도 1시간 이내로 마칠 수 있게 됐어요.</strong> AI를 실무에 깊이 적용하며, 일하는 방식을 효율적으로 바꾼 거죠.</p><p><strong>특히 놀라운 점은 개발 경험이 거의 없던 Sofia가 LLM과의 대화를 통해 기능을 고도화했다는 사실이에요. </strong>첫 결과물은 키워드 기반으로 맵핑하는 수준이었는데요. “맥락 기준으로 분류할 방법은 없을까?”라는 Sofia의 질문에 Cursor는 OpenAI API 활용을 제안했어요. 그 결과물의 완성도도 부족해서 “예시 데이터를 학습해 줄 수 있을까?”라는 추가 요청을 하게 됐고, 끝내 유사도 기반 임베딩 방식을 도입하여 분류 정확도를 크게 개선할 수 있었어요. <strong>기술력은 부족하더라도 문제를 더 나은 방식으로 해결하고자 한 집요함이 실질적인 결과로 이어진 거예요.</strong></p><p>당근 운영실의 AI 전환은 단순한 기술 도입이 아니라, 실행을 중심에 둔 치열한 전환이었어요. 팀은 문제를 더 잘 풀 수 있다면 수개월간 준비하던 계획도 과감히 접었고, 누구든 자기 자리에서 실무에 적용할 수 있는 도구를 직접 만들며 실행의 밀도를 끌어올렸죠. <strong>개발자와 비개발자 모두가 ‘어떻게든 해내겠다’는 태도로 일에 몰입했고, 그 몰입이 하나둘 실질적인 변화로 이어졌어요.</strong></p><p>이제 이 몰입은 운영실을 넘어 조직 곳곳으로 번지고 있어요. 다음 AI Show &amp; Tell에서는 다른 팀들이 AI를 일의 방식으로 어떻게 받아들이고 있는지 전해드릴게요. 더 나은 문제 해결을 위해 매일 이어지는 치열한 몰입이 조직에 어떤 변화를 만들어내고 있는지 궁금하다면, 그다음 이야기도 기대해 주세요.</p><blockquote>AI로 함께 새로운 변화를 만들어내고 싶다면? <br>👉 <a href=\"https://bit.ly/3RZWwhm\"><strong>당근 채용 공고 바로 가기</strong></a></blockquote><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=289e6c1ba987\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/%EC%A7%80%EA%B8%88%EC%9D%98-%EB%B0%A9%EC%8B%9D%EC%9D%B4-%EC%B5%9C%EC%84%A0%EC%9D%BC%EA%B9%8C-ai%EB%A1%9C-%EC%9E%84%ED%8C%A9%ED%8A%B8%EB%A5%BC-%EB%B0%94%EA%BE%B8%EB%8A%94-%EB%8B%B9%EA%B7%BC-%EC%9A%B4%EC%98%81%EC%8B%A4-289e6c1ba987\">지금의 방식이 최선일까? AI로 임팩트를 바꾸는 당근 운영실</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "지금의 방식이 최선일까? AI로 임팩트를 바꾸는 당근 운영실 — 당근 AI Show & Tell #3\n당근은 매주 ‘AI Show & Tell’을 통해 각 팀의 AI 실험을 전사적으로 공유해요. AI를 업무에 어떻게 적용하고 있는지, 그 과정에서 어떤 시행착오와 인사이트가 있었는지를 가감 없이 나누죠. 당근은 완벽한 정답을 찾기보다 먼저 과감하게 실행하며, AI 전환에 빠르게 몰입하고 있어요. AI로 만드는 생생한 도전의 순간들, 지금 만나보세요.\n✍️ 이 콘텐츠는 생성형 AI를 활용해 제작한 콘텐츠입니다.\n서비스 운영실 팀 내부 세션 ‘Nextstep for Service Operation’ 발표 자료\n당근 운영실은 최근 AI를 활용해 실행과 학습 속도를 높일 수 있도록 조직 구조와 일하는 방식을 재설계했어요. 그 구체적인 변화는 🔗‘모두가 AI 로켓에 올라타도록, 당근 운영실이 AI로 일하는 법’에서 소개해 드렸는데요. 이번에는 ‘당근 AI Show & Tell’ 세션에서 발표된 내용을 바탕으로, 그 전환이 어떤 구체적인 결과물로 이어졌는지 전해드리려 해요.\n이번에 소개할 세 가지 프로젝트는 기존의 문제 해결 방식을 AI를 통해 새롭게 바라본 시도들이에요. 지금의 방식이 정말 최선인지 근본부터 다시 점검했고, 더 효과적인 해결 방법을 새롭게 기획했죠. 이후 “AI를 활용하면 빠르게 구현할 수 있다”는 확신 아래, 과감하게 실행에 나섰어요. 수개월간 준비하던 프로젝트를 AI 기반 프로덕트로 전면 피봇한 사례부터, 반복 업무를 줄이기 위해 비개발자가 직접 AI 툴을 만들어낸 실험까지 — 그 치열한 몰입의 과정을 지금부터 하나씩 살펴볼게요.\nProject 1. 누구나 쉽게 조립하는 멀티 AI 에이전트 시스템, ‘KAMP’\nAI 전환이 본격화되던 시기, 운영개발팀은 여러 차례 논의와 얼라인을 거쳐 팀원 모두가 멀티 AI 에이전트 시스템을 염두에 두고 있다는 점을 확인했어요. 이는 서로 다른 역할의 AI들이 협업해 복잡한 문제를 효율적으로 처리하는 구조인데요. 제재 사유 설명이나 운영 정책 안내처럼 다양한 데이터를 다뤄야 하는 CS 업무에서는 AI 에이전트의 역할을 분리하는 게 응답 정확도와 처리 속도 모두에 유리했어요. 운영개발팀은 서비스별로 필요한 CS 대응 시스템을 누구나 쉽게 구현할 수 있도록, 개발 없이도 에이전트를 조합할 수 있는 플랫폼을 기획했어요.\n\n이렇게 탄생한 것이 운영개발팀 Backend Engineer Julius가 개발한 KAMP(Karrot Agent Management Platform)예요. KAMP는 ‘프로젝트–에이전트–도구’라는 세 가지 요소로 구성돼 있어요. 프로젝트는 해결하려는 문제, 에이전트는 LLM 기반으로 역할을 수행하는 AI, 도구는 외부 정보를 조회하거나 특정 행동을 할 수 있도록 해주는 API를 의미하죠.\n이 세 가지를 상황에 맞게 조합하기만 하면, 복잡한 응대 시나리오도 코드 없이 손쉽게 구현할 수 있어요. 예를 들어 기본적인 사용자 질문에 응대하는 ‘고객지원 상담사’ 에이전트에게는 사용자 정보를 조회할 수 있는 도구를 연결하고, ‘운영정책 전문가’ 에이전트에는 내부 정책 검색 도구를 연결하는 식이에요. 여기에 ‘답변 검토 에이전트’를 추가해 다른 에이전트에 의해 작성된 답변이 사용자의 질문에 충분한 답변이 되는지 검토할 수도 있어요. 이렇게 에이전트는 각자 전문 분야 작업을 수행하고 서로 협업하여 복잡한 사용자의 문제를 해결해요.\n사실 Julius는 한 달 전까지만 해도 룰 베이스 기반의 고객 지원 시스템을 설계 중이었고, 기획과 기본적인 시스템 구조 설계까지 마친 상태였어요. 하지만 AI 전환이 본격화되면서 그 방식이 사용자에게 가장 큰 임팩트를 줄 수 있을지 의문이 생겼고, 고민 끝에 멀티 AI 에이전트 시스템으로 방향을 전환했죠. 이미 많은 설계가 진행된 상황에서 결정을 뒤집는 건 쉽지 않았지만, 오로지 사용자 경험에 집중하며 4일 만에 코어 로직과 UI를 완성했어요. Julius는 “LLM의 한계를 의심하기보다 빠르게 시도하는 것이 중요하다”는 인사이트를 남겼어요.\nProject 2. CS 데이터를 가지고 놀 수 있도록, ‘VoC Playground’\n문의, 신고, 설문, 전화 상담 등 다양한 채널에서 매일 피드백이 들어오지만, 프로덕트 팀이 이 데이터를 직접 활용하기는 어려웠어요. 각 채널별로 데이터는 서로 다른 구조의 DB에 흩어져 있었고, 결국 운영팀이 대신 쿼리를 짜주거나 수작업으로 정리해 전달하는 일이 반복됐어요. 실시간 대응이 중요한 상황에서, 분석 속도는 느려지고 데이터 활용도는 낮아졌어요. 운영개발팀 Backend Engineer Willie는 쌓여만 가는 CS 데이터를 보며, 이 문제를 AI로 해결해 볼 수 있지 않을까 고민했어요.\n\n그 고민의 결과로 누구나 쉽게 CS 데이터를 탐색하고 분석할 수 있는 플랫폼인 VoC Playground가 탄생했어요. VoC는 Voice of Customer의 약자로, 사용자가 우리에게 보내는 모든 의견을 뜻하는데요. VoC Playground는 사용자가 보낸 의견 텍스트를 효율적으로 분석할 수 있도록 도와주는 관리 도구예요. 분석하려는 VoC 유형, 정확도 임계값, 필터링 조건 등만 설정하면, AI가 그에 맞춰 데이터를 정리하죠. 예를 들어 클릭 몇 번과 짧은 프롬프트만으로 ‘의견 남기기’ CS 데이터 중 ‘기능 개선 및 제안’ 관련 데이터만 추출할 수 있어요.\n\n이후 필터링된 데이터를 다양한 방식으로 분석해 볼 수 있어요. 원하는 LLM 모델을 선택하고 분석 방향을 프롬프트로 입력하면, AI가 리포트를 자동으로 생성해요. 예를 들어 앞서 추출한 ‘기능 개선 및 제안’ 관련 데이터를 기반으로 서비스별 개선 사항과 액션 아이템을 정리할 수 있어요. 복잡한 쿼리 없이도 누구나 구조화된 인사이트를 도출할 수 있게 된 거예요. VoC Playground는 앞으로도 VoC 감정 분석, 핵심 키워드 도출, 텍스트 요약 등의 기능이 추가되며 계속 고도화될 예정이에요.\nVoC Playground는 운영개발팀이 반년 넘게 준비하던 VoC 파이프라인을 과감히 접고, 단 일주일 만에 피봇해 만든 결과물이에요. 처음엔 완성도 높은 분석 기능 구현을 목표로 했지만, AI 전환의 흐름 속에서 빠르고 손쉽게 써볼 수 있는 도구가 더 시급하다는 판단을 내렸죠. 클러스터링, 키워드 추출 등 기존 설계를 폐기하고, 프롬프트 기반 분석 구조로 방향을 바꿨어요. 완성도보다 속도가 중요한 순간, 치열하게 결정하고 빠르게 만들어낸 전환이었어요.\nProject 3. 수작업 6시간을 3분으로, ‘앱 리뷰 자동 라벨링 툴’\n운영팀의 Operations Manager인 Sofia는 앱 리뷰 데이터를 직접 관리하며, 매월 리포트 형태로 구성원들에게 공유해 왔어요. 이때 필요한 시각화 자료를 만들기 위해, 매일 수기 라벨링 작업을 병행하고 있었는데요. 앱 리뷰는 텍스트가 정돈돼 있지 않아 단순 키워드 매칭이 어려웠어요. 하나하나 맥락을 판단해 라벨을 붙여야만 했죠. 이 반복 작업은 매월 6시간 이상 소요됐는데, 이 업무를 하는 동안 다른 기획 업무를 병행하기에도 어려웠어요.\n\n문제를 해결하기 위해 Sofia는 Cursor를 활용해 자동 라벨링 툴을 완성했어요. 라벨링된 예시 데이터와 라벨링할 대상 데이터를 임베딩하면, 예시 데이터와의 유사도 분석을 통해 앱 리뷰 데이터의 ‘관련 서비스’, ‘유형’, ‘세부 유형’을 자동으로 라벨링해요. 수작업으로 6시간 걸리던 업무는 3분으로 줄었고, 검수 시간을 포함하더라도 1시간 이내로 마칠 수 있게 됐어요. AI를 실무에 깊이 적용하며, 일하는 방식을 효율적으로 바꾼 거죠.\n특히 놀라운 점은 개발 경험이 거의 없던 Sofia가 LLM과의 대화를 통해 기능을 고도화했다는 사실이에요. 첫 결과물은 키워드 기반으로 맵핑하는 수준이었는데요. “맥락 기준으로 분류할 방법은 없을까?”라는 Sofia의 질문에 Cursor는 OpenAI API 활용을 제안했어요. 그 결과물의 완성도도 부족해서 “예시 데이터를 학습해 줄 수 있을까?”라는 추가 요청을 하게 됐고, 끝내 유사도 기반 임베딩 방식을 도입하여 분류 정확도를 크게 개선할 수 있었어요. 기술력은 부족하더라도 문제를 더 나은 방식으로 해결하고자 한 집요함이 실질적인 결과로 이어진 거예요.\n당근 운영실의 AI 전환은 단순한 기술 도입이 아니라, 실행을 중심에 둔 치열한 전환이었어요. 팀은 문제를 더 잘 풀 수 있다면 수개월간 준비하던 계획도 과감히 접었고, 누구든 자기 자리에서 실무에 적용할 수 있는 도구를 직접 만들며 실행의 밀도를 끌어올렸죠. 개발자와 비개발자 모두가 ‘어떻게든 해내겠다’는 태도로 일에 몰입했고, 그 몰입이 하나둘 실질적인 변화로 이어졌어요.\n이제 이 몰입은 운영실을 넘어 조직 곳곳으로 번지고 있어요. 다음 AI Show & Tell에서는 다른 팀들이 AI를 일의 방식으로 어떻게 받아들이고 있는지 전해드릴게요. 더 나은 문제 해결을 위해 매일 이어지는 치열한 몰입이 조직에 어떤 변화를 만들어내고 있는지 궁금하다면, 그다음 이야기도 기대해 주세요.\nAI로 함께 새로운 변화를 만들어내고 싶다면? \n👉 당근 채용 공고 바로 가기\n\n지금의 방식이 최선일까? AI로 임팩트를 바꾸는 당근 운영실 was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "당근",
        "guid": "https://medium.com/p/289e6c1ba987",
        "categories": [
          "ai-agent",
          "ai",
          "ai-tools",
          "automation"
        ],
        "isoDate": "2025-04-22T07:01:01.000Z"
      },
      {
        "creator": "Elon park",
        "title": "Cursor와 TDD로 만드는 Swift Macro",
        "link": "https://medium.com/daangn/cursor%EC%99%80-tdd%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-swift-macro-0e4a245caee2?source=rss----4505f82a2dbd---4",
        "pubDate": "Thu, 17 Apr 2025 06:13:12 GMT",
        "content:encoded": "<p>안녕하세요. 모바일실 iOS팀에서 iOS Engineer로 일하고 있는 Elon이에요.</p><p>제가 속한 모바일실은 당근에 전사적으로 필요한 기능을 개발해요. CI/CD, 애널리틱스, 실험 플랫폼, 딥링크 시스템 등을 직접 개발 및 관리하며, 앱 개발에 필요한 플랫폼 엔지니어링을 담당하고 있어요. 이러한 플랫폼 엔지니어링에는 iOS 엔지니어분들의 개발 생산성을 높이기 위한 Swift Macro를 개발하는 것도 포함되는데요.</p><p>이 글에서는 Curosr와 함께 TDD를 통해 Swift Macro를 구현해 보면서, 실제 프로덕션에 적용할 수 있는 신뢰도 높은 코드를 작성하는 방법에 대해 이야기하려고 해요.</p><h3>TDD에 들어가기에 앞서</h3><p>당근 앱의 토대를 쌓아 올리셨던 iOS 엔지니어분들은 모두 당근 초기부터 TDD(Test Driven Development)를 진행했어요. 그래서 단순 View를 제외하면 현재까지도 iOS 당근 앱에선 테스트 코드가 없는 곳을 찾아보기 어렵죠. 기존 개발 환경이 이러하다 보니 iOS 챕터에 합류한 엔지니어분들도 모두 테스트 코드를 작성하는 걸 당연하게 생각해요. 테스트 코드가 없으면 Pull Reqeust를 올리지 않을 정도예요. 전 당근에 입사하기 전까지는 iOS 앱 개발에서는 테스트 코드를 작성해 본 경험이 없었는데요. 그랬던 저도 지금은 테스트 코드를 수월하게 작성해요. Swift Macro와 같이 처음 접하는 기술을 도입할 때도 자연스럽게 TDD로 시작해보고 있죠.</p><p>Swift Macro는 Swift로 작성된 코드를 SwiftSyntax로 파싱한 후, Swift Syntax Tree에서 원하는 코드를 탐색해 가져와 사용하는 방식이에요. 그래서 매크로를 만들기 위해서는 먼저 원하는 형태의 매크로 인터페이스와 매크로 적용 후 생성될 코드 형태를 미리 설계해야 하는데요. 테스트 작성 시 일반적으로 사용하는 패턴인 <em>Given-When-Then</em> 패턴에서 매크로 인터페이스는 <em>Given,</em> 매크로가 적용되어 생성된 코드는 <em>Then</em>에 해당돼요. 따라서 자연스럽게 테스트코드를 먼저 작성하고 구현을 개발하는 TDD 방식에 적합하다고 볼 수 있어요.</p><p>TDD는 아래와 같은 세 단계를 하나의 사이클로 반복하면서 기능을 완성해 나가요. Swift Macro의 경우, 일반적으로 iOS 앱 개발에서 접할 일이 거의 없는 SwiftSyntax API를 사용해야 해요. 그래서 SwiftSyntax 레퍼런스 문서와 Swift AST Explorer 사이트를 오가며 필요한 Syntax를 찾는데 많은 시간을 소비하게 되는데, 이 과정을 Cursor와 함께 한다면 많은 시간을 절약할 수 있어요.</p><ul><li>🔴 Red: 원하는 기능의 테스트 코드를 작성하고 테스트를 실행하여 실패하는 것을 확인해요.</li><li>🟢 Green: 테스트를 통과할 수 있도록 최대한 빠르게 동작할 수 있는 코드를 구현해요.</li><li>🟡 Refactor: 빠르게 작성한 코드에서 중복된 코드 등을 제거하고 유지보수하기 쉽도록 가독성 좋게 리팩토링해요.</li></ul><p>이번 글에서는 예시로 Swift에서 JSON 파싱을 위해 Codable의 CodingKeys 를 자동으로 추가해 주는 Swift 매크로를 만들어 볼게요. 코드 작성은 Cursor에서 진행하고, 컴파일과 테스트 코드 실행은 Xcode를 사용해요.</p><p>💡 아래 예시는 Cursor를 사용하여 TDD를 하는 것을 목적으로 하기 때문에 Swift Macro 패키지를 만들기 위한 모든 내용을 다루지 않아요.</p><ul><li>전체 코드들은 <a href=\"https://github.com/ElonPark/Make-SwiftMacro-using-Cousor-Example\">예제 레포지토리</a>에서 보실 수 있어요.</li></ul><h3>🔴 Red</h3><ol><li>먼저 매크로의 인터페이스를 설계하여 사용될 예시 코드를 정의해요.</li></ol><pre>@CustomCodable<br>struct Person {<br>  let name: String<br>  @CodableKey(&quot;user_age&quot;) let age: Int<br>}</pre><p>2. 실제 매크로가 적용되었을 때 추가될 코드의 모습을 정의해요.</p><pre>struct Person {<br>  let name: String<br>  let age: Int<br><br>  enum CodingKeys: String, CodingKey {<br>    case name<br>    case age = &quot;user_age&quot;<br>  }<br>}</pre><p>3. 해당 코드들을 매크로 패키지에 테스트코드로 정의해요.</p><pre>func testExpansionWithCodableKeyAddsCustomCodingKeys() {<br>  assertMacroExpansion(<br>    &quot;&quot;&quot;<br>    @CustomCodable<br>    struct Person {<br>      let name: String<br>      @CodableKey(&quot;user_age&quot;) let age: Int<br>    }<br>    &quot;&quot;&quot;,<br>    expandedSource: &quot;&quot;&quot;<br>      struct Person {<br>        let name: String<br>        @CodableKey(&quot;user_age&quot;) let age: Int<br><br>        enum CodingKeys: String, CodingKey {<br>          case name<br>          case age = &quot;user_age&quot;<br>        }<br>      }<br>      &quot;&quot;&quot;,<br>    macros: macros,<br>    indentationWidth: .spaces(2)<br>  )<br>}</pre><p>4. 테스트를 실행하여 테스트에 통과하지 못하고 실패하는 것을 확인해요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Je28RFdhR2h61aOX2-Ae3g.png\" /></figure><h3>🟢 Green</h3><p>테스트에 실패한 것을 확인했으니 동작하는 코드를 구현할 차례예요.</p><p>1. 작성한 테스트 코드를 포함한 프롬프트를 Cursor Composer를 통해 LLM에게 전달하여 실제 구현 코드를 생성해요.</p><blockquote>Tip: SwiftSyntax 버전에 따라 사용할 수 있는 API가 달라요. 따라서 프롬프트 Swift 버전을 명시하여 Swift 버전에 맞는 SwiftSyntax 코드를 생성할 수 있도록 해요.</blockquote><pre>아래와 같은 테스트 코드를 통과하는 Swift Macro를 작성해 줘<br>Swift 버전은 5.10을 사용하고 swift-syntax에 맞게 구현하여야 해<br>Tuple이 필요하다면 struct 또는 enum을 새로 정의하여 사용해 줘<br><br>```swift<br>/* 작성한 테스트 코드 */<br>```</pre><p>2. 생성된 코드를 리뷰하고 문제가 있는 부분을 수정 요청해요. 코드를 커밋해도 될 만큼 코드가 개선되었다고 판단되면, 해당 코드들을 수락하여 패키지에 반영해요.</p><p>3. Xcode에서 패키지를 열고 테스트를 실행해요. LLM이 생성한 코드가 한 번에 테스트를 통과하면 좋겠지만, 대부분은 컴파일 단계에서 실패하는 코드가 생성돼요.</p><ul><li>여기서는 컴파일러 경고와 에러가 하나씩 발생했네요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*71T5a3VQtOb5AXlkBiH_KQ.png\" /></figure><ul><li>컴파일러 경고 메시지는 Fix 버튼을 눌러서 간단하게 수정 가능하기 때문에 직접 수정해요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*7-Rse83urN4pswD5qqSiGQ.jpeg\" /></figure><p>4. 컴파일러 에러를 수정할 차례예요. 테스트가 통과할 수 있도록 에러를 수정해 달라고 요청해볼게요.</p><pre>다음과 같은 에러와 경고가 발생하였어 테스트가 통과할 수 있게 수정해 줘<br>- 에러 메시지: `CustomCodableMacros/CustomCodableMacro.swift:39:15 Initializer for conditional binding must have Optional type, not &#39;AttributeListSyntax&#39;`</pre><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*CRP8pY6Tetc5EeOyNwUesw.jpeg\" /><figcaption>Cursor에서 실행한 결과</figcaption></figure><p>5. 다시 Xcode로 돌아와서 테스트 코드를 실행해 봅니다. 이번에는 다행히 컴파일에 성공할 수 있도록 코드를 수정해 주었네요. 하지만 아쉽게도 아직 테스트는 통과하지 못했어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3H2fr4WKNF7wLsKdYmmR9g.jpeg\" /></figure><p>6. 다시 한번 에러 메시지를 전달하여 수정을 요청하여 볼게요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*O0RuJRA_thBWyx5ok46KrA.jpeg\" /></figure><p>7. 수정된 코드를 리뷰하여 문제가 있다면 다시 수정 요청하기를 반복해요. 수정된 코드들에 문제가 없다고 판단되면 적용하고, 다시 Xcode로 돌아와 테스트를 실행해 봅니다. 저는 이번에도 테스트가 실패했는데요.</p><p>오류 메시지를 확인해 보니 생성된 코드와 테스트에서 기대하는 코드의 인덴트가 다르기 때문에 테스트에 통과하지 못했네요.</p><blockquote>Tip: Swift Macro는 매크로가 생성한 코드와 테스트의 결괏값이 정확히 일치하는 경우에만 성공하기 때문에, 문법 상에 문제가 없는 경우에도 테스트에 실패할 수 있어요.</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*aWHkHSnnBWG3DH9wwjZvHA.jpeg\" /></figure><p>8. 단순히 인덴트만 수정하면 되기 때문에 이번에는 직접 수정해요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/896/1*0uqU-NqZ3hIXBG2s49AJBw.jpeg\" /></figure><p>9. 다시 테스트를 실행시켜 테스트에 통과하는 것을 확인해요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*JxBPjJ8NFEBKix0OciNFaQ.jpeg\" /></figure><h3>🟡 Refactor</h3><p>테스트에 통과하는 것을 확인했으니 이제 리팩토링을 진행할 차례예요.</p><blockquote>Tip: 리팩토링 요청 시에는 원하는 코드 스타일이나 메소드 추출 기법 등 리팩토링 방법들을 프롬프트에 구체적으로 명시하면 더욱 좋은 결과물을 얻을 수 있어요.</blockquote><ol><li>리팩토링 또한 LLM에게 요청하여 진행해 봅니다 😉</li></ol><pre>이제 @CustomCodableMacro.swift를 가독성 좋고 이해기 쉬운 단위로 메소드로 추출하여<br>리팩토링해줘 필요하다면 파일을 여러 개로 분리해도 괜찮아 하지만 기존 테스트는 통과할 수 있도록<br>구현에는 문제가 없어야 해</pre><ul><li>Green 단계에서 진행한 것과 동일하게 수정된 코드를 리뷰해 보고 문제가 없다면 적용해요. 문제가 있다면 해당 내용을 지적하여 다시 리팩토링을 요청해요.</li></ul><p>2. 이제 리팩토링된 코드가 문제가 없는지 다시 한번 테스트를 실행해 봅니다.</p><ul><li>리팩토링 과정에서 이전과 동일하게 인덴트가 스페이스 4칸으로 변경되어 테스트가 실패했네요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*MrtNB4tr8N6jDB30YIWSoA.jpeg\" /></figure><p>3. 이번에도 단순 인덴트 차이가 원인이기 때문에 직접 수정해요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*13m1ECHJEo2uG9EZx8HDzA.jpeg\" /></figure><p>4. 다시 테스트를 실행하여 테스트가 통과하는 것을 확인해요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3rYyaWL7IfZz-kXArvBG-w.jpeg\" /></figure><p>5. 필요에 따라 다시 리팩토링을 진행하거나 작업을 마무리해요.</p><blockquote>Tip: LLM은 Context 크기에 제한이 있기 때문에 한 번에 여러 작업을 진행하기보다는 하나씩 작업을 진행하고, 많은 양의 코드를 LLM에 전달하여야 하는 큰 작업이 있다면 여러 개의 작은 단위로 쪼개서 작업하는 것이 좋아요.</blockquote><h3>TDD에 LLM을 활용한다면?</h3><p>이것으로 TDD의 3가지 스텝을 차례대로 진행해 보면서 TDD의 한 사이클을 돌아보았는데요. 이 과정에서 LLM을 사용하여 TDD를 진행했을 때의 두 가지 장점을 찾을 수 있었어요.</p><p>첫 번째 장점은 많은 시간을 절약할 수 있다는 점이에요. Swift Macro를 만들기 위해서는 Green 단계에서 Swift Syntax Tree를 탐색하고 필요한 Syntax를 가져오는 데 시간을 소모해야 하는데요. 이 작업을 LLM이 대신 수행하므로 많은 시간을 절약할 수 있었어요.</p><p>두 번째 장점은 코드의 문제점을 빠르게 파악하고 수정할 수 있다는 점이에요. 테스트를 먼저 작성한 후, 테스트를 통해 LLM이 생성한 코드를 검증하기 때문인데요. 테스트가 통과한 이후 리팩토링을 진행할 때에도 테스트를 통해 문제를 감지하고 바르게 수정할 수 있어요.</p><p>다만, 주의점은 LLM을 활용해 TDD를 하더라도, LLM이 생성한 코드를 리뷰하고 오류를 수정하는 것은 엔지니어의 역할이에요. 따라서 SwiftSyntax와 같이 구현에 사용되는 기술에 대한 지식을 반드시 갖추고 진행하여야 해요.</p><h3>나가며</h3><p>ChatGPT 등장 이후 LLM 기반의 생성형 AI가 빠르게 발전해 나가면서 세상을 바꾸고 있는데요. 당근에서는 LLM을 활용하여 사용자 경험이나 동료의 생산성을 높이는 도구를 함께 만들어 갈 iOS 엔지니어를 찾고 있어요. 저희의 여정에 함께하고 싶으시다면 아래 공고를 통해 지원하실 수 있어요! 😃</p><p><a href=\"https://team.daangn.com/jobs/5282170003/\">Software Engineer, iOS | 당근 팀 채용</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=0e4a245caee2\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/cursor%EC%99%80-tdd%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-swift-macro-0e4a245caee2\">Cursor와 TDD로 만드는 Swift Macro</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "안녕하세요. 모바일실 iOS팀에서 iOS Engineer로 일하고 있는 Elon이에요.\n제가 속한 모바일실은 당근에 전사적으로 필요한 기능을 개발해요. CI/CD, 애널리틱스, 실험 플랫폼, 딥링크 시스템 등을 직접 개발 및 관리하며, 앱 개발에 필요한 플랫폼 엔지니어링을 담당하고 있어요. 이러한 플랫폼 엔지니어링에는 iOS 엔지니어분들의 개발 생산성을 높이기 위한 Swift Macro를 개발하는 것도 포함되는데요.\n이 글에서는 Curosr와 함께 TDD를 통해 Swift Macro를 구현해 보면서, 실제 프로덕션에 적용할 수 있는 신뢰도 높은 코드를 작성하는 방법에 대해 이야기하려고 해요.\nTDD에 들어가기에 앞서\n당근 앱의 토대를 쌓아 올리셨던 iOS 엔지니어분들은 모두 당근 초기부터 TDD(Test Driven Development)를 진행했어요. 그래서 단순 View를 제외하면 현재까지도 iOS 당근 앱에선 테스트 코드가 없는 곳을 찾아보기 어렵죠. 기존 개발 환경이 이러하다 보니 iOS 챕터에 합류한 엔지니어분들도 모두 테스트 코드를 작성하는 걸 당연하게 생각해요. 테스트 코드가 없으면 Pull Reqeust를 올리지 않을 정도예요. 전 당근에 입사하기 전까지는 iOS 앱 개발에서는 테스트 코드를 작성해 본 경험이 없었는데요. 그랬던 저도 지금은 테스트 코드를 수월하게 작성해요. Swift Macro와 같이 처음 접하는 기술을 도입할 때도 자연스럽게 TDD로 시작해보고 있죠.\nSwift Macro는 Swift로 작성된 코드를 SwiftSyntax로 파싱한 후, Swift Syntax Tree에서 원하는 코드를 탐색해 가져와 사용하는 방식이에요. 그래서 매크로를 만들기 위해서는 먼저 원하는 형태의 매크로 인터페이스와 매크로 적용 후 생성될 코드 형태를 미리 설계해야 하는데요. 테스트 작성 시 일반적으로 사용하는 패턴인 Given-When-Then 패턴에서 매크로 인터페이스는 Given, 매크로가 적용되어 생성된 코드는 Then에 해당돼요. 따라서 자연스럽게 테스트코드를 먼저 작성하고 구현을 개발하는 TDD 방식에 적합하다고 볼 수 있어요.\nTDD는 아래와 같은 세 단계를 하나의 사이클로 반복하면서 기능을 완성해 나가요. Swift Macro의 경우, 일반적으로 iOS 앱 개발에서 접할 일이 거의 없는 SwiftSyntax API를 사용해야 해요. 그래서 SwiftSyntax 레퍼런스 문서와 Swift AST Explorer 사이트를 오가며 필요한 Syntax를 찾는데 많은 시간을 소비하게 되는데, 이 과정을 Cursor와 함께 한다면 많은 시간을 절약할 수 있어요.\n\n🔴 Red: 원하는 기능의 테스트 코드를 작성하고 테스트를 실행하여 실패하는 것을 확인해요.\n🟢 Green: 테스트를 통과할 수 있도록 최대한 빠르게 동작할 수 있는 코드를 구현해요.\n🟡 Refactor: 빠르게 작성한 코드에서 중복된 코드 등을 제거하고 유지보수하기 쉽도록 가독성 좋게 리팩토링해요.\n\n이번 글에서는 예시로 Swift에서 JSON 파싱을 위해 Codable의 CodingKeys 를 자동으로 추가해 주는 Swift 매크로를 만들어 볼게요. 코드 작성은 Cursor에서 진행하고, 컴파일과 테스트 코드 실행은 Xcode를 사용해요.\n💡 아래 예시는 Cursor를 사용하여 TDD를 하는 것을 목적으로 하기 때문에 Swift Macro 패키지를 만들기 위한 모든 내용을 다루지 않아요.\n\n전체 코드들은 예제 레포지토리에서 보실 수 있어요.\n\n🔴 Red\n\n먼저 매크로의 인터페이스를 설계하여 사용될 예시 코드를 정의해요.\n\n@CustomCodable\nstruct Person {\n  let name: String\n  @CodableKey(\"user_age\") let age: Int\n}\n2. 실제 매크로가 적용되었을 때 추가될 코드의 모습을 정의해요.\nstruct Person {\n  let name: String\n  let age: Int\n  enum CodingKeys: String, CodingKey {\n    case name\n    case age = \"user_age\"\n  }\n}\n3. 해당 코드들을 매크로 패키지에 테스트코드로 정의해요.\nfunc testExpansionWithCodableKeyAddsCustomCodingKeys() {\n  assertMacroExpansion(\n    \"\"\"\n    @CustomCodable\n    struct Person {\n      let name: String\n      @CodableKey(\"user_age\") let age: Int\n    }\n    \"\"\",\n    expandedSource: \"\"\"\n      struct Person {\n        let name: String\n        @CodableKey(\"user_age\") let age: Int\n        enum CodingKeys: String, CodingKey {\n          case name\n          case age = \"user_age\"\n        }\n      }\n      \"\"\",\n    macros: macros,\n    indentationWidth: .spaces(2)\n  )\n}\n4. 테스트를 실행하여 테스트에 통과하지 못하고 실패하는 것을 확인해요.\n\n🟢 Green\n테스트에 실패한 것을 확인했으니 동작하는 코드를 구현할 차례예요.\n1. 작성한 테스트 코드를 포함한 프롬프트를 Cursor Composer를 통해 LLM에게 전달하여 실제 구현 코드를 생성해요.\nTip: SwiftSyntax 버전에 따라 사용할 수 있는 API가 달라요. 따라서 프롬프트 Swift 버전을 명시하여 Swift 버전에 맞는 SwiftSyntax 코드를 생성할 수 있도록 해요.\n아래와 같은 테스트 코드를 통과하는 Swift Macro를 작성해 줘\nSwift 버전은 5.10을 사용하고 swift-syntax에 맞게 구현하여야 해\nTuple이 필요하다면 struct 또는 enum을 새로 정의하여 사용해 줘\n```swift\n/* 작성한 테스트 코드 */\n```\n2. 생성된 코드를 리뷰하고 문제가 있는 부분을 수정 요청해요. 코드를 커밋해도 될 만큼 코드가 개선되었다고 판단되면, 해당 코드들을 수락하여 패키지에 반영해요.\n3. Xcode에서 패키지를 열고 테스트를 실행해요. LLM이 생성한 코드가 한 번에 테스트를 통과하면 좋겠지만, 대부분은 컴파일 단계에서 실패하는 코드가 생성돼요.\n\n여기서는 컴파일러 경고와 에러가 하나씩 발생했네요.\n\n컴파일러 경고 메시지는 Fix 버튼을 눌러서 간단하게 수정 가능하기 때문에 직접 수정해요.\n\n4. 컴파일러 에러를 수정할 차례예요. 테스트가 통과할 수 있도록 에러를 수정해 달라고 요청해볼게요.\n다음과 같은 에러와 경고가 발생하였어 테스트가 통과할 수 있게 수정해 줘\n- 에러 메시지: `CustomCodableMacros/CustomCodableMacro.swift:39:15 Initializer for conditional binding must have Optional type, not 'AttributeListSyntax'`\nCursor에서 실행한 결과\n5. 다시 Xcode로 돌아와서 테스트 코드를 실행해 봅니다. 이번에는 다행히 컴파일에 성공할 수 있도록 코드를 수정해 주었네요. 하지만 아쉽게도 아직 테스트는 통과하지 못했어요.\n\n6. 다시 한번 에러 메시지를 전달하여 수정을 요청하여 볼게요.\n\n7. 수정된 코드를 리뷰하여 문제가 있다면 다시 수정 요청하기를 반복해요. 수정된 코드들에 문제가 없다고 판단되면 적용하고, 다시 Xcode로 돌아와 테스트를 실행해 봅니다. 저는 이번에도 테스트가 실패했는데요.\n오류 메시지를 확인해 보니 생성된 코드와 테스트에서 기대하는 코드의 인덴트가 다르기 때문에 테스트에 통과하지 못했네요.\nTip: Swift Macro는 매크로가 생성한 코드와 테스트의 결괏값이 정확히 일치하는 경우에만 성공하기 때문에, 문법 상에 문제가 없는 경우에도 테스트에 실패할 수 있어요.\n\n8. 단순히 인덴트만 수정하면 되기 때문에 이번에는 직접 수정해요.\n\n9. 다시 테스트를 실행시켜 테스트에 통과하는 것을 확인해요.\n\n🟡 Refactor\n테스트에 통과하는 것을 확인했으니 이제 리팩토링을 진행할 차례예요.\nTip: 리팩토링 요청 시에는 원하는 코드 스타일이나 메소드 추출 기법 등 리팩토링 방법들을 프롬프트에 구체적으로 명시하면 더욱 좋은 결과물을 얻을 수 있어요.\n\n리팩토링 또한 LLM에게 요청하여 진행해 봅니다 😉\n\n이제 @CustomCodableMacro.swift를 가독성 좋고 이해기 쉬운 단위로 메소드로 추출하여\n리팩토링해줘 필요하다면 파일을 여러 개로 분리해도 괜찮아 하지만 기존 테스트는 통과할 수 있도록\n구현에는 문제가 없어야 해\n\nGreen 단계에서 진행한 것과 동일하게 수정된 코드를 리뷰해 보고 문제가 없다면 적용해요. 문제가 있다면 해당 내용을 지적하여 다시 리팩토링을 요청해요.\n\n2. 이제 리팩토링된 코드가 문제가 없는지 다시 한번 테스트를 실행해 봅니다.\n\n리팩토링 과정에서 이전과 동일하게 인덴트가 스페이스 4칸으로 변경되어 테스트가 실패했네요.\n\n3. 이번에도 단순 인덴트 차이가 원인이기 때문에 직접 수정해요.\n\n4. 다시 테스트를 실행하여 테스트가 통과하는 것을 확인해요.\n\n5. 필요에 따라 다시 리팩토링을 진행하거나 작업을 마무리해요.\nTip: LLM은 Context 크기에 제한이 있기 때문에 한 번에 여러 작업을 진행하기보다는 하나씩 작업을 진행하고, 많은 양의 코드를 LLM에 전달하여야 하는 큰 작업이 있다면 여러 개의 작은 단위로 쪼개서 작업하는 것이 좋아요.\nTDD에 LLM을 활용한다면?\n이것으로 TDD의 3가지 스텝을 차례대로 진행해 보면서 TDD의 한 사이클을 돌아보았는데요. 이 과정에서 LLM을 사용하여 TDD를 진행했을 때의 두 가지 장점을 찾을 수 있었어요.\n첫 번째 장점은 많은 시간을 절약할 수 있다는 점이에요. Swift Macro를 만들기 위해서는 Green 단계에서 Swift Syntax Tree를 탐색하고 필요한 Syntax를 가져오는 데 시간을 소모해야 하는데요. 이 작업을 LLM이 대신 수행하므로 많은 시간을 절약할 수 있었어요.\n두 번째 장점은 코드의 문제점을 빠르게 파악하고 수정할 수 있다는 점이에요. 테스트를 먼저 작성한 후, 테스트를 통해 LLM이 생성한 코드를 검증하기 때문인데요. 테스트가 통과한 이후 리팩토링을 진행할 때에도 테스트를 통해 문제를 감지하고 바르게 수정할 수 있어요.\n다만, 주의점은 LLM을 활용해 TDD를 하더라도, LLM이 생성한 코드를 리뷰하고 오류를 수정하는 것은 엔지니어의 역할이에요. 따라서 SwiftSyntax와 같이 구현에 사용되는 기술에 대한 지식을 반드시 갖추고 진행하여야 해요.\n나가며\nChatGPT 등장 이후 LLM 기반의 생성형 AI가 빠르게 발전해 나가면서 세상을 바꾸고 있는데요. 당근에서는 LLM을 활용하여 사용자 경험이나 동료의 생산성을 높이는 도구를 함께 만들어 갈 iOS 엔지니어를 찾고 있어요. 저희의 여정에 함께하고 싶으시다면 아래 공고를 통해 지원하실 수 있어요! 😃\nSoftware Engineer, iOS | 당근 팀 채용\n\nCursor와 TDD로 만드는 Swift Macro was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "Elon park",
        "guid": "https://medium.com/p/0e4a245caee2",
        "categories": [
          "tdd",
          "ios",
          "llm",
          "programming"
        ],
        "isoDate": "2025-04-17T06:13:12.000Z"
      },
      {
        "creator": "Hy Lee (sang un)",
        "title": "검색 Indexing 파이프라인 개선기",
        "link": "https://medium.com/daangn/%EA%B2%80%EC%83%89-indexing-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EC%84%A0%EA%B8%B0-c01c64292831?source=rss----4505f82a2dbd---4",
        "pubDate": "Tue, 15 Apr 2025 06:14:54 GMT",
        "content:encoded": "<p>안녕하세요! 검색플랫폼팀의 Backend Engineer 하이(Hy)에요.</p><p>당근에는 중고거래, 동네생활, 동네업체, 채팅 등 다양한 서비스가 있는데요. 검색플랫폼팀은 검색 서비스를 안정적으로 지원하는 플랫폼을 만들며, 다양한 서비스의 검색을 지원하고 있어요. 이를 위해서는 가장 먼저 각 서비스들의 데이터가 필요한데요. 이번 글에서는 각 서비스의 데이터를 검색 엔진에 전달하는 색인 파이프라인을 운영하면서, 어떤 문제가 있었고 어떻게 해결했는지 이야기하려고 해요.</p><p>색인 파이프라인은 1) 실시간성을 보장하기 위한 Online 색인과 2) 사전 변경, 데이터 보정을 위해 하루에 한 번 전체 색인을 하는 Offline 색인을 해요. 이 두 가지를 진행할 때, 기존 파이프라인은 아래와 같은 문제점이 있었어요.</p><h4>생산성</h4><p>데이터를 가져오고 색인하는 로직의 패턴은 대부분 동일하지만, 서비스마다 로직이 따로 존재해서 관리 포인트가 많아져요.</p><h4>의존성</h4><p>당근의 서비스 DB에 직접적으로 붙어서 데이터를 가져오기 때문에, 각 서비스 DB에 강한 의존성을 가지게 됐어요.</p><h4>비용</h4><p>하루에 한 번 OnlineDB의 내용을 전체 Full Scan해야 하기 때문에 색인 파이프라인의 DB의 사이즈가 커야 했어요. 또한 서비스팀에서도 저희를 위한 ReplicaDB를 만들어주어야 해요.</p><h4>가시성</h4><p>어떤 필드가 어떻게 색인이 되는지, 필터링 로직 등 색인 로직이 어떻게 구성됐는지 등을 파악하려면, 늘 코드를 전부 일일이 확인해야 했어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SRARdWW1QM5Ryfk4aQ3I2w.png\" /><figcaption><strong>이전 색인 파이프라인에서 개발해야 하는 부분</strong></figcaption></figure><p><strong>위의 4가지 문제를 해결하기 위해 다음과 같은 목표를 세웠어요.</strong></p><ol><li>설정 기반의 인터페이스로 자동화하여, 누구나 기여할 수 있는 생산성이 높은 시스템을 만들어요.</li><li>외부 서비스 DB에 대한 의존성을 낮춰서, 상태가 변경되어도 안전한 색인 파이프라인을 만들어요.</li><li>하루에 한 번 풀색인(Full Indexing)의 부담을 낮추고 비용을 줄여요.</li><li>이벤트가 쏟아져도 안전한 고가용성의 시스템을 만들어요.</li></ol><h4>1) 설정 기반의 인터페이스로 자동화하여, 누구나 기여할 수 있는 생산성이 높은 시스템을 만들어요.</h4><p>위의 목표를 달성하기 위해서는 동작을 명시하는 설정 Interface가 잘 정의되어야 해요. 또한 아무리 자동화가 목적이라도 안전한 시스템을 갖추기 위해선, 먼저 안전한 스키마를 설계해야 해요. 그래서 아래와 같은 원칙을 세웠어요.</p><ul><li>해당 인터페이스에 명시된 동작만 이루어져야 하며, 이외에 다른 동작을 하는 마술은 부리지 않아야 함</li><li>모든 데이터는 스키마를 가지고 안전하게 처리할 수 있도록 해야 함</li><li>모든 in/out 사이에는 비즈니스로직을 자유롭게 넣을 수 있어야 함</li><li>사용자가 몰라도 되는 core 로직은 데이터 처리 외에는 하지 않아야 함</li></ul><p>먼저 동작을 명시하는 Interface를 정의하기 위해 비교적 접근성이 쉬운 yaml을 사용하였어요. 아래는 데이터를 어떻게 가져오고, 적재하고, 관리할지를 보여주는 Datastore의 Interface 예시예요.</p><pre>version: 1<br>name: {서비스이름}_datastore<br>storage: datastore<br>sources:<br>  - table: {테이블명}_v2<br>    comment: &quot;{설명 주석}&quot;<br>    country: ### 사용되는 나라만 넣어주세요.<br>    primary_key: {primary_key_field}<br>    schema: {DB schema 경로} ### dbschema/{테이블명}.yaml로 만들어주세요 schema의 type은 MySQL 타입기준으로 만들어주시면 됩니다.<br>    scan:<br>      type: time<br>      target_field: {스키마의 변경시간 field이름} ### 데이터 비교 및 최신데이터를 구별할 필드이름을 넣어주세요 예시) updated_at<br>      ttl_interval_ms: {ttl ms}<br>      ### 예시) 온라인 디비에 적재할 TTL 시간을 넣어주세요 예시) 43200000, -1로 하면 영원히 가지고 있게 됩니다.<br>    subscribe_message:<br>      - topic: {kafka_topic} ### 인덱서에서 읽어 들일 카프카 topic을 넣어주세요 예시) event.search.region<br>        transform: {transform name}<br>        ### 해당 메시지를 처리할 transform의 이름을 넣어주세요 검색팀이 아닌 경우 직접 transform로직을 작성해 주셔도 좋고, 비워두시고 검색 플랫폼팀에게 요청을 주시면 검색 팀에서 만들어드립니다.<br>    publish_message:<br>      - topic: services.searchindexer.internal.job_state_change_v1<br>        ## bigquery cdc 로그에 적재할 토픽에 true를 넣어줍니다.<br>        cdc: true<br>    auto_indexing:<br>      - option: simple<br>        generate_policy: always<br>        partition_page_size: 100000<br>        ## 데이터 스토어 형태에서 검색엔진에 데이터를 삭제할 조건을 넣습니다.<br>        active_conditions:<br>          - destroyed_at is null<br>....        <br>    deployments: ### env prod / alpha 배포 설정을 넣어주세요. 지정된 환경변수만 배포가 되어요.<br>      - env: alpha<br>        slack_alarm_channel: &#39;#슬랙채널&#39;<br>    transform_parameter:<br>      - env: alpha<br>        pipeline:<br>          kr:<br>            configs:<br>              - name: flea_market_image_vector_v1<br>                tensorflow_serving_config: tensorflowserving/alpha/kr/flea_market_vector_v1.yaml       offline:<br>    executors:<br>      - env: alpha ### env prod / alpha<br>        back_fill: ### backfill sql 경로를 넣어주세요<br>          sql:<br>            all: backfill/regions.sql<br>        resources: ### 리소스 default는 memory: 512Mi cpu: 500m이에요.<br>          kr:<br>           limits:<br>             memory: 512Mi<br>             cpu: 500m<br>           requests:<br>             memory: 512Mi<br>             cpu: 500m</pre><p>위의 interface를 작성하고 명령어를 치면 시스템에서 코드를 생성해요. <strong>“모든 데이터는 스키마를 가져서 안전하게 처리해야 함”</strong>이라는 원칙을 보장하기 위해 “코드 생성 방식”을 선택했어요. 또한 Online 이벤트와 Offline 데이터를 똑같은 형태로 만들어야 하기 때문에, 시스템에서 Schema를 코드로 만드는 것이 가장 안전하다고 판단했어요.</p><p>아래는 위의 Interface의 Schema를 읽고 생성한 코드 예시예요.</p><pre>// Code generated by indexer/message. DO NOT EDIT.<br>// versions: v1<br>// source: message/schema/.../articles_datastore.yaml<br>// 중고거래 article MySQL 테이블 모델<br><br>package articlesdatastore<br>import (<br>   &quot;github.com/daangn/search-indexer/message/entity&quot;<br>   &quot;github.com/daangn/search-indexer/message/entity/utils&quot;<br>   &quot;time&quot;<br>)<br>var _ entity.IndexerMySQLMessage = &amp;ArticlesV2{}<br>type FleaMarket struct {<br> ID                      int64      `db:&quot;id&quot; json:&quot;id&quot; bigquery:&quot;id&quot; structs:&quot;id&quot;`<br> Title                   *string    `db:&quot;title&quot; json:&quot;title&quot; bigquery:&quot;title&quot; structs:&quot;title&quot;`<br> Content                 *string    `db:&quot;content&quot; json:&quot;content&quot; bigquery:&quot;content&quot; structs:&quot;content&quot;`<br>.....</pre><p>유연한 플랫폼을 만들려면, 엔지니어가 모든 input 데이터를 자유롭게 변환할 수 있어야 해요. 이를 위해 Interface 중간에 엔지니어가 직접 코드를 삽입할 수 있는 Transform 단계를 만들어뒀어요. 외부에서 받아온 메시지는 Transform의 로직을 거쳐 변환되고, 그 후 OnlineStorage와 상태 변경 이벤트를 통해 OfflineStorage에 적재돼요. Transform을 구현하는 구체적인 방식은 아래와 같아요.</p><pre>type DataLoaderMessageTransform interface {<br>    // GetName transform 이름 : schema yaml transform 필드에 들어갈 이름<br>    GetName() string<br><br>    // Transform 변환 로직이 들어갈 곳 return 값이 DataStore에 적재됨<br>    // kafka message를 파싱해 다시 DB에서 값을 가져오거나<br>    // message안에 데이터가 있다면 변환해서 생성된 MySQL Schema모델에 채워서 리턴해준다.<br>    MessageTransform(ctx context.Context, <br>                     parameter entity.TransformParameter,<br>                     msg *kafka.Message) (entity.IndexerMySQLMessage, error)<br><br>    // CustomClearSQL Custom 하여 지우는 로직을 넣는 SQL<br>    // custom 이 필요 없이 나 자신을 Clear 하는 것이라면 retrun &quot;&quot; 하면 된다<br>    // 릴레이션되어 1:N관계 일 때 1에 릴레이션되어 커스텀 SQL을 넣고 싶을 때 사용하면 된다.<br>    CustomClearSQL() string<br>}</pre><p>SearchEngine에 적재하는 Indexing Inteface도 이와 비슷한 형태로 만들 수 있어요. 추가적으로, 코드를 생성시키면 Airflow에 Offline 색인 파이프라인이 자동으로 생기도록 하였어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*juJHipwXCiF8xBUrBEwDpw.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*xB642YdttfLuZcGm55Ihzw.png\" /><figcaption>자동으로 생성된 Airflow Dag</figcaption></figure><h4>2) 외부 서비스 DB와 의존성을 낮춰서, 안전한 색인 파이프라인을 만들어요</h4><p>대부분 서비스의 DB는 MySQL, MongoDB 같은 OnlineDB 일 거예요. OnlineDB는 실시간으로 변할 수 있는 상태이기 때문에, 직접 외부 서비스의 OnlineDB를 바라보는 것은 장애 포인트가 될 수 있어요. 또 풀색인 시에 모든 데이터를 읽어오기 위한 비용도 크고 유지하기가 어려워요. 이를 해결하고자 저희는 Offline Storage를 사용하기로 결정하였어요.</p><p>당근은 OfflineStorage로 BigQuery를 사용하고 있고, 모든 서비스의 데이터가 BigQuery에 잘 적재되어 있는데요. 이는 서비스에서 직접적으로 사용되는 데이터이기 때문에 DB의 신뢰성과 성능, 그리고 비용을 잘 관리해야 했어요.</p><p>먼저, 위의 datastore inteface에 명시된 backfill로 가져온 데이터로 빈 데이터를 채워주었어요. 그리고 WAL(Write-Ahead Log)과 같은 형태의 상태 변경 메시지를 발행하여, 데이터를 OfflineStorage에 적재했어요. 이때 적재된 데이터를 가장 우선순위가 높은 데이터로 활용하였어요.</p><blockquote><em>“상태 변경 이벤트”는 특정 요인에서 순서, 시간 등 이 잘못될 수 있기 때문에 이벤트 메시지에는 ID만 발행해요. 그다음 CDCStreaming 애플리케이션에서 ID를 기준으로 데이터를 조회한 후, Schema에 맞춘 변환 로직을 거쳐서 OfflineStorage에 저장해요.</em></blockquote><p>프로세스는 다음과 같아요.</p><ul><li>먼저 외부 데이터를 Backfill하여 빈데이터를 채워줘요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HAdsVSlKSqUt-SusfKC5bg.png\" /></figure><ul><li>Scan 하는 필드를 기준으로 Streaming 데이터를 비교하여 더 큰 값을 우선순위로 정해요. 그 후 ID 기준의 유니크한 Row를 가지는 형태로 머지하고, Offline 색인 테이블에 Overwrite 해요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i4j0MxrKSi3R-vRfPXFtNQ.png\" /></figure><ul><li>위의 프로세스로 전체 데이터를 채워주면 Backfill시에 잘못된 데이터가 들어와도, 저희의 데이터로 overwrite하기 때문에 안전한 데이터 테이블을 만들어 색인할 수 있었어요.</li><li>마지막으로 OfflineStorage의 최신 데이터 이후의 데이터도 함께 처리해줘야 하는데요. 해당 데이터는 색인 파이프라인에서 사용하는 OnlineDB에서 가져와 실시간성까지 보장할 수 있었어요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yzjKo8UjpZ-Th9z5bENvyQ.png\" /></figure><h4>3) 하루에 한 번 풀색인의 부담을 낮추고 비용을 줄여요.</h4><p>하루에 한 번 전체 데이터를 가져와 색인하는 과정에서 <strong>“어떻게 OffineStorage에서 적은 비용으로 빠르게 데이터를 가져올 수 있을까?”</strong> 하는 고민을 가지게 됐어요. BigQuery 같은 OfflineStorage는 파일 시스템이기 때문에 특정한 범위를 가져오는 SQL을 작성하더라도 FullScan을 발생시켜요. 해당 문제를 해결하기 위해 색인 파이프라인에서 데이터를 읽기 전, 데이터를 파티셔닝하고 복제 테이블을 만드는 작업을 하였어요.</p><ul><li>Offline 색인 시작 전 data table에서 partition 룰을 통하여 partition을 나눈 임시 테이블을 생성해요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9s2xtKIZvFotROKqOGL7gg.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pg0SkpOqZZHz0yT07Xu_ZQ.png\" /><figcaption><strong>실제 airflow log</strong></figcaption></figure><ul><li>색인 파이프라인에서 각 분산된 Processor별로 할당된 파티션을 읽고, Processor 내부의 Task들이 데이터를 검색엔진에 색인해요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VvovzE1EmkHszFuAsuKHnA.png\" /></figure><p>위와 같이 작업을 하고 하니 하루에 수억 건의 데이터를 색인하는데, 1~2시간 정도 끝나는 성능을 보였어요. 게다가 1~2만 원 정도의 비용밖에 들지 않았고요.</p><p>실제로 Spark 같은 오픈소스가 이 문제를 어떻게 해결하는지 들여다보니 위에서 작업한 형태와 크게 다르지 않다는 것을 확인했어요. 이를 통해 현재 접근 방식에 대한 신뢰와 확신을 좀 더 가질 수 있었어요.</p><h4>4) 이벤트가 쏟아져도 안전한 고가용 시스템을 만들어요.</h4><p>색인 파이프라인을 오픈된 형태로 유지하려면, 무수히 많은 카프카 이벤트에도 안전한 시스템을 만들어야 해요. 실제로 내부 서비스 중 어떤 서비스는 초당 수천 건의 이벤트를 발행해요. 이러한 상황에서 비용을 최소화하고 성능을 극대화할 방법을 찾아야 했어요.</p><p>대부분의 서비스들은 초당 많아야 100건 이내의 이벤트가 발생하기 때문에, 각 이벤트를 OnlineDB에 적재해도 큰 문제가 없어요. 다만, 초당 수천 건 이상의 데이터를 밀어 넣는 서비스의 경우, 혹은 해당 파이프라인에서 embedding vector를 생성하거나 모델 inference를 하는 Latency가 긴 서비스의 경우, KafkaLag가 생기거나 DB의 부하가 급격히 증가해 다른 서비스에도 영향을 줄 수 있어요.</p><p>해당 문제를 해결하기 위해 Streaming Tumbling TimeWindow을 만들어 Streaming Batch 처리를 가능하게 하였어요. 검색엔진에 적재할 때도 동일하게 Streaming Batch 처리를 해요.</p><p>Indexer Pipeline의 TimeWindow 동작 방식은 Streaming OpenSource들을 모방하여 Local 머신마다 StateStore를 가지고 처리할 수 있도록 구현했어요.</p><pre>streams := kafka.NewStream(topic, config.KafkaConsumer).<br>\t\tWindowTime(windowTime).<br>\t\tTransform(func(ctx context.Context, msg *kafka2.Message) (interface{}, interface{}, error) {<br>\t\t\t\treturn msg.key, msg.Value, nil<br>\t\t\t}, consumeFailProcess).<br>\t\tProcess(func(ctx context.Context, window *TimeWindow) error {<br>\t\t...<br>\t\t\treturn nil<br>\t\t}, consumeFailProcess)</pre><p>아래와 같이 설정에 time window 기간을 명시하고, 아래 “flea_market_vector_v1”라는 이름으로 DataLoaderBatchStreamingTransform를 구현했어요. 이 로직을 transform에 넣어주면 TumblingWindow 형태로 데이터를 모아서 batch 처리를 할 수 있어요.</p><pre>subscribe_message:<br>      - topic: indexing.fleamarket.flea_market_article.v1<br>        transform: flea_market_vector_v1<br>        window_time_milliseconds: 2000</pre><pre>type DataLoaderBatchStreamingTransform interface {<br>    // GetName transform 이름 : schema yaml transform 필드에 들어갈 이름<br>    GetName() string<br>    // Preprocess batch transform전 단일 문서에 대해 전처리를 수행합니다.<br>    Preprocess(ctx context.Context,<br>               parameter entity.TransformParameter,<br>               msg *kafka.Message) (entity.IndexerMessage, error)<br>    // BatchTransform bulk로 변환 로직이 들어갈 곳 return 값이 DataStore에 적재됨<br>    BatchTransform(ctx context.Context,<br>                   parameter entity.TransformParameter,<br>                   data []entity.IndexerMessage) ([]entity.IndexerMySQLMessage, error)<br>}</pre><p>해당 작업을 통해 1.5core의 pod 8대 만으로도 초당 수만 건의 이벤트를 무리 없이 처리할 수 있었어요.</p><p>이외에도 최근까지 Transform을 자동으로 생성해 주는 옵션, Vector Emebdding, LLM, Model Inference, 수많은 PR 테스트와 모니터링 등 검색 서비스를 안정적으로 지원하기 위해 다양한 작업을 지속하고 있어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*0w3ElC3X2PvwGmFCjBEzDg.png\" /><figcaption>Model Inference 등 기능이 추가되고 있는 Indexer pipeline</figcaption></figure><h4>마무리</h4><p>지금까지 당근의 검색플랫폼팀에서 색인 파이프라인의 안정성과 생산성을 높이기 위해 고민하고 개선했던 과정들을 소개했어요.</p><p>서비스가 성장할수록 더 많은 데이터를 효율적으로 처리할 수 있는 구조가 필요해지고, 동시에 서비스 간 의존성을 낮추고 가시성을 높여야 하는데요. 앞으로도 저희 검색플랫폼팀은 더욱 편리하고 신뢰할 수 있는 검색 환경을 사용자와 개발자 모두에게 제공하기 위해 다양한 시도를 계속할 예정이에요. 당근의 검색 플랫폼이 어떤 모습으로 발전해 나갈지 많은 관심 부탁드리며, 함께 고민하고 성장할 멋진 동료들을 언제나 환영합니다!</p><p>긴 글 읽어주셔서 감사합니다. 😊</p><p>검색인프라 채용: <a href=\"https://about.daangn.com/jobs/5688517003/\">https://about.daangn.com/jobs/5688517003/</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c01c64292831\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/%EA%B2%80%EC%83%89-indexing-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EA%B0%9C%EC%84%A0%EA%B8%B0-c01c64292831\">검색 Indexing 파이프라인 개선기</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "안녕하세요! 검색플랫폼팀의 Backend Engineer 하이(Hy)에요.\n당근에는 중고거래, 동네생활, 동네업체, 채팅 등 다양한 서비스가 있는데요. 검색플랫폼팀은 검색 서비스를 안정적으로 지원하는 플랫폼을 만들며, 다양한 서비스의 검색을 지원하고 있어요. 이를 위해서는 가장 먼저 각 서비스들의 데이터가 필요한데요. 이번 글에서는 각 서비스의 데이터를 검색 엔진에 전달하는 색인 파이프라인을 운영하면서, 어떤 문제가 있었고 어떻게 해결했는지 이야기하려고 해요.\n색인 파이프라인은 1) 실시간성을 보장하기 위한 Online 색인과 2) 사전 변경, 데이터 보정을 위해 하루에 한 번 전체 색인을 하는 Offline 색인을 해요. 이 두 가지를 진행할 때, 기존 파이프라인은 아래와 같은 문제점이 있었어요.\n생산성\n데이터를 가져오고 색인하는 로직의 패턴은 대부분 동일하지만, 서비스마다 로직이 따로 존재해서 관리 포인트가 많아져요.\n의존성\n당근의 서비스 DB에 직접적으로 붙어서 데이터를 가져오기 때문에, 각 서비스 DB에 강한 의존성을 가지게 됐어요.\n비용\n하루에 한 번 OnlineDB의 내용을 전체 Full Scan해야 하기 때문에 색인 파이프라인의 DB의 사이즈가 커야 했어요. 또한 서비스팀에서도 저희를 위한 ReplicaDB를 만들어주어야 해요.\n가시성\n어떤 필드가 어떻게 색인이 되는지, 필터링 로직 등 색인 로직이 어떻게 구성됐는지 등을 파악하려면, 늘 코드를 전부 일일이 확인해야 했어요.\n이전 색인 파이프라인에서 개발해야 하는 부분\n위의 4가지 문제를 해결하기 위해 다음과 같은 목표를 세웠어요.\n\n설정 기반의 인터페이스로 자동화하여, 누구나 기여할 수 있는 생산성이 높은 시스템을 만들어요.\n외부 서비스 DB에 대한 의존성을 낮춰서, 상태가 변경되어도 안전한 색인 파이프라인을 만들어요.\n하루에 한 번 풀색인(Full Indexing)의 부담을 낮추고 비용을 줄여요.\n이벤트가 쏟아져도 안전한 고가용성의 시스템을 만들어요.\n\n1) 설정 기반의 인터페이스로 자동화하여, 누구나 기여할 수 있는 생산성이 높은 시스템을 만들어요.\n위의 목표를 달성하기 위해서는 동작을 명시하는 설정 Interface가 잘 정의되어야 해요. 또한 아무리 자동화가 목적이라도 안전한 시스템을 갖추기 위해선, 먼저 안전한 스키마를 설계해야 해요. 그래서 아래와 같은 원칙을 세웠어요.\n\n해당 인터페이스에 명시된 동작만 이루어져야 하며, 이외에 다른 동작을 하는 마술은 부리지 않아야 함\n모든 데이터는 스키마를 가지고 안전하게 처리할 수 있도록 해야 함\n모든 in/out 사이에는 비즈니스로직을 자유롭게 넣을 수 있어야 함\n사용자가 몰라도 되는 core 로직은 데이터 처리 외에는 하지 않아야 함\n\n먼저 동작을 명시하는 Interface를 정의하기 위해 비교적 접근성이 쉬운 yaml을 사용하였어요. 아래는 데이터를 어떻게 가져오고, 적재하고, 관리할지를 보여주는 Datastore의 Interface 예시예요.\nversion: 1\nname: {서비스이름}_datastore\nstorage: datastore\nsources:\n  - table: {테이블명}_v2\n    comment: \"{설명 주석}\"\n    country: ### 사용되는 나라만 넣어주세요.\n    primary_key: {primary_key_field}\n    schema: {DB schema 경로} ### dbschema/{테이블명}.yaml로 만들어주세요 schema의 type은 MySQL 타입기준으로 만들어주시면 됩니다.\n    scan:\n      type: time\n      target_field: {스키마의 변경시간 field이름} ### 데이터 비교 및 최신데이터를 구별할 필드이름을 넣어주세요 예시) updated_at\n      ttl_interval_ms: {ttl ms}\n      ### 예시) 온라인 디비에 적재할 TTL 시간을 넣어주세요 예시) 43200000, -1로 하면 영원히 가지고 있게 됩니다.\n    subscribe_message:\n      - topic: {kafka_topic} ### 인덱서에서 읽어 들일 카프카 topic을 넣어주세요 예시) event.search.region\n        transform: {transform name}\n        ### 해당 메시지를 처리할 transform의 이름을 넣어주세요 검색팀이 아닌 경우 직접 transform로직을 작성해 주셔도 좋고, 비워두시고 검색 플랫폼팀에게 요청을 주시면 검색 팀에서 만들어드립니다.\n    publish_message:\n      - topic: services.searchindexer.internal.job_state_change_v1\n        ## bigquery cdc 로그에 적재할 토픽에 true를 넣어줍니다.\n        cdc: true\n    auto_indexing:\n      - option: simple\n        generate_policy: always\n        partition_page_size: 100000\n        ## 데이터 스토어 형태에서 검색엔진에 데이터를 삭제할 조건을 넣습니다.\n        active_conditions:\n          - destroyed_at is null\n....        \n    deployments: ### env prod / alpha 배포 설정을 넣어주세요. 지정된 환경변수만 배포가 되어요.\n      - env: alpha\n        slack_alarm_channel: '#슬랙채널'\n    transform_parameter:\n      - env: alpha\n        pipeline:\n          kr:\n            configs:\n              - name: flea_market_image_vector_v1\n                tensorflow_serving_config: tensorflowserving/alpha/kr/flea_market_vector_v1.yaml       offline:\n    executors:\n      - env: alpha ### env prod / alpha\n        back_fill: ### backfill sql 경로를 넣어주세요\n          sql:\n            all: backfill/regions.sql\n        resources: ### 리소스 default는 memory: 512Mi cpu: 500m이에요.\n          kr:\n           limits:\n             memory: 512Mi\n             cpu: 500m\n           requests:\n             memory: 512Mi\n             cpu: 500m\n위의 interface를 작성하고 명령어를 치면 시스템에서 코드를 생성해요. “모든 데이터는 스키마를 가져서 안전하게 처리해야 함”이라는 원칙을 보장하기 위해 “코드 생성 방식”을 선택했어요. 또한 Online 이벤트와 Offline 데이터를 똑같은 형태로 만들어야 하기 때문에, 시스템에서 Schema를 코드로 만드는 것이 가장 안전하다고 판단했어요.\n아래는 위의 Interface의 Schema를 읽고 생성한 코드 예시예요.\n// Code generated by indexer/message. DO NOT EDIT.\n// versions: v1\n// source: message/schema/.../articles_datastore.yaml\n// 중고거래 article MySQL 테이블 모델\npackage articlesdatastore\nimport (\n   \"github.com/daangn/search-indexer/message/entity\"\n   \"github.com/daangn/search-indexer/message/entity/utils\"\n   \"time\"\n)var _ entity.IndexerMySQLMessage = &ArticlesV2{}\ntype FleaMarket struct {\n ID                      int64      `db:\"id\" json:\"id\" bigquery:\"id\" structs:\"id\"`\n Title                   *string    `db:\"title\" json:\"title\" bigquery:\"title\" structs:\"title\"`\n Content                 *string    `db:\"content\" json:\"content\" bigquery:\"content\" structs:\"content\"`\n.....\n유연한 플랫폼을 만들려면, 엔지니어가 모든 input 데이터를 자유롭게 변환할 수 있어야 해요. 이를 위해 Interface 중간에 엔지니어가 직접 코드를 삽입할 수 있는 Transform 단계를 만들어뒀어요. 외부에서 받아온 메시지는 Transform의 로직을 거쳐 변환되고, 그 후 OnlineStorage와 상태 변경 이벤트를 통해 OfflineStorage에 적재돼요. Transform을 구현하는 구체적인 방식은 아래와 같아요.\ntype DataLoaderMessageTransform interface {\n    // GetName transform 이름 : schema yaml transform 필드에 들어갈 이름\n    GetName() string\n    // Transform 변환 로직이 들어갈 곳 return 값이 DataStore에 적재됨\n    // kafka message를 파싱해 다시 DB에서 값을 가져오거나\n    // message안에 데이터가 있다면 변환해서 생성된 MySQL Schema모델에 채워서 리턴해준다.\n    MessageTransform(ctx context.Context, \n                     parameter entity.TransformParameter,\n                     msg *kafka.Message) (entity.IndexerMySQLMessage, error)\n    // CustomClearSQL Custom 하여 지우는 로직을 넣는 SQL\n    // custom 이 필요 없이 나 자신을 Clear 하는 것이라면 retrun \"\" 하면 된다\n    // 릴레이션되어 1:N관계 일 때 1에 릴레이션되어 커스텀 SQL을 넣고 싶을 때 사용하면 된다.\n    CustomClearSQL() string\n}\nSearchEngine에 적재하는 Indexing Inteface도 이와 비슷한 형태로 만들 수 있어요. 추가적으로, 코드를 생성시키면 Airflow에 Offline 색인 파이프라인이 자동으로 생기도록 하였어요.\n자동으로 생성된 Airflow Dag\n2) 외부 서비스 DB와 의존성을 낮춰서, 안전한 색인 파이프라인을 만들어요\n대부분 서비스의 DB는 MySQL, MongoDB 같은 OnlineDB 일 거예요. OnlineDB는 실시간으로 변할 수 있는 상태이기 때문에, 직접 외부 서비스의 OnlineDB를 바라보는 것은 장애 포인트가 될 수 있어요. 또 풀색인 시에 모든 데이터를 읽어오기 위한 비용도 크고 유지하기가 어려워요. 이를 해결하고자 저희는 Offline Storage를 사용하기로 결정하였어요.\n당근은 OfflineStorage로 BigQuery를 사용하고 있고, 모든 서비스의 데이터가 BigQuery에 잘 적재되어 있는데요. 이는 서비스에서 직접적으로 사용되는 데이터이기 때문에 DB의 신뢰성과 성능, 그리고 비용을 잘 관리해야 했어요.\n먼저, 위의 datastore inteface에 명시된 backfill로 가져온 데이터로 빈 데이터를 채워주었어요. 그리고 WAL(Write-Ahead Log)과 같은 형태의 상태 변경 메시지를 발행하여, 데이터를 OfflineStorage에 적재했어요. 이때 적재된 데이터를 가장 우선순위가 높은 데이터로 활용하였어요.\n“상태 변경 이벤트”는 특정 요인에서 순서, 시간 등 이 잘못될 수 있기 때문에 이벤트 메시지에는 ID만 발행해요. 그다음 CDCStreaming 애플리케이션에서 ID를 기준으로 데이터를 조회한 후, Schema에 맞춘 변환 로직을 거쳐서 OfflineStorage에 저장해요.\n프로세스는 다음과 같아요.\n\n먼저 외부 데이터를 Backfill하여 빈데이터를 채워줘요.\n\nScan 하는 필드를 기준으로 Streaming 데이터를 비교하여 더 큰 값을 우선순위로 정해요. 그 후 ID 기준의 유니크한 Row를 가지는 형태로 머지하고, Offline 색인 테이블에 Overwrite 해요.\n\n위의 프로세스로 전체 데이터를 채워주면 Backfill시에 잘못된 데이터가 들어와도, 저희의 데이터로 overwrite하기 때문에 안전한 데이터 테이블을 만들어 색인할 수 있었어요.\n마지막으로 OfflineStorage의 최신 데이터 이후의 데이터도 함께 처리해줘야 하는데요. 해당 데이터는 색인 파이프라인에서 사용하는 OnlineDB에서 가져와 실시간성까지 보장할 수 있었어요.\n\n3) 하루에 한 번 풀색인의 부담을 낮추고 비용을 줄여요.\n하루에 한 번 전체 데이터를 가져와 색인하는 과정에서 “어떻게 OffineStorage에서 적은 비용으로 빠르게 데이터를 가져올 수 있을까?” 하는 고민을 가지게 됐어요. BigQuery 같은 OfflineStorage는 파일 시스템이기 때문에 특정한 범위를 가져오는 SQL을 작성하더라도 FullScan을 발생시켜요. 해당 문제를 해결하기 위해 색인 파이프라인에서 데이터를 읽기 전, 데이터를 파티셔닝하고 복제 테이블을 만드는 작업을 하였어요.\n\nOffline 색인 시작 전 data table에서 partition 룰을 통하여 partition을 나눈 임시 테이블을 생성해요.\n실제 airflow log\n색인 파이프라인에서 각 분산된 Processor별로 할당된 파티션을 읽고, Processor 내부의 Task들이 데이터를 검색엔진에 색인해요.\n\n위와 같이 작업을 하고 하니 하루에 수억 건의 데이터를 색인하는데, 1~2시간 정도 끝나는 성능을 보였어요. 게다가 1~2만 원 정도의 비용밖에 들지 않았고요.\n실제로 Spark 같은 오픈소스가 이 문제를 어떻게 해결하는지 들여다보니 위에서 작업한 형태와 크게 다르지 않다는 것을 확인했어요. 이를 통해 현재 접근 방식에 대한 신뢰와 확신을 좀 더 가질 수 있었어요.\n4) 이벤트가 쏟아져도 안전한 고가용 시스템을 만들어요.\n색인 파이프라인을 오픈된 형태로 유지하려면, 무수히 많은 카프카 이벤트에도 안전한 시스템을 만들어야 해요. 실제로 내부 서비스 중 어떤 서비스는 초당 수천 건의 이벤트를 발행해요. 이러한 상황에서 비용을 최소화하고 성능을 극대화할 방법을 찾아야 했어요.\n대부분의 서비스들은 초당 많아야 100건 이내의 이벤트가 발생하기 때문에, 각 이벤트를 OnlineDB에 적재해도 큰 문제가 없어요. 다만, 초당 수천 건 이상의 데이터를 밀어 넣는 서비스의 경우, 혹은 해당 파이프라인에서 embedding vector를 생성하거나 모델 inference를 하는 Latency가 긴 서비스의 경우, KafkaLag가 생기거나 DB의 부하가 급격히 증가해 다른 서비스에도 영향을 줄 수 있어요.\n해당 문제를 해결하기 위해 Streaming Tumbling TimeWindow을 만들어 Streaming Batch 처리를 가능하게 하였어요. 검색엔진에 적재할 때도 동일하게 Streaming Batch 처리를 해요.\nIndexer Pipeline의 TimeWindow 동작 방식은 Streaming OpenSource들을 모방하여 Local 머신마다 StateStore를 가지고 처리할 수 있도록 구현했어요.\nstreams := kafka.NewStream(topic, config.KafkaConsumer).\n\t\tWindowTime(windowTime).\n\t\tTransform(func(ctx context.Context, msg *kafka2.Message) (interface{}, interface{}, error) {\n\t\t\t\treturn msg.key, msg.Value, nil\n\t\t\t}, consumeFailProcess).\n\t\tProcess(func(ctx context.Context, window *TimeWindow) error {\n\t\t...\n\t\t\treturn nil\n\t\t}, consumeFailProcess)\n아래와 같이 설정에 time window 기간을 명시하고, 아래 “flea_market_vector_v1”라는 이름으로 DataLoaderBatchStreamingTransform를 구현했어요. 이 로직을 transform에 넣어주면 TumblingWindow 형태로 데이터를 모아서 batch 처리를 할 수 있어요.\nsubscribe_message:\n      - topic: indexing.fleamarket.flea_market_article.v1\n        transform: flea_market_vector_v1\n        window_time_milliseconds: 2000\ntype DataLoaderBatchStreamingTransform interface {\n    // GetName transform 이름 : schema yaml transform 필드에 들어갈 이름\n    GetName() string\n    // Preprocess batch transform전 단일 문서에 대해 전처리를 수행합니다.\n    Preprocess(ctx context.Context,\n               parameter entity.TransformParameter,\n               msg *kafka.Message) (entity.IndexerMessage, error)\n    // BatchTransform bulk로 변환 로직이 들어갈 곳 return 값이 DataStore에 적재됨\n    BatchTransform(ctx context.Context,\n                   parameter entity.TransformParameter,\n                   data []entity.IndexerMessage) ([]entity.IndexerMySQLMessage, error)\n}\n해당 작업을 통해 1.5core의 pod 8대 만으로도 초당 수만 건의 이벤트를 무리 없이 처리할 수 있었어요.\n이외에도 최근까지 Transform을 자동으로 생성해 주는 옵션, Vector Emebdding, LLM, Model Inference, 수많은 PR 테스트와 모니터링 등 검색 서비스를 안정적으로 지원하기 위해 다양한 작업을 지속하고 있어요.\nModel Inference 등 기능이 추가되고 있는 Indexer pipeline\n마무리\n지금까지 당근의 검색플랫폼팀에서 색인 파이프라인의 안정성과 생산성을 높이기 위해 고민하고 개선했던 과정들을 소개했어요.\n서비스가 성장할수록 더 많은 데이터를 효율적으로 처리할 수 있는 구조가 필요해지고, 동시에 서비스 간 의존성을 낮추고 가시성을 높여야 하는데요. 앞으로도 저희 검색플랫폼팀은 더욱 편리하고 신뢰할 수 있는 검색 환경을 사용자와 개발자 모두에게 제공하기 위해 다양한 시도를 계속할 예정이에요. 당근의 검색 플랫폼이 어떤 모습으로 발전해 나갈지 많은 관심 부탁드리며, 함께 고민하고 성장할 멋진 동료들을 언제나 환영합니다!\n긴 글 읽어주셔서 감사합니다. 😊\n검색인프라 채용: https://about.daangn.com/jobs/5688517003/\n\n검색 Indexing 파이프라인 개선기 was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "Hy Lee (sang un)",
        "guid": "https://medium.com/p/c01c64292831",
        "categories": [
          "indexing",
          "platform-engineering",
          "search",
          "pipeline"
        ],
        "isoDate": "2025-04-15T06:14:54.000Z"
      },
      {
        "creator": "당근",
        "title": "모두가 AI 로켓에 올라타도록, 당근 운영실이 AI로 일하는 법",
        "link": "https://medium.com/daangn/%EB%AA%A8%EB%91%90%EA%B0%80-ai-%EB%A1%9C%EC%BC%93%EC%97%90-%EC%98%AC%EB%9D%BC%ED%83%80%EB%8F%84%EB%A1%9D-%EB%8B%B9%EA%B7%BC-%EC%9A%B4%EC%98%81%EC%8B%A4%EC%9D%B4-ai%EB%A1%9C-%EC%9D%BC%ED%95%98%EB%8A%94-%EB%B2%95-b8aaa6713cea?source=rss----4505f82a2dbd---4",
        "pubDate": "Fri, 11 Apr 2025 06:11:35 GMT",
        "content:encoded": "<h3>모두가 AI 로켓에 올라타도록, 당근 운영실이 AI로 일하는 법 — 당근 AI Show &amp; Tell #2</h3><blockquote>당근은 매주 ‘AI Show &amp; Tell’을 통해 각 팀의 AI 실험을 전사적으로 공유해요. AI를 업무에 어떻게 적용하고 있는지, 그 과정에서 어떤 시행착오와 인사이트가 있었는지를 가감 없이 나누죠. 당근은 완벽한 정답을 찾기보다 먼저 과감하게 실행하며, AI 전환에 빠르게 몰입하고 있어요. AI로 만드는 생생한 도전의 순간들, 지금 만나보세요.</blockquote><blockquote>✍️ 이 콘텐츠는 생성형 AI를 활용해 제작한 콘텐츠입니다.</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_KoBP5ulvvwWDBSKxnKSNw.png\" /><figcaption>서비스 운영실 팀 내부 세션 ‘Nextstep for Service Operation’ 발표 자료</figcaption></figure><p>단순히 팀에 AI를 도입한다고 해서 곧바로 혁신을 만들어낼 수 있을까요? 기술은 어디까지나 수단일 뿐이에요. 새로운 기술을 ‘무엇을 위해’, ‘어떻게’ 활용할지에 대한 체계가 뒷받침되지 않으면, 변화는 새로운 기술을 한두 번 시도해 보는 수준에서 그칠 수 있어요. AI로 유의미한 성과를 지속적으로 만들기 위해선 문제 해결 방식과 협업 구조까지 조직 전체가 AI에 맞게 바뀌어야 해요.</p><p>최근 당근 AI Show &amp; Tell 세션에서 서비스 운영실 리더 Brent와 운영실 ML Engineer 리더 Aio는 <strong>“운영실이 AI로 일하는 방식”</strong>을 공유했어요. 운영실은 사용자 접점의 최전선에서 사용자 문제 해결에 집요하게 몰입하는 팀이에요. 그렇기 때문에 AI를 도입할 때도 어떻게 해야 더 빠르고 정확하게 사용자 문제를 해결할 수 있을지 고민하며, <strong>팀의 실행과 학습 속도를 극대화할 수 있도록 조직 구조와 일하는 방식을 재설계했어요.</strong></p><p>이 글에서는 당근 운영실이 AI 전환을 위해 어떻게 실행 문화를 세우고, 조직 구조를 실험적으로 바꿔 나갔는지, 그리고 어떻게 직군의 경계를 넘어 팀 모두가 함께 몰입할 수 있었는지 그 과정을 전하려고 해요.</p><h3>Part 1. 기반을 다지다 — 방향과 실행 문화의 세팅</h3><p>운영실의 AI 전환은 팀의 비전을 함께 점검하며 목표를 명확히 설정하는 데서 시작됐어요. “사용자 문제를 해결해 사용자 만족으로 연결하겠다”라는 운영실의 목표는 예나 지금이나 같고, AI 시대에도 변하지 않을 거란 점을 다시 확인했는데요. <strong>다만 AI라는 강력한 수단을 잘 활용하면, 이전과는 비교할 수 없을 만큼 빠르게 목표를 성취할 수 있다는 데 모두가 공감했어요. </strong>그렇게 팀 전체가 AI로 과감하게 시도하며 그 구체적인 방법을 찾아가 보자는 데 뜻을 모았죠.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*i-gDJU17vSYKqvzRe4kySA.png\" /></figure><p><strong>특히 운영실 리더들은 한 달 동안, 많게는 하루에 한 번씩, 최소 일주일에 한 번은 모여 실행 전략을 구체화했어요. </strong>AI 프로젝트의 방향과 분기별 OKR, 북미 대상 제품 전략까지 논의하며, 운영실의 다양한 프로덕트 중 어떤 영역을 AI로 혁신할 수 있을지 리스트업하고 우선순위를 재정비했죠. 이 치열한 정렬 과정 덕분에 팀원들은 방향을 잃지 않고, 함께 한 방향을 바라볼 수 있게 됐어요.</p><p><strong>이후 구성원들이 그 방향으로 힘 있게 나아갈 수 있도록, 구성원들에게 심리적 안정감을 주려 했어요.</strong> AI는 빠르게 실험하며 최적화하는 과정이 중요한데, ‘실패하면 어쩌지’라는 두려움이 앞서면 시작조차 어렵거든요. 그래서 운영실에서는 “틀려도 된다”, “실패에서도 배울 수 있다”, “실행 자체가 의미 있다”는 말들을 슬랙과 회의에서 반복하며, 시도를 격려하는 분위기를 일관되게 만들어갔어요. 그러자 회고 자리에서 “AI로 과감한 실행을 해보고 싶어 졌다”라는 피드백이 나올 정도로 실행에 대한 기대감이 팀 안에 자리잡기 시작했어요.</p><h3>Part 2. 구조를 바꾸다 — 워킹그룹으로의 조직적 피봇</h3><p>이런 문화적 기반 위에서 운영실은 실제 일하는 구조를 바꿨어요. 기존에는 운영실 내 다양한 파트가 기능적으로 나뉘어 있었는데요. ‘사용자가 겪는 문제를 빠르게 해결하자’는 목표는 같았지만, 한 파트는 시나리오 기반의 문제 해결을, 다른 파트는 챗봇과 FAQ 모델 활용을 고려하는 등 접근 방식이 달랐어요. 문제 해결에 대한 관점이 분산되다 보니, 조율을 위한 커뮤니케이션 비용이 커졌어요. 특히 반복적인 실행과 빠른 정렬이 필요한 AI 기술을 도입할 때, 이런 구조는 실행 속도를 늦추는 장애물이 됐죠.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*eeVHadH-8CmKzTvvXFAw4Q.png\" /><figcaption>다양한 파트의 팀원들이 섞여 프로젝트별로 결성된 워킹그룹</figcaption></figure><p>문제를 해결하기 위해 운영실은 익숙했던 파트 구조를 내려놓고 워킹그룹 체계를 도입했어요. 동일한 문제를 푸는 사람들을 파트와 무관하게 한 그룹으로 묶고, 실제 오피스 자리까지 서로 가깝게 재배치했죠. 그러자 분산되어 있던 AI 기능도 하나의 목표 아래 빠르게 실험할 수 있게 됐어요. <strong>각 워킹그룹은 하나의 AI 프로덕트를 담당해 집중하고, 매주 월요일마다 데모를 팀 내부에 공유하며 개선점을 빠르게 정리했어요.</strong> 실행과 피드백을 빠르게 오가는 사이클을 통해 시도는 반복되고 학습은 가속화됐어요.</p><p><strong>이 실행 루틴을 뒷받침하기 위해</strong> <strong>운영실은 팀의 리소스를 과감히 재배치했어요. </strong>팀 내 자원이 한정된 상황에서 구성원들이 실행에 몰입할 수 있도록 한 거죠. 예를 들어 AI 효과가 상대적으로 적은 기능성 프로젝트는 최소 동작 상태로만 유지하고, VOC 파이프라인 프로젝트*처럼 AI 적용 효과가 큰 영역은 완전 자동화 중심으로 피봇했어요. 이렇게 무엇을 멈추고 어디에 몰입할지를 명확히 정리한 덕에 실행의 밀도를 크게 높일 수 있었어요.</p><blockquote><em>VOC 파이프라인 프로젝트: 챗봇 기반으로 문제를 해결하고 VOC를 프로덕트 팀에 연결하는 프로젝트</em></blockquote><p>물론 이 과정에서 중요한 기존 프로젝트들을 놓치지 않는 것도 필요했어요. 기존에 운영실이 진행해 오던 핵심 프로젝트들은 종료 일정을 명확히 설정해 병행 중이고, 완성 이후에는 인력을 워킹그룹 체계로 재배치할 예정이에요. 지금 가장 중요한 문제 해결에 집중할 수 있도록 과거의 업무와 새로운 시도를 병렬로 정렬한 전략이었는데요. 기존의 기반을 유지하면서도 새로운 시도에 치열하게 몰입한 운영 방식은, 실행 중심 AI 전환의 좋은 사례가 되었어요.</p><h3>Part 3. 몰입을 확산하다 — 직군을 뛰어넘는 AI 몰입과 실행</h3><p>그다음 단계는 기술의 문턱을 허무는 일이었어요. 운영실은 AI 전환의 속도를 높이기 위해, 개발자 중심의 실행에 머물지 않겠다는 원칙을 세웠어요. AI가 특정 직군의 도구로 한정되면 팀 전체의 몰입도는 낮아질 수밖에 없다고 본 거죠. <strong>그래서 비개발자 구성원들도 Cursor 같은 LLM 도구를 직접 실무에 활용할 수 있도록 환경을 설계했어요. </strong>예를 들어 중고거래 게시글의 가품 여부를 판단하는 실험에서는, 운영 매니저가 엔지니어와 함께 LLM에 테이블 스키마만 제공한 뒤, SQL 쿼리 생성을 요청하고 결과를 시각화하는 실습을 진행했어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*znuPSSrlCJSFItUCLIjPmQ.png\" /></figure><p>이런 경험을 통해 문제 해결에 AI가 유용하다는 체감이 생기자, 비개발자 구성원들의 태도도 빠르게 바뀌었어요. ‘AI가 할 수 있을까?’라는 의심은 ‘이건 내가 AI로 풀어야 할 문제다’라는 책임감으로 전환됐죠. 그러자 자발적인 학습 문화도 빠르게 자리 잡았어요. 퇴근 후에도 커서로 실습을 해보거나, 서로 사용법을 나누는 분위기가 형성됐죠. 리더는 “개발자도 아닌 우리도 할 수 있다”라고 독려했고, 실제로 Cursor뿐 아니라 다양한 LLM 도구를 활용한 크고 작은 실험이 자연스럽게 퍼졌어요.</p><p><strong>결국 운영실은 ‘AI를 도입한 팀’이 아니라 ‘AI로 일하는 팀’으로 변화해 갔어요. </strong>기술 역량에 상관없이 모두가 문제를 정의하고, 실행하고, 다시 정렬하는 리듬을 갖게 되었죠. AI는 특정 직군의 언어가 아닌, 문제를 함께 푸는 공동의 언어가 되었고요. 이 변화는 모두가 AI 전환의 로켓에 올라탔기 때문에 가능했고, ‘누구나 실행할 수 있다’는 믿음이 만든 결과였어요.</p><p>당근 운영실의 AI 전환은 단순한 기술 도입이 아니었어요. <strong>문화에서 시작해 구조를 바꾸고, 실행을 모두의 일상으로 확장한 과정이었어요. </strong>팀의 비전을 다시 정비하고, 실행을 주저하지 않는 문화를 함께 설계하며, 문제 중심으로 일하는 구조를 과감히 재편했어요. 여기에 직군을 가리지 않는 몰입과 학습, 빠른 실행과 피드백의 루틴이 더해지며, 문제 해결 방식도 계속해서 고도화됐어요.</p><p>운영실의 전환은 끝이 아니라 시작이에요. 이제 이 몰입의 문화가 다른 팀들로도 확산되고 있어요. 다음 AI Show &amp; Tell에서도 이 몰입의 문화가 어떻게 더 다양한 직군과 팀으로 확산되고, 전사적으로 어떤 실행의 연결고리를 만들어가고 있는지를 보여드리도록 할게요. 실행이 문화를 만들고, 문화가 더 큰 실행을 낳는 이 전환의 흐름을 함께 지켜봐 주세요.</p><blockquote>당근에서 함께 AI 전환에 몰입하고 싶다면?<br>👉 <a href=\"https://about.daangn.com/jobs/\"><strong>당근 채용 공고 바로 가기</strong></a></blockquote><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b8aaa6713cea\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/%EB%AA%A8%EB%91%90%EA%B0%80-ai-%EB%A1%9C%EC%BC%93%EC%97%90-%EC%98%AC%EB%9D%BC%ED%83%80%EB%8F%84%EB%A1%9D-%EB%8B%B9%EA%B7%BC-%EC%9A%B4%EC%98%81%EC%8B%A4%EC%9D%B4-ai%EB%A1%9C-%EC%9D%BC%ED%95%98%EB%8A%94-%EB%B2%95-b8aaa6713cea\">모두가 AI 로켓에 올라타도록, 당근 운영실이 AI로 일하는 법</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "모두가 AI 로켓에 올라타도록, 당근 운영실이 AI로 일하는 법 — 당근 AI Show & Tell #2\n당근은 매주 ‘AI Show & Tell’을 통해 각 팀의 AI 실험을 전사적으로 공유해요. AI를 업무에 어떻게 적용하고 있는지, 그 과정에서 어떤 시행착오와 인사이트가 있었는지를 가감 없이 나누죠. 당근은 완벽한 정답을 찾기보다 먼저 과감하게 실행하며, AI 전환에 빠르게 몰입하고 있어요. AI로 만드는 생생한 도전의 순간들, 지금 만나보세요.\n✍️ 이 콘텐츠는 생성형 AI를 활용해 제작한 콘텐츠입니다.\n서비스 운영실 팀 내부 세션 ‘Nextstep for Service Operation’ 발표 자료\n단순히 팀에 AI를 도입한다고 해서 곧바로 혁신을 만들어낼 수 있을까요? 기술은 어디까지나 수단일 뿐이에요. 새로운 기술을 ‘무엇을 위해’, ‘어떻게’ 활용할지에 대한 체계가 뒷받침되지 않으면, 변화는 새로운 기술을 한두 번 시도해 보는 수준에서 그칠 수 있어요. AI로 유의미한 성과를 지속적으로 만들기 위해선 문제 해결 방식과 협업 구조까지 조직 전체가 AI에 맞게 바뀌어야 해요.\n최근 당근 AI Show & Tell 세션에서 서비스 운영실 리더 Brent와 운영실 ML Engineer 리더 Aio는 “운영실이 AI로 일하는 방식”을 공유했어요. 운영실은 사용자 접점의 최전선에서 사용자 문제 해결에 집요하게 몰입하는 팀이에요. 그렇기 때문에 AI를 도입할 때도 어떻게 해야 더 빠르고 정확하게 사용자 문제를 해결할 수 있을지 고민하며, 팀의 실행과 학습 속도를 극대화할 수 있도록 조직 구조와 일하는 방식을 재설계했어요.\n이 글에서는 당근 운영실이 AI 전환을 위해 어떻게 실행 문화를 세우고, 조직 구조를 실험적으로 바꿔 나갔는지, 그리고 어떻게 직군의 경계를 넘어 팀 모두가 함께 몰입할 수 있었는지 그 과정을 전하려고 해요.\nPart 1. 기반을 다지다 — 방향과 실행 문화의 세팅\n운영실의 AI 전환은 팀의 비전을 함께 점검하며 목표를 명확히 설정하는 데서 시작됐어요. “사용자 문제를 해결해 사용자 만족으로 연결하겠다”라는 운영실의 목표는 예나 지금이나 같고, AI 시대에도 변하지 않을 거란 점을 다시 확인했는데요. 다만 AI라는 강력한 수단을 잘 활용하면, 이전과는 비교할 수 없을 만큼 빠르게 목표를 성취할 수 있다는 데 모두가 공감했어요. 그렇게 팀 전체가 AI로 과감하게 시도하며 그 구체적인 방법을 찾아가 보자는 데 뜻을 모았죠.\n\n특히 운영실 리더들은 한 달 동안, 많게는 하루에 한 번씩, 최소 일주일에 한 번은 모여 실행 전략을 구체화했어요. AI 프로젝트의 방향과 분기별 OKR, 북미 대상 제품 전략까지 논의하며, 운영실의 다양한 프로덕트 중 어떤 영역을 AI로 혁신할 수 있을지 리스트업하고 우선순위를 재정비했죠. 이 치열한 정렬 과정 덕분에 팀원들은 방향을 잃지 않고, 함께 한 방향을 바라볼 수 있게 됐어요.\n이후 구성원들이 그 방향으로 힘 있게 나아갈 수 있도록, 구성원들에게 심리적 안정감을 주려 했어요. AI는 빠르게 실험하며 최적화하는 과정이 중요한데, ‘실패하면 어쩌지’라는 두려움이 앞서면 시작조차 어렵거든요. 그래서 운영실에서는 “틀려도 된다”, “실패에서도 배울 수 있다”, “실행 자체가 의미 있다”는 말들을 슬랙과 회의에서 반복하며, 시도를 격려하는 분위기를 일관되게 만들어갔어요. 그러자 회고 자리에서 “AI로 과감한 실행을 해보고 싶어 졌다”라는 피드백이 나올 정도로 실행에 대한 기대감이 팀 안에 자리잡기 시작했어요.\nPart 2. 구조를 바꾸다 — 워킹그룹으로의 조직적 피봇\n이런 문화적 기반 위에서 운영실은 실제 일하는 구조를 바꿨어요. 기존에는 운영실 내 다양한 파트가 기능적으로 나뉘어 있었는데요. ‘사용자가 겪는 문제를 빠르게 해결하자’는 목표는 같았지만, 한 파트는 시나리오 기반의 문제 해결을, 다른 파트는 챗봇과 FAQ 모델 활용을 고려하는 등 접근 방식이 달랐어요. 문제 해결에 대한 관점이 분산되다 보니, 조율을 위한 커뮤니케이션 비용이 커졌어요. 특히 반복적인 실행과 빠른 정렬이 필요한 AI 기술을 도입할 때, 이런 구조는 실행 속도를 늦추는 장애물이 됐죠.\n다양한 파트의 팀원들이 섞여 프로젝트별로 결성된 워킹그룹\n문제를 해결하기 위해 운영실은 익숙했던 파트 구조를 내려놓고 워킹그룹 체계를 도입했어요. 동일한 문제를 푸는 사람들을 파트와 무관하게 한 그룹으로 묶고, 실제 오피스 자리까지 서로 가깝게 재배치했죠. 그러자 분산되어 있던 AI 기능도 하나의 목표 아래 빠르게 실험할 수 있게 됐어요. 각 워킹그룹은 하나의 AI 프로덕트를 담당해 집중하고, 매주 월요일마다 데모를 팀 내부에 공유하며 개선점을 빠르게 정리했어요. 실행과 피드백을 빠르게 오가는 사이클을 통해 시도는 반복되고 학습은 가속화됐어요.\n이 실행 루틴을 뒷받침하기 위해 운영실은 팀의 리소스를 과감히 재배치했어요. 팀 내 자원이 한정된 상황에서 구성원들이 실행에 몰입할 수 있도록 한 거죠. 예를 들어 AI 효과가 상대적으로 적은 기능성 프로젝트는 최소 동작 상태로만 유지하고, VOC 파이프라인 프로젝트*처럼 AI 적용 효과가 큰 영역은 완전 자동화 중심으로 피봇했어요. 이렇게 무엇을 멈추고 어디에 몰입할지를 명확히 정리한 덕에 실행의 밀도를 크게 높일 수 있었어요.\nVOC 파이프라인 프로젝트: 챗봇 기반으로 문제를 해결하고 VOC를 프로덕트 팀에 연결하는 프로젝트\n물론 이 과정에서 중요한 기존 프로젝트들을 놓치지 않는 것도 필요했어요. 기존에 운영실이 진행해 오던 핵심 프로젝트들은 종료 일정을 명확히 설정해 병행 중이고, 완성 이후에는 인력을 워킹그룹 체계로 재배치할 예정이에요. 지금 가장 중요한 문제 해결에 집중할 수 있도록 과거의 업무와 새로운 시도를 병렬로 정렬한 전략이었는데요. 기존의 기반을 유지하면서도 새로운 시도에 치열하게 몰입한 운영 방식은, 실행 중심 AI 전환의 좋은 사례가 되었어요.\nPart 3. 몰입을 확산하다 — 직군을 뛰어넘는 AI 몰입과 실행\n그다음 단계는 기술의 문턱을 허무는 일이었어요. 운영실은 AI 전환의 속도를 높이기 위해, 개발자 중심의 실행에 머물지 않겠다는 원칙을 세웠어요. AI가 특정 직군의 도구로 한정되면 팀 전체의 몰입도는 낮아질 수밖에 없다고 본 거죠. 그래서 비개발자 구성원들도 Cursor 같은 LLM 도구를 직접 실무에 활용할 수 있도록 환경을 설계했어요. 예를 들어 중고거래 게시글의 가품 여부를 판단하는 실험에서는, 운영 매니저가 엔지니어와 함께 LLM에 테이블 스키마만 제공한 뒤, SQL 쿼리 생성을 요청하고 결과를 시각화하는 실습을 진행했어요.\n\n이런 경험을 통해 문제 해결에 AI가 유용하다는 체감이 생기자, 비개발자 구성원들의 태도도 빠르게 바뀌었어요. ‘AI가 할 수 있을까?’라는 의심은 ‘이건 내가 AI로 풀어야 할 문제다’라는 책임감으로 전환됐죠. 그러자 자발적인 학습 문화도 빠르게 자리 잡았어요. 퇴근 후에도 커서로 실습을 해보거나, 서로 사용법을 나누는 분위기가 형성됐죠. 리더는 “개발자도 아닌 우리도 할 수 있다”라고 독려했고, 실제로 Cursor뿐 아니라 다양한 LLM 도구를 활용한 크고 작은 실험이 자연스럽게 퍼졌어요.\n결국 운영실은 ‘AI를 도입한 팀’이 아니라 ‘AI로 일하는 팀’으로 변화해 갔어요. 기술 역량에 상관없이 모두가 문제를 정의하고, 실행하고, 다시 정렬하는 리듬을 갖게 되었죠. AI는 특정 직군의 언어가 아닌, 문제를 함께 푸는 공동의 언어가 되었고요. 이 변화는 모두가 AI 전환의 로켓에 올라탔기 때문에 가능했고, ‘누구나 실행할 수 있다’는 믿음이 만든 결과였어요.\n당근 운영실의 AI 전환은 단순한 기술 도입이 아니었어요. 문화에서 시작해 구조를 바꾸고, 실행을 모두의 일상으로 확장한 과정이었어요. 팀의 비전을 다시 정비하고, 실행을 주저하지 않는 문화를 함께 설계하며, 문제 중심으로 일하는 구조를 과감히 재편했어요. 여기에 직군을 가리지 않는 몰입과 학습, 빠른 실행과 피드백의 루틴이 더해지며, 문제 해결 방식도 계속해서 고도화됐어요.\n운영실의 전환은 끝이 아니라 시작이에요. 이제 이 몰입의 문화가 다른 팀들로도 확산되고 있어요. 다음 AI Show & Tell에서도 이 몰입의 문화가 어떻게 더 다양한 직군과 팀으로 확산되고, 전사적으로 어떤 실행의 연결고리를 만들어가고 있는지를 보여드리도록 할게요. 실행이 문화를 만들고, 문화가 더 큰 실행을 낳는 이 전환의 흐름을 함께 지켜봐 주세요.\n당근에서 함께 AI 전환에 몰입하고 싶다면?\n👉 당근 채용 공고 바로 가기\n\n모두가 AI 로켓에 올라타도록, 당근 운영실이 AI로 일하는 법 was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "당근",
        "guid": "https://medium.com/p/b8aaa6713cea",
        "categories": [
          "ai",
          "working",
          "culture",
          "team-building"
        ],
        "isoDate": "2025-04-11T06:11:35.000Z"
      },
      {
        "creator": "identity16",
        "title": "의존성 그래프를 활용한 프로젝트 시각화 — 사이드 이펙트 한눈에 파악하기",
        "link": "https://medium.com/daangn/%EC%9D%98%EC%A1%B4%EC%84%B1-%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-%ED%95%9C%EB%88%88%EC%97%90-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0-eec17d5aabb2?source=rss----4505f82a2dbd---4",
        "pubDate": "Thu, 10 Apr 2025 06:26:29 GMT",
        "content:encoded": "<h3>의존성 그래프를 활용한 프로젝트 시각화 — 사이드 이펙트 한눈에 파악하기</h3><p>안녕하세요! 당근의 동네 지도 탭에서 확인할 수 있는 동네 가게 화면과 동네 사장님들이 가게를 관리하기 위한 비즈니스 도구를 만드는 로컬 비즈니스의 Frontend Engineer 준(Joon)이에요.</p><p>혹시 ‘줄줄이 고구마’라는 말을 들어보신 적 있으신가요? 고구마 하나를 캐니, 그 뿌리에 달린 다른 고구마들이 몇 십 개나 딸려 나왔다는 건데요. 고구마가 70개나 달린 줄줄이 고구마 사진을 뉴스에서 처음 봤을 때, 저는 제가 작업하던 코드가 생각나더라고요.</p><p>많은 엔지니어들이 그러하듯, 저도 개발에 착수하기 전에 일정을 산정하는데요. 정작 작업하다 보면 예상치 못한 사이드 이펙트가 ‘하나 캐니 줄줄줄!’ 나오는 상황이 발생하곤 하죠. 그럴 때마다 ‘고구마 뿌리 뽑듯이 계속 나와서요.. 🥺’라고 공유드리며 일정을 미룬 적이 한두 번이\u001c아니에요. 이러면 팀 차원의 일정이 미뤄지기 때문에 그 해결 방법을 고민하기 시작했어요.</p><p>결과적으로 저희 팀은 의존성 그래프를 활용해 프로젝트를 시각화함으로써 코드 파악에 소모되는 시간을 단축했어요. 덕분에 팀에서는 불필요한 리소스 소모 없이 더 빠른 실행이 가능해졌는데요. 이 글에서는 그 구체적인 과정을 소개해 드리려고 해요. 본격적인 작업에 들어가기 전 기존 코드 파악에 시간을 많이 쏟는 게 고민이시라면, 저희의 사례가 업무의 생산성을 높이는 데 큰 도움이 될 수 있을 거예요.</p><h3>문제를 정의해 보자</h3><p>해결에 앞서 5 whys 기법을 통해 문제의 본질적인 원인을 찾아보려고 했어요.</p><p><strong>Q1: 사이드 이펙트를 왜 뒤늦게 발견하는가?</strong></p><p>A: 일정 산정 시점에는 보이지 않았는데, 코드 작업할 때 눈에 띄는 경우가 많았어요.</p><p><strong>Q2: 일정 산정 시점에는 사이드 이펙트를 찾지 못하는가?</strong></p><p>A: 현실적으로 작업 전에 관련된 모든 파일을 다 뒤져보지 못하기 때문이에요.</p><p><strong>Q3: 왜 작업 관련 파일을 다 뒤져보지 못하는가?</strong></p><p>A: 비즈프로필 웹뷰에는 144개의 페이지, 4648개의 파일이 존재해요. 중간중간 재사용되는 파일을 다 뒤지다 보면, 수작업으로 파악하기 어려울 정도로 경우의 수가 커져요.</p><p>5개의 why를 던지지는 않았지만 이쯤에서 저는 본질적인 원인을 파악했다고 판단했어요. <strong>‘너무 많은 파일들의 의존 관계를 다 뒤져보기 힘들다’</strong>는 부분이 해결되면, 예상치 못한 ‘줄줄이 고구마’를 개발 착수 전에 미리 찾아낼 수 있겠다고 생각했죠. 이걸 문제로 정의하고 해결해 보기로 했어요.</p><h3>어떻게 해결하는 게 좋을까?</h3><p>앞에서 정의한 문제는 다음과 같아요.</p><blockquote><strong><em>‘너무 많은 파일들의 의존 관계를 다 뒤져보기 힘들다’</em></strong></blockquote><p>이 문제는 두 가지 방식으로 접근할 수 있을 것 같아요.</p><ol><li><strong>설계 잘하기</strong> : 파일 간의 관계를 명확하게 드러낼 수 있는 폴더 구조 혹은 아키텍처를 정립한다.</li><li><strong>시각화 잘하기</strong> : 현재 파일이 어떤 파일을 import 하고 있는지, 어떤 파일에 import 되고 있는지 한눈에 볼 수 있도록 시각화한다.</li></ol><p>1번은 의존 관계의 복잡도 자체를 근본적으로 낮출 수 있는 방법이에요. 그러나 빠르게 프로덕트를 실험하고 기능을 추가하고자 하는 상황에서 한 가지 구조를 학습시키고 따르게 하는 것은 많은 설득과 시간이 필요할 거예요. 따라서 1번은 장기적으로 가져가야 할 전략이라 판단했고, 당장 지금의 문제를 완화할 수 있는 방안으로 시각화를 잘해보자는 결론에 다다랐어요.</p><p>JS/TS 환경에서 사용할 수 있는 의존성 시각화 도구로 크게 두 가지 정도를 발견했어요.</p><ul><li><a href=\"https://github.com/pahen/madge\">Madge</a></li><li><a href=\"https://github.com/sverweij/dependency-cruiser/tree/main\">Dependency Cruiser</a></li></ul><p>저는 이 중에서 조금 더 문서화가 잘 되어 있는 Dependency Cruiser를 사용하기로 했어요. 이 도구를 사용하면 다음과 같은 의존성 그래프를 그릴 수 있어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*sK4g4seXlehCtKRUF2EM7Q.png\" /></figure><p>참고로, 이 글에서는 도구의 사용법은 다루지 않을 예정이에요. 어떤 도구를 사용하든 파일 구조에 따라 정규표현식을 각기 다르게 써주어야 하고, 보고 싶은 정보가 사람, 팀, 상황마다 다를 수 있어요. 그래서 툴보다는 의존성 그래프 활용 사례를 중심으로 소개해 드릴 예정이에요.</p><blockquote><em>Tip: Cursor의 Docs에 추가하거나 GPT에 링크를 넣고 물어보면, 훨씬 빠르게 원하는 옵션을 찾을 수 있어요.</em></blockquote><h3>의존성 그래프를 적용해 보자</h3><p>개발을 하다 보면 코드를 파악해야 하는 상황이 정말 많이 벌어지는데요. 의존성 그래프가 어떻게 코드 파악을 용이하게 만드는지 DashBoard, Profile, Settings 3개의 페이지를 가진 예제 프로젝트를 기준으로 설명드려볼게요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IE9QROkgKtmjo_jUXA_Dsw.png\" /><figcaption>예제 프로젝트 — DashBoard 페이지</figcaption></figure><h3>Bottom-Up: 이 파일의 사이드 이펙트를 빠르게 알고 싶어.</h3><p>협업을 하다 보면 종종 디자이너 분들에게서 이런 요청을 받을 때가 있어요.</p><blockquote><em>👩‍🎨(디자이너) : 공통 컴포넌트를 디자인시스템으로 만들기 위해 파악 중이에요. 혹시 카드 컴포넌트가 어디 어디 쓰이는지 알 수 있을까요?</em></blockquote><p>혹은 본격적으로 개발하기 전에 수정해야 할 파일의 사이드 이펙트를 파악해야 하죠.</p><blockquote><em>🧑‍💻(엔지니어) : 이번 작업은 카드 컴포넌트 리팩토링이 수반될 것 같은데, 이 작업이 어느 파일들에 영향을 줄까?</em></blockquote><p>의존성 그래프를 도입하기 전과 후의 작업 과정을 한번 비교해 볼게요.</p><p><strong>Before: 파일을 하나하나 타고 올라가서 파악했어요</strong></p><p>기존에는 위와 같은 요청을 받으면 일단 에디터에서 카드 컴포넌트 파일(Card.tsx)을 여는 걸로 시작했어요. 그 후 Cmd(혹은 Ctrl) 버튼을 누른 채 컴포넌트명을 누르면, 아래 이미지와 같이 이 컴포넌트가 어디에서 import 되는지 목록을 볼 수 있죠.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YQkER8vjEgBIiMuLpneX1Q.png\" /></figure><p>여기를 보면 다음과 같은 파일들이 보이네요.</p><ul><li>components/.../UserProfile.tsx</li><li>components/.../ActivityList.tsx</li><li>components/.../StatCard.tsx</li><li>components/.../NotificationSettings.tsx</li><li>components/.../UserProfileCard.tsx</li><li>pages/Dashboard.tsx</li><li>pages/Settings.tsx</li></ul><p>일단 pages/Dashboard.tsx, pages/Settings.tsx 두 페이지에서 쓰인다는 사실은 알았으니 나머지 컴포넌트들은 어느 페이지에서 쓰이는지 봐야 해요. UserProfile.tsx를 import하고 있는 파일 목록 안에, 그 파일들을 import 하고 있는 파일 목록을 또 파악하고, 그 과정 끝에 최종적으로 import 하고 있는 페이지 컴포넌트를 확인해야 하죠.</p><p>이 과정을 ActivityList.tsx, StatCard.tsx, NotificationSettings.tsx, UserProfileCard.tsx 각각에 대하여 재귀적으로 다 확인해 본 다음에야 비로소 카드 컴포넌트가 사용되는 영향 범위를 전부 알 수 있어요. 수백, 수천 개의 파일이 서로 의존하고 있는 프로젝트에선 길게는 수시간 이상 걸리기도 하는 과정이에요.</p><p><strong>After: 의존성 그래프를 그려 한눈에 파악해요</strong></p><p>다음 옵션들과 함께 Dependency Cruiser 스크립트 실행하면 이런 그래프를 그릴 수 있어요.</p><ul><li>depcruise src : 타겟 경로로 src를 넣어 전체 소스 코드에 대한 의존성 그래프를 그려요.</li><li>--reaches 옵션으로, 카드 컴포넌트에 도달하는 의존성만 필터링해서 원하는 정보만 남겼어요.</li><li>--highlight 옵션으로, pages와 카드 컴포넌트를 한눈에 알아볼 수 있게 색을 입혔어요.</li><li>--include-only 옵션으로, src 경로에서만 의존성을 파악하도록 했어요. (node_modules 제외)</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*CDSiyltcDCQRHA3iBYtwgQ.png\" /></figure><p>이렇게 생성된 의존성 그래프를 보면, Card 컴포넌트가 사용되고 있는 페이지를 한눈에 파악할 수 있어요. 이제는 스크립트 한번 실행하는 것만으로 파일을 하나하나 찾아볼 시간이 절약되었고, 덤으로 DashLayout, SettingsLayout는 아무 페이지에서도 안 쓰고 있다는 것을 발견했네요.</p><p>또한 실무에서 협업할 때도 확실한 이점을 느꼈는데요. 본 작업 전에 코드 리팩토링 작업이 필요하다는 사실을 비개발 직군 팀원들에게 설득할 때, 복잡하게 그려진 의존성 그래프를 보여주면 문제를 더 직관적으로 이해시킬 수 있게 됐어요.</p><h3>Top-Down: 이 컴포넌트가 어떤 파일에 영향받는지 궁금해.</h3><p>앞에서는 특정 파일이 <strong>‘어디에 사용되는지’</strong>에 대한 궁금증을 해소하기 위해 의존성 그래프의 도움을 받았어요. 이번에는 특정 파일이 <strong>‘무엇을 사용하는지’</strong> 궁금한 경우에 대해서 이야기해보려고 해요.</p><p>대표적으로 프로젝트에서 처음 수정해 보는 페이지를 마주치게 된다면, 다음과 같은 생각이 자연스럽게 따라 나오는 것 같아요.</p><blockquote><em>👨‍💻(엔지니어) : DashBoard 페이지는 처음 건드려보는데, 얼마나 복잡한 페이지일까?</em></blockquote><p>DashBoard 페이지를 작업하기 전에 예상 소요 시간을 파악하기 위해서는 주요 파일들을 한번 훑어보는 과정이 반드시 필요하죠. 의존성 그래프를 도입하기 전후로 이 과정에 어떤 변화가 있었는지 소개드려볼게요.</p><p><strong>Before: 코드를 보고 눈대중으로 중요한 부분만 파악했어요</strong></p><p>일단 pages/Dashboard.tsx 에 들어가서 코드를 훑어본 다음, 중요해 보이는 컴포넌트나 훅이 있다면 해당 파일로 가서 세부 구현을 살펴봐요.</p><p>그렇게 들어간 파일에서도 핵심 로직을 집중적으로 보고, 나머지 코드에서도 중요해 보이는 파일이 있다면 또 넘어가서 보는 것을 반복했어요. 이 페이지가 가진 복잡도가 어느 정도인지 눈대중으로 감을 얻어갔죠.</p><p>이 과정에서 느낀 불편함은 다음과 같아요.</p><ul><li><strong>시간 소모</strong> : 복잡한 페이지일수록 수십 개의 컴포넌트를 일일이 확인해야 하는데, 많게는 몇 시간까지 소요돼요. 게다가 중간중간 질문을 받거나 회의를 다녀오면 집중이 끊기기 때문에 더 많은 시간을 필요로 해요.</li><li><strong>중복 파악 / 누락 가능성</strong> : 중첩된 컴포넌트 구조에서는 일부를 놓치거나 봤던 파일을 또 보기 쉬워요. 또한 추상화로 인해 숨겨진 내부 동작을 모르고 어림짐작으로 넘어간다면, 작업할 때 뒤늦게 발견되는 코드로 인해 일정에 변수가 생기기도 해요.</li><li><strong>일정 산정의 근거 미약 :</strong> 이렇게 파악한 결론은 ‘복잡한 것 같다는 감’이기 때문에, “이 페이지는 다른 데보다 조금 더 복잡해서 일정이 더 필요할 거 같아요” 정도의 두루뭉술한 소통이 일어날 수 있어요. 일정이 지연됐을 때 “막상 작업하다 보니 생각보다 더 복잡해서 일정이 조금 더 필요해요”라고 변명하는 모습은 제가 생각하는 좋은 엔지니어의 모습은 아니었어요.</li></ul><p><strong>After: 하위 의존성을 시각화해, 파일들의 복잡도를 한눈에 파악해요</strong></p><p>Dependency Cruiser는 기본적으로 Top-Down 시각화를 지원해요.</p><p>다음 옵션들과 함께 Dependency Cruiser 스크립트 실행하면 이런 그래프를 그릴 수 있어요.</p><ul><li>depcruise src/pages/Dashboard.tsx : 타겟 경로로 Dashboard 파일을 지정하여 Dashboard 페이지 하위 의존성만 그리도록 했어요.</li><li>--highlight : 대시보드 페이지만 강조하도록 했어요.</li><li>--collapse : node_modules에 있는 라이브러리는 최상위 폴더만 보이도록 설정했어요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cCGdtW12S0FjpnnC-I2hYg.png\" /></figure><p>이렇게 Top-Down 방향으로 하위 의존성을 시각화해 보면, Dashboard 페이지 하위에 어떤 파일들이 연관되어 있는지와 얼마나 복잡하게 의존하고 있는지를 한눈에 볼 수 있어요.</p><p>의존성 그래프로 인해 앞서 말했던 불편함들이 이렇게 해결돼요.</p><ul><li><strong>시간 절약 :</strong> Dashboard 페이지 하위의 파일들을 한눈에 보고, 내가 모르는 부분과 이미 아는 부분을 빠르게 솎아낼 수 있어요. 파악할 코드를 추려내기 위해 위에서부터 하나하나 파일을 타고 내려갈 필요 없이 스크립트를 돌리는 몇 초만 소요하면 돼요.</li><li><strong>중복 파악 / 누락 가능성 감소 :</strong> 파일과 코드를 일일이 텍스트로 보지 않고 관련 파일을 펼쳐놓고 보기 때문에, 봤던 파일을 또 보거나 못 보고 넘어갈 확률이 줄어요.</li><li><strong>일정 산정의 근거로 활용 :</strong> 개발자만 느끼는 ‘복잡도’라는 개념을 시각적으로 보여주면 비개발자도 쉽게 이해할 수 있어요. 왜 A 페이지를 수정하는 게 왜 B 페이지보다 오래 걸리는지 직관적으로 설명할 수 있어요. 그리고 리팩토링은 복잡도를 낮춰 생산성을 올리는 행위라는 걸 AS-IS / TO-BE로 비교하며 보여줄 수도 있어요.</li></ul><h3>Code Review: Pull Request에 의존성 그래프 추가</h3><p>이번에는 코드리뷰 시점에 의존성 그래프를 적용한 시도를 소개해볼게요.</p><p>Github Actions를 이용해 Pull Request에 포함된 File Changes를 기준으로 영향이 가는 범위를 시각화하는 스크립트를 추가했어요. 이 작업으로 인해 저장소에 기여자의 PR이 올라오면, 다음과 같은 시각화가 자동으로 달리게 돼요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*AN7g7lw-smjkyDo333EDag.png\" /><figcaption>실제 Pull Request에 생성된 의존성 그래프</figcaption></figure><p>기존에는 다른 개발자의 코드를 리뷰할 때 파일 하나, 코드 한 줄이라는 텍스트에 집중했다면, 의존성 시각화를 통해 이 사람이 <strong>얼마나 큰 작업을 했는지,</strong> 수정한 파일의 <strong>사이드 이펙트가 얼마나 큰지를 알 수 있게 되었어요.</strong></p><p>또한 의존성 그래프가 있으면 리뷰어는 다음과 같은 코드리뷰를 통해서 코드베이스 전체의 복잡도까지 관리할 수 있게 돼요.</p><blockquote><em>🧑‍💻(리뷰어) : X 파일 수정하셨는데, 작업과 관련 없는 A/B/C 페이지에도 영향이 가는 것 같아요. 예상치 못한 사이드 이펙트가 없도록 리팩토링 먼저 하고 변경사항 적용하면 어떨까요?</em></blockquote><h3>Team: 프로젝트 전체 구조 한눈에 훑어보기</h3><p>프로젝트의 신규 기여자를 온보딩할 때, 일반적으로 코드를 살펴보는 시간을 충분히 가지게 하죠.</p><p>매일 많은 변경이 일어나는 거대한 프로젝트를 제대로 이해하려면, 그 어떤 문서보다 실제로 돌아가는 코드를 확인하는 게 중요해요. 하지만 수천 개의 파일이 담긴 프로젝트 폴더를 열어보는 순간 어디서부터 봐야 할지 막막해지죠.</p><p>이런 막막함을 느껴본 적이 있으시다면 프로젝트 전체를 의존성 그래프로 그려서 지도처럼 표현해 보는 방식을 소개드려요. 다음과 같은 그림이나 스크립트를 기여 문서에 추가한다면, 처음 기여하는 사람들이 조금 더 원활하게 온보딩할 수 있어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*sK4g4seXlehCtKRUF2EM7Q.png\" /><figcaption>예제 프로젝트의 전체 의존성 그래프</figcaption></figure><p>기본적으로 depcruise src 로 전체 소스코드를 대상으로 그래프를 그릴 수 있고, Depedency Cruiser 옵션을 더 다양하게 알아보고 건드리면서 필요한 수준으로 조정하시는 걸 추천드려요.</p><ul><li>--output-type ddot로 폴더 단위로 그래프를 그려 폴더 구조만 표현할 수 있어요.</li><li>특정 범위의 파일만 보고 싶다면 --include-only로 원하는 영역만 시각화할 수 있어요.</li><li>Rule을 사용하면 순환 참조나 폴더 구조에 대한 규칙을 Lint처럼 걸어두고, 이를 위반한 경우에는 의존성 그래프에 화살표를 강조하는 등의 안내를 줄 수 있어요.</li></ul><h3>결론</h3><p>의존성 그래프를 활용해 프로젝트 시각화한 후, 코드를 파악하느라 정처 없이 여기저기 파일을 열어보며 돌아다니는 시간이 거의 사라졌어요.</p><p>사이드 프로젝트가 아닌 회사 프로젝트에서, 대부분의 개발자는 관리하고 있는 코드의 첫 번째 기여자가 아닌 경우가 많아요. 따라서 코드를 작성하는 것보다 파악하는 시간이 훨씬 길어질 수 있어요.</p><p>특히나 제가 당근에서 마주친 코드들은 엔지니어링과 프로덕트 경험 양면에서의 치열한 고민 흔적들이 많이 묻어있었어요. 지금도 옆에서 다양한 고민을 함께 나누고 시도하는 동료들이 있기 때문에 파악할 코드는 더더욱 빠르게 늘어나고 있고요.</p><p>Copilot, Cursor 등의 AI 도구들이 발전하면서 코드 작성에 대한 생산성은 빠르게 개선되고 있다고 생각하는데요. 이번 글을 읽으신 분들께서는 의존성 시각화라는 도구를 통해 코드를 파악하는 데에 드는 시간까지 줄여서, 더 빠른 실행과 좋은 프로덕트를 만들어가는 데 조금이라도 도움이 되셨으면 좋겠습니다!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=eec17d5aabb2\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/%EC%9D%98%EC%A1%B4%EC%84%B1-%EA%B7%B8%EB%9E%98%ED%94%84%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-%ED%95%9C%EB%88%88%EC%97%90-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0-eec17d5aabb2\">의존성 그래프를 활용한 프로젝트 시각화 — 사이드 이펙트 한눈에 파악하기</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "의존성 그래프를 활용한 프로젝트 시각화 — 사이드 이펙트 한눈에 파악하기\n안녕하세요! 당근의 동네 지도 탭에서 확인할 수 있는 동네 가게 화면과 동네 사장님들이 가게를 관리하기 위한 비즈니스 도구를 만드는 로컬 비즈니스의 Frontend Engineer 준(Joon)이에요.\n혹시 ‘줄줄이 고구마’라는 말을 들어보신 적 있으신가요? 고구마 하나를 캐니, 그 뿌리에 달린 다른 고구마들이 몇 십 개나 딸려 나왔다는 건데요. 고구마가 70개나 달린 줄줄이 고구마 사진을 뉴스에서 처음 봤을 때, 저는 제가 작업하던 코드가 생각나더라고요.\n많은 엔지니어들이 그러하듯, 저도 개발에 착수하기 전에 일정을 산정하는데요. 정작 작업하다 보면 예상치 못한 사이드 이펙트가 ‘하나 캐니 줄줄줄!’ 나오는 상황이 발생하곤 하죠. 그럴 때마다 ‘고구마 뿌리 뽑듯이 계속 나와서요.. 🥺’라고 공유드리며 일정을 미룬 적이 한두 번이\u001c아니에요. 이러면 팀 차원의 일정이 미뤄지기 때문에 그 해결 방법을 고민하기 시작했어요.\n결과적으로 저희 팀은 의존성 그래프를 활용해 프로젝트를 시각화함으로써 코드 파악에 소모되는 시간을 단축했어요. 덕분에 팀에서는 불필요한 리소스 소모 없이 더 빠른 실행이 가능해졌는데요. 이 글에서는 그 구체적인 과정을 소개해 드리려고 해요. 본격적인 작업에 들어가기 전 기존 코드 파악에 시간을 많이 쏟는 게 고민이시라면, 저희의 사례가 업무의 생산성을 높이는 데 큰 도움이 될 수 있을 거예요.\n문제를 정의해 보자\n해결에 앞서 5 whys 기법을 통해 문제의 본질적인 원인을 찾아보려고 했어요.\nQ1: 사이드 이펙트를 왜 뒤늦게 발견하는가?\nA: 일정 산정 시점에는 보이지 않았는데, 코드 작업할 때 눈에 띄는 경우가 많았어요.\nQ2: 일정 산정 시점에는 사이드 이펙트를 찾지 못하는가?\nA: 현실적으로 작업 전에 관련된 모든 파일을 다 뒤져보지 못하기 때문이에요.\nQ3: 왜 작업 관련 파일을 다 뒤져보지 못하는가?\nA: 비즈프로필 웹뷰에는 144개의 페이지, 4648개의 파일이 존재해요. 중간중간 재사용되는 파일을 다 뒤지다 보면, 수작업으로 파악하기 어려울 정도로 경우의 수가 커져요.\n5개의 why를 던지지는 않았지만 이쯤에서 저는 본질적인 원인을 파악했다고 판단했어요. ‘너무 많은 파일들의 의존 관계를 다 뒤져보기 힘들다’는 부분이 해결되면, 예상치 못한 ‘줄줄이 고구마’를 개발 착수 전에 미리 찾아낼 수 있겠다고 생각했죠. 이걸 문제로 정의하고 해결해 보기로 했어요.\n어떻게 해결하는 게 좋을까?\n앞에서 정의한 문제는 다음과 같아요.\n‘너무 많은 파일들의 의존 관계를 다 뒤져보기 힘들다’\n이 문제는 두 가지 방식으로 접근할 수 있을 것 같아요.\n\n설계 잘하기 : 파일 간의 관계를 명확하게 드러낼 수 있는 폴더 구조 혹은 아키텍처를 정립한다.\n시각화 잘하기 : 현재 파일이 어떤 파일을 import 하고 있는지, 어떤 파일에 import 되고 있는지 한눈에 볼 수 있도록 시각화한다.\n\n1번은 의존 관계의 복잡도 자체를 근본적으로 낮출 수 있는 방법이에요. 그러나 빠르게 프로덕트를 실험하고 기능을 추가하고자 하는 상황에서 한 가지 구조를 학습시키고 따르게 하는 것은 많은 설득과 시간이 필요할 거예요. 따라서 1번은 장기적으로 가져가야 할 전략이라 판단했고, 당장 지금의 문제를 완화할 수 있는 방안으로 시각화를 잘해보자는 결론에 다다랐어요.\nJS/TS 환경에서 사용할 수 있는 의존성 시각화 도구로 크게 두 가지 정도를 발견했어요.\n\nMadge\nDependency Cruiser\n\n저는 이 중에서 조금 더 문서화가 잘 되어 있는 Dependency Cruiser를 사용하기로 했어요. 이 도구를 사용하면 다음과 같은 의존성 그래프를 그릴 수 있어요.\n\n참고로, 이 글에서는 도구의 사용법은 다루지 않을 예정이에요. 어떤 도구를 사용하든 파일 구조에 따라 정규표현식을 각기 다르게 써주어야 하고, 보고 싶은 정보가 사람, 팀, 상황마다 다를 수 있어요. 그래서 툴보다는 의존성 그래프 활용 사례를 중심으로 소개해 드릴 예정이에요.\nTip: Cursor의 Docs에 추가하거나 GPT에 링크를 넣고 물어보면, 훨씬 빠르게 원하는 옵션을 찾을 수 있어요.\n의존성 그래프를 적용해 보자\n개발을 하다 보면 코드를 파악해야 하는 상황이 정말 많이 벌어지는데요. 의존성 그래프가 어떻게 코드 파악을 용이하게 만드는지 DashBoard, Profile, Settings 3개의 페이지를 가진 예제 프로젝트를 기준으로 설명드려볼게요.\n예제 프로젝트 — DashBoard 페이지\nBottom-Up: 이 파일의 사이드 이펙트를 빠르게 알고 싶어.\n협업을 하다 보면 종종 디자이너 분들에게서 이런 요청을 받을 때가 있어요.\n👩‍🎨(디자이너) : 공통 컴포넌트를 디자인시스템으로 만들기 위해 파악 중이에요. 혹시 카드 컴포넌트가 어디 어디 쓰이는지 알 수 있을까요?\n혹은 본격적으로 개발하기 전에 수정해야 할 파일의 사이드 이펙트를 파악해야 하죠.\n🧑‍💻(엔지니어) : 이번 작업은 카드 컴포넌트 리팩토링이 수반될 것 같은데, 이 작업이 어느 파일들에 영향을 줄까?\n의존성 그래프를 도입하기 전과 후의 작업 과정을 한번 비교해 볼게요.\nBefore: 파일을 하나하나 타고 올라가서 파악했어요\n기존에는 위와 같은 요청을 받으면 일단 에디터에서 카드 컴포넌트 파일(Card.tsx)을 여는 걸로 시작했어요. 그 후 Cmd(혹은 Ctrl) 버튼을 누른 채 컴포넌트명을 누르면, 아래 이미지와 같이 이 컴포넌트가 어디에서 import 되는지 목록을 볼 수 있죠.\n\n여기를 보면 다음과 같은 파일들이 보이네요.\n\ncomponents/.../UserProfile.tsx\ncomponents/.../ActivityList.tsx\ncomponents/.../StatCard.tsx\ncomponents/.../NotificationSettings.tsx\ncomponents/.../UserProfileCard.tsx\npages/Dashboard.tsx\npages/Settings.tsx\n\n일단 pages/Dashboard.tsx, pages/Settings.tsx 두 페이지에서 쓰인다는 사실은 알았으니 나머지 컴포넌트들은 어느 페이지에서 쓰이는지 봐야 해요. UserProfile.tsx를 import하고 있는 파일 목록 안에, 그 파일들을 import 하고 있는 파일 목록을 또 파악하고, 그 과정 끝에 최종적으로 import 하고 있는 페이지 컴포넌트를 확인해야 하죠.\n이 과정을 ActivityList.tsx, StatCard.tsx, NotificationSettings.tsx, UserProfileCard.tsx 각각에 대하여 재귀적으로 다 확인해 본 다음에야 비로소 카드 컴포넌트가 사용되는 영향 범위를 전부 알 수 있어요. 수백, 수천 개의 파일이 서로 의존하고 있는 프로젝트에선 길게는 수시간 이상 걸리기도 하는 과정이에요.\nAfter: 의존성 그래프를 그려 한눈에 파악해요\n다음 옵션들과 함께 Dependency Cruiser 스크립트 실행하면 이런 그래프를 그릴 수 있어요.\n\ndepcruise src : 타겟 경로로 src를 넣어 전체 소스 코드에 대한 의존성 그래프를 그려요.\n--reaches 옵션으로, 카드 컴포넌트에 도달하는 의존성만 필터링해서 원하는 정보만 남겼어요.\n--highlight 옵션으로, pages와 카드 컴포넌트를 한눈에 알아볼 수 있게 색을 입혔어요.\n--include-only 옵션으로, src 경로에서만 의존성을 파악하도록 했어요. (node_modules 제외)\n\n이렇게 생성된 의존성 그래프를 보면, Card 컴포넌트가 사용되고 있는 페이지를 한눈에 파악할 수 있어요. 이제는 스크립트 한번 실행하는 것만으로 파일을 하나하나 찾아볼 시간이 절약되었고, 덤으로 DashLayout, SettingsLayout는 아무 페이지에서도 안 쓰고 있다는 것을 발견했네요.\n또한 실무에서 협업할 때도 확실한 이점을 느꼈는데요. 본 작업 전에 코드 리팩토링 작업이 필요하다는 사실을 비개발 직군 팀원들에게 설득할 때, 복잡하게 그려진 의존성 그래프를 보여주면 문제를 더 직관적으로 이해시킬 수 있게 됐어요.\nTop-Down: 이 컴포넌트가 어떤 파일에 영향받는지 궁금해.\n앞에서는 특정 파일이 ‘어디에 사용되는지’에 대한 궁금증을 해소하기 위해 의존성 그래프의 도움을 받았어요. 이번에는 특정 파일이 ‘무엇을 사용하는지’ 궁금한 경우에 대해서 이야기해보려고 해요.\n대표적으로 프로젝트에서 처음 수정해 보는 페이지를 마주치게 된다면, 다음과 같은 생각이 자연스럽게 따라 나오는 것 같아요.\n👨‍💻(엔지니어) : DashBoard 페이지는 처음 건드려보는데, 얼마나 복잡한 페이지일까?\nDashBoard 페이지를 작업하기 전에 예상 소요 시간을 파악하기 위해서는 주요 파일들을 한번 훑어보는 과정이 반드시 필요하죠. 의존성 그래프를 도입하기 전후로 이 과정에 어떤 변화가 있었는지 소개드려볼게요.\nBefore: 코드를 보고 눈대중으로 중요한 부분만 파악했어요\n일단 pages/Dashboard.tsx 에 들어가서 코드를 훑어본 다음, 중요해 보이는 컴포넌트나 훅이 있다면 해당 파일로 가서 세부 구현을 살펴봐요.\n그렇게 들어간 파일에서도 핵심 로직을 집중적으로 보고, 나머지 코드에서도 중요해 보이는 파일이 있다면 또 넘어가서 보는 것을 반복했어요. 이 페이지가 가진 복잡도가 어느 정도인지 눈대중으로 감을 얻어갔죠.\n이 과정에서 느낀 불편함은 다음과 같아요.\n\n시간 소모 : 복잡한 페이지일수록 수십 개의 컴포넌트를 일일이 확인해야 하는데, 많게는 몇 시간까지 소요돼요. 게다가 중간중간 질문을 받거나 회의를 다녀오면 집중이 끊기기 때문에 더 많은 시간을 필요로 해요.\n중복 파악 / 누락 가능성 : 중첩된 컴포넌트 구조에서는 일부를 놓치거나 봤던 파일을 또 보기 쉬워요. 또한 추상화로 인해 숨겨진 내부 동작을 모르고 어림짐작으로 넘어간다면, 작업할 때 뒤늦게 발견되는 코드로 인해 일정에 변수가 생기기도 해요.\n일정 산정의 근거 미약 : 이렇게 파악한 결론은 ‘복잡한 것 같다는 감’이기 때문에, “이 페이지는 다른 데보다 조금 더 복잡해서 일정이 더 필요할 거 같아요” 정도의 두루뭉술한 소통이 일어날 수 있어요. 일정이 지연됐을 때 “막상 작업하다 보니 생각보다 더 복잡해서 일정이 조금 더 필요해요”라고 변명하는 모습은 제가 생각하는 좋은 엔지니어의 모습은 아니었어요.\n\nAfter: 하위 의존성을 시각화해, 파일들의 복잡도를 한눈에 파악해요\nDependency Cruiser는 기본적으로 Top-Down 시각화를 지원해요.\n다음 옵션들과 함께 Dependency Cruiser 스크립트 실행하면 이런 그래프를 그릴 수 있어요.\n\ndepcruise src/pages/Dashboard.tsx : 타겟 경로로 Dashboard 파일을 지정하여 Dashboard 페이지 하위 의존성만 그리도록 했어요.\n--highlight : 대시보드 페이지만 강조하도록 했어요.\n--collapse : node_modules에 있는 라이브러리는 최상위 폴더만 보이도록 설정했어요.\n\n이렇게 Top-Down 방향으로 하위 의존성을 시각화해 보면, Dashboard 페이지 하위에 어떤 파일들이 연관되어 있는지와 얼마나 복잡하게 의존하고 있는지를 한눈에 볼 수 있어요.\n의존성 그래프로 인해 앞서 말했던 불편함들이 이렇게 해결돼요.\n\n시간 절약 : Dashboard 페이지 하위의 파일들을 한눈에 보고, 내가 모르는 부분과 이미 아는 부분을 빠르게 솎아낼 수 있어요. 파악할 코드를 추려내기 위해 위에서부터 하나하나 파일을 타고 내려갈 필요 없이 스크립트를 돌리는 몇 초만 소요하면 돼요.\n중복 파악 / 누락 가능성 감소 : 파일과 코드를 일일이 텍스트로 보지 않고 관련 파일을 펼쳐놓고 보기 때문에, 봤던 파일을 또 보거나 못 보고 넘어갈 확률이 줄어요.\n일정 산정의 근거로 활용 : 개발자만 느끼는 ‘복잡도’라는 개념을 시각적으로 보여주면 비개발자도 쉽게 이해할 수 있어요. 왜 A 페이지를 수정하는 게 왜 B 페이지보다 오래 걸리는지 직관적으로 설명할 수 있어요. 그리고 리팩토링은 복잡도를 낮춰 생산성을 올리는 행위라는 걸 AS-IS / TO-BE로 비교하며 보여줄 수도 있어요.\n\nCode Review: Pull Request에 의존성 그래프 추가\n이번에는 코드리뷰 시점에 의존성 그래프를 적용한 시도를 소개해볼게요.\nGithub Actions를 이용해 Pull Request에 포함된 File Changes를 기준으로 영향이 가는 범위를 시각화하는 스크립트를 추가했어요. 이 작업으로 인해 저장소에 기여자의 PR이 올라오면, 다음과 같은 시각화가 자동으로 달리게 돼요.\n실제 Pull Request에 생성된 의존성 그래프\n기존에는 다른 개발자의 코드를 리뷰할 때 파일 하나, 코드 한 줄이라는 텍스트에 집중했다면, 의존성 시각화를 통해 이 사람이 얼마나 큰 작업을 했는지, 수정한 파일의 사이드 이펙트가 얼마나 큰지를 알 수 있게 되었어요.\n또한 의존성 그래프가 있으면 리뷰어는 다음과 같은 코드리뷰를 통해서 코드베이스 전체의 복잡도까지 관리할 수 있게 돼요.\n🧑‍💻(리뷰어) : X 파일 수정하셨는데, 작업과 관련 없는 A/B/C 페이지에도 영향이 가는 것 같아요. 예상치 못한 사이드 이펙트가 없도록 리팩토링 먼저 하고 변경사항 적용하면 어떨까요?\nTeam: 프로젝트 전체 구조 한눈에 훑어보기\n프로젝트의 신규 기여자를 온보딩할 때, 일반적으로 코드를 살펴보는 시간을 충분히 가지게 하죠.\n매일 많은 변경이 일어나는 거대한 프로젝트를 제대로 이해하려면, 그 어떤 문서보다 실제로 돌아가는 코드를 확인하는 게 중요해요. 하지만 수천 개의 파일이 담긴 프로젝트 폴더를 열어보는 순간 어디서부터 봐야 할지 막막해지죠.\n이런 막막함을 느껴본 적이 있으시다면 프로젝트 전체를 의존성 그래프로 그려서 지도처럼 표현해 보는 방식을 소개드려요. 다음과 같은 그림이나 스크립트를 기여 문서에 추가한다면, 처음 기여하는 사람들이 조금 더 원활하게 온보딩할 수 있어요.\n예제 프로젝트의 전체 의존성 그래프\n기본적으로 depcruise src 로 전체 소스코드를 대상으로 그래프를 그릴 수 있고, Depedency Cruiser 옵션을 더 다양하게 알아보고 건드리면서 필요한 수준으로 조정하시는 걸 추천드려요.\n\n--output-type ddot로 폴더 단위로 그래프를 그려 폴더 구조만 표현할 수 있어요.\n특정 범위의 파일만 보고 싶다면 --include-only로 원하는 영역만 시각화할 수 있어요.\nRule을 사용하면 순환 참조나 폴더 구조에 대한 규칙을 Lint처럼 걸어두고, 이를 위반한 경우에는 의존성 그래프에 화살표를 강조하는 등의 안내를 줄 수 있어요.\n\n결론\n의존성 그래프를 활용해 프로젝트 시각화한 후, 코드를 파악하느라 정처 없이 여기저기 파일을 열어보며 돌아다니는 시간이 거의 사라졌어요.\n사이드 프로젝트가 아닌 회사 프로젝트에서, 대부분의 개발자는 관리하고 있는 코드의 첫 번째 기여자가 아닌 경우가 많아요. 따라서 코드를 작성하는 것보다 파악하는 시간이 훨씬 길어질 수 있어요.\n특히나 제가 당근에서 마주친 코드들은 엔지니어링과 프로덕트 경험 양면에서의 치열한 고민 흔적들이 많이 묻어있었어요. 지금도 옆에서 다양한 고민을 함께 나누고 시도하는 동료들이 있기 때문에 파악할 코드는 더더욱 빠르게 늘어나고 있고요.\nCopilot, Cursor 등의 AI 도구들이 발전하면서 코드 작성에 대한 생산성은 빠르게 개선되고 있다고 생각하는데요. 이번 글을 읽으신 분들께서는 의존성 시각화라는 도구를 통해 코드를 파악하는 데에 드는 시간까지 줄여서, 더 빠른 실행과 좋은 프로덕트를 만들어가는 데 조금이라도 도움이 되셨으면 좋겠습니다!\n\n의존성 그래프를 활용한 프로젝트 시각화 — 사이드 이펙트 한눈에 파악하기 was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "identity16",
        "guid": "https://medium.com/p/eec17d5aabb2",
        "categories": [
          "programming",
          "dependency-graph",
          "productivity"
        ],
        "isoDate": "2025-04-10T06:26:29.000Z"
      },
      {
        "creator": "Lebron J",
        "title": "Feed-Entity: 당근 피드의 심장",
        "link": "https://medium.com/daangn/feed-entity-%EB%8B%B9%EA%B7%BC-%ED%94%BC%EB%93%9C%EC%9D%98-%EC%8B%AC%EC%9E%A5-e2ba0a7f57fa?source=rss----4505f82a2dbd---4",
        "pubDate": "Thu, 03 Apr 2025 06:05:58 GMT",
        "content:encoded": "<p>안녕하세요. 저는 당근 피드인프라팀에서 Software Engineer로 일하고 있는 Lebron이라고 해요.</p><p>피드인프라팀은 하루에 수백만 명의 사용자들이 당근 앱을 열었을 때 가장 먼저 마주하게 되는 피드 경험을 담당해요. 각 사용자의 관심사에 맞는 맞춤형 콘텐츠를 적절한 위치에 제공하기 위해 복잡한 피드 시스템을 운영하며, 대규모 트래픽을 안정적으로 처리하기 위한 인프라를 구축하고 있어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NzOkY-yE5l8JKcV0-LmT2g.png\" /><figcaption>중고차, 부동산 등 다양한 콘텐츠가 있는 피드</figcaption></figure><p>위 이미지와 같이 당근의 피드에는 다양한 콘텐츠가 존재하며, 이들은 여러 맥락으로 연결되어 서빙돼요.</p><p>피드인프라팀은 다양한 콘텐츠를 서빙하면서 “어떻게 하면 더 일관성 있게 데이터를 저장하고 활용할 수 있을까?”라는 고민을 여러 번 마주했어요. Feed-Entity는 바로 그 고민에서 시작한 프로젝트예요. Feed-Entity는 단순히 데이터 구조를 표준화하는 것을 넘어서, 당근의 피드 시스템이 더욱 확장 가능하고 유연한 형태로 발전하도록 했어요. 덕분에 피드에 새로운 서비스를 더 빠르게 통합하고, 사용자들에게 더 다양하고 풍부한 콘텐츠를 제공할 수 있었어요.</p><p>지금부터 Feed-Entity가 어떻게 탄생했는지, 그리고 이를 통해 어떤 문제들을 해결했는지 이야기해 드릴게요.</p><h3>Feed-Entity의 탄생</h3><p>Feed-Entity가 등장하기 전, 피드 시스템은 다소 분산된 형태로 운영되었어요. 당근 내 여러 서비스(중고거래, 중고차, 당근알바 등)가 각자의 콘텐츠를 피드에 노출시키기 위해 독립적인 저장소를 운영하거나, 피드 시스템과의 직접적인 연동을 통해 데이터를 제공했어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*T8r-PqOv2jkZDszdjhtWeA.png\" /><figcaption>Feed-Entity 등장 이전 피드 시스템</figcaption></figure><p>예를 들어 중고거래 서비스는 자체 데이터베이스에 상품 정보를 저장하고 있었고, 알바 서비스는 별도의 저장소에 구인구직 정보를 보관했어요. 피드 시스템은 여러 저장소에서 데이터를 가져와 사용자에게 보여주는 역할을 했어요.</p><p>이런 구조는 초기에는 단순하고 직관적이었어요. 그러나 당근의 서비스가 다양해지고 규모가 커지면서 여러 가지 한계점을 드러내기 시작했어요. 각 서비스마다 데이터 구조와 저장 방식이 달랐고, 새로운 서비스를 피드에 추가할 때마다 많은 통합 작업이 필요했어요.</p><p>이러한 문제들을 해결하기 위해 우리는 Feed-Entity라는 개념을 도입했어요. Feed-Entity를 통해 이루고자 했던 목표들은 다음과 같아요.</p><ul><li>데이터 구조의 표준화: 각 서비스마다 달랐던 데이터 구조와 통신 방식을 표준화하여 시스템 간 일관된 인터페이스를 제공하고 싶었어요.</li><li>시스템 확장성 개선: 새로운 서비스를 피드에 더 쉽고 빠르게 추가할 수 있게 만들고 싶었어요.</li><li>데이터 일관성 확보: 다양한 콘텐츠를 더 일관성 있게 다루고 싶었어요.</li><li>통합 관리 시스템 구축: 중고거래, 알바, 중고차, 부동산, 동네생활 등 모든 서비스의 콘텐츠를 한 곳에서 관리하고 싶었어요.</li><li>사용자 경험 향상: 결과적으로 사용자들에게 더 다양하고 풍부한 콘텐츠를 보여주고 싶었어요.</li></ul><h3>Feed-Entity: Single Source of Truth for Feed System</h3><p>Feed-Entity는 피드에서 노출 가능한, 당근 내에서 발행할 수 있는 가장 작은 단위의 콘텐츠로, 피드 시스템 안에서의 Single Source of Truth(SSOT)로 정의한 단위를 의미해요.</p><ul><li>콘텐츠 자체를 나타내는 요소들만 Feed-Entity에 정의해요.</li><li>중고거래 게시글, 동네생활* 게시글, 동네생활 댓글, 비즈프로필** 등이 Feed-Entity가 될 수 있어요.</li><li>사진, 텍스트, 관심 수나 채팅 수와 같은 속성은 Feed-Entity가 될 수 없어요.</li></ul><blockquote><em>💡</em> *동네생활: 동네에 대한 이야기와 정보를 나눌 수 있는 커뮤니티<br><em>💡</em> **비즈프로필: 동네 업체에 대한 정보를 담고 있는 프로필</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/950/1*6525aP0EqMml9NtYlf7WLA.png\" /><figcaption>Feed-Entity로 변환되는 예시</figcaption></figure><p>위 그림처럼 다양한 콘텐츠(중고거래, 알바, 부동산 등)를 Feed-Entity라는 가공된 형태로 변환하여 저장하게 돼요. Feed-Entity는 기본적으로 다음과 같은 구성 요소를 가져요.</p><ul><li>ID: Feed-Entity를 고유하게 구분할 수 있는 식별자예요.</li><li>타입: 중고거래, 알바, 동네생활 등 어떤 종류의 콘텐츠인지를 나타내요.</li><li>소스 정보: SourceContent*의 출처와 관련된 정보를 담아요.</li><li>생성자: 콘텐츠를 작성한 사용자에 대한 정보를 담아요.</li><li>생성/수정/노출 시간: 콘텐츠가 언제 만들어지고 수정되었는지에 대한 정보를 나타내요.</li><li>상태: Feed-Entity가 생성되었는지, 노출 중인지, 미노출 상태인지와 같은 상태 정보를 나타내요.</li><li>Entity: 변환된 콘텐츠 정보를 담아요.</li></ul><p>Feed-Entity는 이러한 표준화된 구조를 통해 다양한 서비스의 콘텐츠를 일관되게 관리할 수 있게 했어요. 덕분에 새로운 서비스를 피드에 통합하는 과정이 훨씬 간단해졌고, 개발자들은 데이터 구조보다는 비즈니스 로직에 더 집중할 수 있게 되었어요.</p><blockquote><em>💡</em> *SourceContent: Feed-Entity로 변환하기 전의 원본 콘텐츠 데이터</blockquote><h3>Feed-Entity Data Pipeline</h3><p>Feed-Entity의 데이터 파이프라인은 콘텐츠 제공자(Content Provider)로부터 데이터를 수집하고, 이를 Feed-Entity 형태로 변환하여 저장하는 과정을 담당해요. 이 파이프라인은 크게 데이터 수집, 변환, 저장의 단계로 구성돼요. 각 단계는 모듈화되어 있어 새로운 콘텐츠 타입이 추가되더라도 전체 시스템을 수정하지 않고 해당 모듈만 추가하면 되는 유연한 구조를 가져요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*n4QAs9mfEbTMeJCFn2JRnQ.png\" /><figcaption>Feed-Entity 데이터 파이프라인</figcaption></figure><p>위 이미지는 Feed-Entity의 데이터 파이프라인을 상세하게 보여주고 있어요. 이 파이프라인은 크게 네 단계로 구성되어 있는데, 각 단계별로 자세히 살펴보겠습니다.</p><h4>1. 데이터 수집</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*eB7HXxELvL4h7pWuA6UyHw.png\" /><figcaption>데이터 수집 흐름</figcaption></figure><p>첫 번째 단계는 데이터 수집 과정이에요. 중고거래, 알바, 동네생활, 부동산 등 여러 서비스에서 생성된 원본 데이터가 Feed-Entity 시스템으로 유입됩니다. 각 서비스마다 데이터 구조와 형식이 다르기 때문에, 이 단계에서는 다양한 형태의 데이터를 처리할 수 있는 유연한 수집 메커니즘이 필요해요.</p><p>Feed-Entity 시스템은 이러한 유연한 수집 메커니즘을 위해 데이터 유형별로 별도의 큐를 운영해요. 각 큐에서 데이터를 처리할 때는 멱등성(Idempotency)을 보장하도록 설계했어요. 덕분에 같은 SourceContent가 여러 번 전달되더라도 단 한 번만 처리돼요. 또한 실시간 데이터 스트림을 통해 새로운 콘텐츠나 업데이트된 콘텐츠를 지속적으로 수집하여 사용자에게 항상 최신 정보를 제공할 수 있어요.</p><h4>2. 데이터 변환</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cnMvdXJSPcMOHPKcHB3_7Q.png\" /><figcaption>데이터 변환 흐름</figcaption></figure><p>두 번째 단계는 수집된 다양한 형태의 데이터를 표준화된 Feed-Entity 형식으로 변환하는 과정이에요. 이 과정에서 각 콘텐츠 타입에 맞는 변환 로직이 적용돼요. 예를 들어 중고거래 게시글은 상품 정보, 가격, 위치 등의 필드를 가지는 반면, 동네생활 게시글은 본문 내용, 카테고리, 댓글 수 등 다른 구조를 가져요. 변환 단계에서는 이러한 다양한 구조의 데이터들을 공통 필드(ID, 타입, 생성 시간 등)를 가진 Feed-Entity라는 통일된 형식으로 래핑하면서도, 각 콘텐츠의 고유한 특성은 Entity 필드 내부에 보존하여 변환해요.</p><p>변환된 Feed-Entity 데이터는 별도의 저장소에 저장되어 피드 시스템 전체에서 일관되게 접근할 수 있게 돼요. 모듈화된 시스템 구조 덕분에 새로운 콘텐츠 타입이 추가되더라도, 전체 시스템을 수정하지 않고 해당 모듈만 추가하면 되는 유연한 구조를 갖추고 있어요. 이는 시스템의 확장성을 크게 향상시키고, 새로운 서비스를 빠르게 통합할 수 있게 해주는 핵심 장점이에요.</p><h4>3. 데이터 검증 및 DLQ 처리</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tICI53T-E8vdH5iFyAvzHg.png\" /><figcaption>데이터 검증 및 DLQ 처리 흐름</figcaption></figure><p>세 번째 단계는 데이터 검증 과정이에요. SourceContent나 Feed-Entity 데이터가 검증에 실패할 경우, 해당 데이터는 Dead Letter Queue(DLQ)로 이동하게 돼요. DLQ는 처리에 실패한 메시지를 저장해 두는 특별한 큐로, 이를 통해 데이터 손실 없이 나중에 다시 처리할 수 있게 해요.</p><p>예를 들어 원본 데이터의 형식이 변경되었거나 필수 필드가 누락되었을 때, 데이터 변환 과정에서 오류가 발생할 수 있어요. 이런 경우 해당 데이터는 DLQ로 이동하고, 개발자들은 오류의 원인을 분석한 후 필요한 수정을 거쳐 데이터를 다시 처리할 수 있어요. 이러한 메커니즘을 통해 시스템의 안정성을 높이고, 데이터 무결성을 보장했어요.</p><p>또한 DLQ 시스템은 문제가 발생한 데이터를 자동으로 모니터링하고 알림을 보내는 기능도 포함하고 있어요. 이를 통해 개발팀이 빠르게 문제를 인지하고 대응할 수 있게 되었어요. 이는 데이터 파이프라인의 신뢰성을 높이고, 장애 상황에서도 데이터 손실을 최소화할 수 있게 했어요.</p><h4>4. 메시지 큐 프로듀스 및 서비스 간 연동</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Fopd_bQJ5-GsKENZalG9Zw.png\" /><figcaption>메시지 생성 및 서비스 간 연동 흐름</figcaption></figure><p>마지막 단계는 변환된 Feed-Entity 데이터를 별도의 메시지 큐에 프로듀스(Produce)하는 과정이에요. 이를 통해 피드 시스템 외의 다른 서비스들도 이 표준화된 데이터를 활용할 수 있게 되었어요. 다양한 내부 서비스들이 Feed-Entity를 구독(Subscribe)하여 필요한 정보를 실시간으로 받아볼 수 있게 되었어요. 이런 구조는 서비스 간 데이터 일관성을 유지하고, 각 서비스가 독립적으로 발전할 수 있는 기반이 되었어요.</p><p>또한 처음 Feed-Entity 시스템을 도입할 때는 콜드 스타트(Cold Start) 문제를 해결하기 위한 백필(Backfill) 기능도 중요했어요. 백필은 기존에 존재하던 콘텐츠들을 새로운 Feed-Entity 형식으로 변환하여 시스템에 채워 넣는 과정이에요. 이 과정을 통해 새 시스템을 도입하는 순간부터 충분한 양의 데이터를 확보하고, 사용자들에게 풍부한 콘텐츠를 제공할 수 있었어요.</p><p>이러한 메시지 큐 기반의 아키텍처는 시스템 간 느슨한 결합(Loose Coupling)을 가능하게 하여, 각 서비스가 독립적으로 개발, 배포, 확장될 수 있게 해요. 또한 비동기 처리 방식을 통해 시스템의 부하를 분산시키고, 전체 시스템의 안정성과 확장성을 높이는 데 크게 기여해요.</p><h3>Feed-Entity Serving Flow</h3><p>Feed-Entity를 잘 저장한 것만큼 이를 효율적으로 서빙하는 것도 정말 중요해요. 특히 피드는 쓰기보다 읽기 트래픽이 훨씬 많다는 특성이 있어서, 읽기에 최적화된 구조로 데이터를 저장하고 적절한 캐싱 전략을 설계하는 것이 필수예요.</p><p>피드인프라팀에서는 Feed-Entity 데이터를 효율적으로 서빙하기 위해 지역별 특성을 고려한 Redis 캐싱 전략을 구현했어요. Feed-Entity는 지역성이 강한 특징이 있기 때문에, 지역별로 다른 캐시를 구성하여 데이터 접근 속도를 크게 향상시켰어요. 사용자가 특정 지역의 피드를 요청하면, 해당 지역에 최적화된 캐시에서 데이터를 빠르게 가져와요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZBMVSOxXD8_2sl5S81LjDw.png\" /><figcaption>Feed-Entity 서빙 흐름</figcaption></figure><p>Feed-Entity 서빙 시스템은 효율적인 데이터 접근을 위해 다단계 저장 및 조회 구조를 갖추고 있어요. 이 시스템은 크게 Redis 캐싱 레이어와 데이터베이스 저장소의 두 계층으로 구성되어 있어요.</p><h4>데이터 저장 프로세스</h4><p>Feed-Entity가 생성되거나 업데이트되면, 다음과 같은 과정을 거쳐요:</p><ul><li><strong>데이터베이스 저장:</strong> 모든 Feed-Entity는 우선 영구 저장소인 데이터베이스에 저장됩니다. 이는 데이터의 영구성과 내구성을 보장하기 위함이에요.</li><li><strong>인덱스 생성:</strong> 저장과 동시에 해당 Feed-Entity의 메타데이터와 지역 정보를 포함한 인덱스가 생성됩니다. 이 인덱스는 빠른 검색과 필터링을 위한 핵심 자료구조예요.</li><li><strong>레디스 캐시 업데이트:</strong> 생성된 인덱스는 지역별로 구분된 Redis 캐시에 저장됩니다. 각 지역마다 별도의 캐시 버킷을 유지하여 지역 기반 쿼리의 성능을 최적화했어요.</li></ul><h4>데이터 조회 프로세스</h4><p>사용자가 특정 지역의 피드를 요청하면, 시스템은 다음과 같은 단계로 데이터를 효율적으로 조회해요:</p><ul><li><strong>캐시 조회 (Cache Hit):</strong> 먼저 해당 지역의 Redis 캐시에서 인덱스를 조회합니다. 이때 인덱스에는 Feed-Entity ID와 기본 메타데이터만 포함되어 있어 메모리 사용을 최소화하면서도 빠른 응답 속도를 제공해요.</li><li><strong>데이터베이스 조회 최소화:</strong> 캐시에서 인덱스를 찾으면(Cache Hit), 해당 인덱스를 기반으로 필요한 Feed-Entity만 선택적으로 캐시 혹은 데이터베이스에서 가져옵니다. 이를 통해 전체 데이터베이스 스캔 없이도 필요한 데이터만 효율적으로 접근할 수 있어요.</li><li><strong>캐시 미스 처리 (Cache Miss):</strong> 만약 캐시에서 해당 지역의 인덱스를 찾지 못하면(Cache Miss), 시스템은 데이터베이스를 직접 조회하여 필요한 Feed-Entity를 검색해요.</li></ul><h4>성능 최적화</h4><p>이러한 다층 구조는 여러 성능 이점을 가져왔어요:</p><ul><li><strong>읽기 트래픽 최적화:</strong> 피드 시스템은 특성상 쓰기보다 읽기 작업이 압도적으로 많은데, 인덱스 기반 캐싱을 통해 읽기 성능을 크게 향상시켰어요.</li><li><strong>지역별 부하 분산:</strong> 지역별로 별도의 캐시를 관리함으로써 특정 지역의 트래픽이 증가하더라도 다른 지역의 성능에 영향을 미치지 않도록 했어요.</li></ul><p>이렇게 설계된 Feed-Entity 서빙 시스템은 수백만 사용자의 지역 기반 피드 요청을 매우 낮은 지연 시간(p99 기준 평균 20ms 이하)으로 처리해요. 특히 사용자가 많은 대도시 지역에서도 안정적인 성능을 유지하며 사용자 경험을 크게 개선했어요.</p><h3>Feed-Entity의 장점과 효과</h3><p>Feed-Entity를 도입하면서 저희 팀은 여러 가지 중요한 개선 효과를 얻을 수 있었어요. 앞서 Feed-Entity를 통해 이루고 싶은 목표를 다섯 가지 측면에서 정리했었는데요. 각 측면에서 경험한 구체적인 장점들은 아래와 같아요.</p><ul><li><strong>데이터 구조의 표준화:</strong> 이전에는 서로 다른 형식의 데이터를 처리하기 위해 각 서비스마다 별도의 로직이 필요했지만, Feed-Entity를 통해 모든 콘텐츠를 일관된 형식으로 관리하면서 개발 복잡성이 크게 줄어들었어요.</li><li><strong>시스템 확장성 개선:</strong> 기존에는 새로운 콘텐츠 타입을 추가할 때마다 피드 시스템 전체를 수정해야 했지만, Feed-Entity 도입 후에는 해당 콘텐츠에 대한 변환 모듈만 추가하면 되는 구조가 되었어요. 이런 유연한 아키텍처 덕분에 빠르게 변화하는 비즈니스 요구사항에 신속하게 대응할 수 있게 되었어요.</li><li><strong>데이터 일관성 확보:</strong> DLQ 처리 메커니즘을 통해 데이터 손실 없이 오류 상황을 효과적으로 관리하고, 표준화된 스키마를 통해 데이터 품질을 일관되게 유지할 수 있어요. 이는 서비스 안정성 향상과 운영 부담 감소로 이어졌어요.</li><li><strong>통합 관리 시스템 구축:</strong> 서비스 간 연동이 훨씬 용이해졌어요. Feed-Entity를 통해 이제는 한 곳에서 모든 콘텐츠를 관리할 수 있어요. 새로운 서비스를 추가하거나 기존 서비스를 수정할 때, 표준화된 인터페이스 덕분에 전체 시스템에 미치는 영향이 최소화되었어요. 이런 구조적 이점은 개발 속도와 효율성을 크게 향상시켰고, 팀 간 협업도 더 원활하게 만들었어요.</li><li><strong>사용자 경험 향상:</strong> 다양한 콘텐츠 타입(중고거래, 알바, 부동산, 동네생활 등)을 통합적으로 관리하게 되면서, 사용자에게 더 풍부하고 개인화된 피드 경험을 제공할 수 있어요. 사용자의 관심사와 위치에 기반한 맞춤형 콘텐츠를 보여줄 수 있게 되었어요.</li></ul><p>이러한 여러 장점들이 모여 피드 시스템은 Feed-Entity를 통해 더 안정적이고, 확장 가능한 시스템을 구축할 수 있었어요.</p><h3>Feed-Entity NEXT</h3><p>Feed-Entity는 현재 당근의 피드 시스템에서 핵심적인 역할을 담당하고 있지만, 아직 해결해야 할 여러 과제가 있어요. 지속적인 사용자 증가와 함께 콘텐츠의 다양성도 늘어나면서, 데이터 처리 효율성과 확장성에 대한 새로운 요구사항이 계속해서 등장하고 있어요. 또한 사용자별 맞춤형 경험을 더욱 세밀하게 제공하기 위해서는 Feed-Entity 시스템의 고도화가 필요한 상황이에요. 이러한 도전 과제들을 해결하기 위해 저희 팀은 다음과 같은 방향으로 개선을 계획하고 있어요.</p><ul><li><strong>복합적 인덱싱 전략:</strong> 현재는 단순히 최신순 지역별 큐만 가지고 있지만, 이것만으로는 다양한 요구를 충족시키기에 부족해요. 향후에는 거리순, 카테고리별, 인기도별, 최신순 등 다양한 인덱싱 전략을 구현하여 멀티 큐 시스템을 운영할 필요성이 있어요. 이를 통해 사용자가 원하는 방식으로 콘텐츠를 빠르게 탐색할 수 있게 될 거예요. 특히 지리적 거리에 따른 인덱싱은 하이퍼로컬 서비스인 당근의 특성을 더욱 강화할 수 있는 중요한 요소예요. 또한 카테고리별 인덱싱은 사용자가 관심 있는 특정 영역의 콘텐츠만 효율적으로 찾을 수 있게 도와줄 거예요. 이러한 복합적 인덱싱 전략을 구현함으로써 Feed-Entity의 서빙 속도와 정확도를 크게 향상시킬 수 있을 것으로 기대해요.</li><li><strong>추천 모델학습 활용:</strong> Feed-Entity는 아직 추천 시스템 전반에 적용되지 않아요. 이를 추천 모델 학습과 서빙에 활용한다면, 사용자별 선호도 예측의 정확도를 높이고 개인화된 피드 경험을 제공할 수 있을 것이에요. 또한 통일된 데이터 구조를 기반으로 ML 파이프라인을 구축하면 모델 업데이트와 학습 프로세스를 더욱 효율적으로 관리할 수 있을 거라 기대돼요.</li><li><strong>탐색 시스템의 SSOT 확장:</strong> 현재 Feed-Entity는 해시태그 시스템과 추천 알림에서 SSOT(Single Source of Truth)로 성공적으로 활용되고 있어요. 이러한 성공을 바탕으로 더 많은 시스템으로 Feed-Entity의 활용 범위를 확장할 계획이에요. 이를 통해 전체 서비스에서 일관된 데이터 구조와 높은 신뢰성을 확보할 수 있을 것으로 기대돼요.</li></ul><p>이러한 과제들을 해결하여 Feed-Entity를 추천 전반에 활용할 수 있게 된다면, 당근의 피드 시스템은 한 단계 더 발전된 형태로 사용자들에게 가치 있는 경험을 제공할 수 있을 것이라고 믿어요.</p><h3>마치며…</h3><p>이렇게 피드라는 복잡한 문제를 해결하기 위해 Feed-Entity라는 개념을 도입하고 발전시켜 온 피드인프라팀. 저희는 항상 더 나은 기술과 사용자 경험을 위해 끊임없이 도전하고 있어요. 혹시 이런 기술적 도전에 함께하고 싶으신가요? 당근 피드인프라팀에서는 수백만 명의 사용자들에게 하이퍼로컬 가치 있는 정보를 효율적으로 전달하기 위한 기술을 개발하고 다양한 실험에 도전할 열정적인 동료를 찾고 있어요.</p><p>당근 피드인프라팀과 함께 하이퍼로컬 피드 경험을 만들어 갈 동료를 기다립니다.</p><p>당근마켓 채용 페이지: <a href=\"https://team.daangn.com/jobs/\">https://team.daangn.com/jobs/</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e2ba0a7f57fa\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/feed-entity-%EB%8B%B9%EA%B7%BC-%ED%94%BC%EB%93%9C%EC%9D%98-%EC%8B%AC%EC%9E%A5-e2ba0a7f57fa\">Feed-Entity: 당근 피드의 심장</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "안녕하세요. 저는 당근 피드인프라팀에서 Software Engineer로 일하고 있는 Lebron이라고 해요.\n피드인프라팀은 하루에 수백만 명의 사용자들이 당근 앱을 열었을 때 가장 먼저 마주하게 되는 피드 경험을 담당해요. 각 사용자의 관심사에 맞는 맞춤형 콘텐츠를 적절한 위치에 제공하기 위해 복잡한 피드 시스템을 운영하며, 대규모 트래픽을 안정적으로 처리하기 위한 인프라를 구축하고 있어요.\n중고차, 부동산 등 다양한 콘텐츠가 있는 피드\n위 이미지와 같이 당근의 피드에는 다양한 콘텐츠가 존재하며, 이들은 여러 맥락으로 연결되어 서빙돼요.\n피드인프라팀은 다양한 콘텐츠를 서빙하면서 “어떻게 하면 더 일관성 있게 데이터를 저장하고 활용할 수 있을까?”라는 고민을 여러 번 마주했어요. Feed-Entity는 바로 그 고민에서 시작한 프로젝트예요. Feed-Entity는 단순히 데이터 구조를 표준화하는 것을 넘어서, 당근의 피드 시스템이 더욱 확장 가능하고 유연한 형태로 발전하도록 했어요. 덕분에 피드에 새로운 서비스를 더 빠르게 통합하고, 사용자들에게 더 다양하고 풍부한 콘텐츠를 제공할 수 있었어요.\n지금부터 Feed-Entity가 어떻게 탄생했는지, 그리고 이를 통해 어떤 문제들을 해결했는지 이야기해 드릴게요.\nFeed-Entity의 탄생\nFeed-Entity가 등장하기 전, 피드 시스템은 다소 분산된 형태로 운영되었어요. 당근 내 여러 서비스(중고거래, 중고차, 당근알바 등)가 각자의 콘텐츠를 피드에 노출시키기 위해 독립적인 저장소를 운영하거나, 피드 시스템과의 직접적인 연동을 통해 데이터를 제공했어요.\nFeed-Entity 등장 이전 피드 시스템\n예를 들어 중고거래 서비스는 자체 데이터베이스에 상품 정보를 저장하고 있었고, 알바 서비스는 별도의 저장소에 구인구직 정보를 보관했어요. 피드 시스템은 여러 저장소에서 데이터를 가져와 사용자에게 보여주는 역할을 했어요.\n이런 구조는 초기에는 단순하고 직관적이었어요. 그러나 당근의 서비스가 다양해지고 규모가 커지면서 여러 가지 한계점을 드러내기 시작했어요. 각 서비스마다 데이터 구조와 저장 방식이 달랐고, 새로운 서비스를 피드에 추가할 때마다 많은 통합 작업이 필요했어요.\n이러한 문제들을 해결하기 위해 우리는 Feed-Entity라는 개념을 도입했어요. Feed-Entity를 통해 이루고자 했던 목표들은 다음과 같아요.\n\n데이터 구조의 표준화: 각 서비스마다 달랐던 데이터 구조와 통신 방식을 표준화하여 시스템 간 일관된 인터페이스를 제공하고 싶었어요.\n시스템 확장성 개선: 새로운 서비스를 피드에 더 쉽고 빠르게 추가할 수 있게 만들고 싶었어요.\n데이터 일관성 확보: 다양한 콘텐츠를 더 일관성 있게 다루고 싶었어요.\n통합 관리 시스템 구축: 중고거래, 알바, 중고차, 부동산, 동네생활 등 모든 서비스의 콘텐츠를 한 곳에서 관리하고 싶었어요.\n사용자 경험 향상: 결과적으로 사용자들에게 더 다양하고 풍부한 콘텐츠를 보여주고 싶었어요.\n\nFeed-Entity: Single Source of Truth for Feed System\nFeed-Entity는 피드에서 노출 가능한, 당근 내에서 발행할 수 있는 가장 작은 단위의 콘텐츠로, 피드 시스템 안에서의 Single Source of Truth(SSOT)로 정의한 단위를 의미해요.\n\n콘텐츠 자체를 나타내는 요소들만 Feed-Entity에 정의해요.\n중고거래 게시글, 동네생활* 게시글, 동네생활 댓글, 비즈프로필** 등이 Feed-Entity가 될 수 있어요.\n사진, 텍스트, 관심 수나 채팅 수와 같은 속성은 Feed-Entity가 될 수 없어요.\n\n💡 *동네생활: 동네에 대한 이야기와 정보를 나눌 수 있는 커뮤니티\n💡 **비즈프로필: 동네 업체에 대한 정보를 담고 있는 프로필\nFeed-Entity로 변환되는 예시\n위 그림처럼 다양한 콘텐츠(중고거래, 알바, 부동산 등)를 Feed-Entity라는 가공된 형태로 변환하여 저장하게 돼요. Feed-Entity는 기본적으로 다음과 같은 구성 요소를 가져요.\n\nID: Feed-Entity를 고유하게 구분할 수 있는 식별자예요.\n타입: 중고거래, 알바, 동네생활 등 어떤 종류의 콘텐츠인지를 나타내요.\n소스 정보: SourceContent*의 출처와 관련된 정보를 담아요.\n생성자: 콘텐츠를 작성한 사용자에 대한 정보를 담아요.\n생성/수정/노출 시간: 콘텐츠가 언제 만들어지고 수정되었는지에 대한 정보를 나타내요.\n상태: Feed-Entity가 생성되었는지, 노출 중인지, 미노출 상태인지와 같은 상태 정보를 나타내요.\nEntity: 변환된 콘텐츠 정보를 담아요.\n\nFeed-Entity는 이러한 표준화된 구조를 통해 다양한 서비스의 콘텐츠를 일관되게 관리할 수 있게 했어요. 덕분에 새로운 서비스를 피드에 통합하는 과정이 훨씬 간단해졌고, 개발자들은 데이터 구조보다는 비즈니스 로직에 더 집중할 수 있게 되었어요.\n💡 *SourceContent: Feed-Entity로 변환하기 전의 원본 콘텐츠 데이터\nFeed-Entity Data Pipeline\nFeed-Entity의 데이터 파이프라인은 콘텐츠 제공자(Content Provider)로부터 데이터를 수집하고, 이를 Feed-Entity 형태로 변환하여 저장하는 과정을 담당해요. 이 파이프라인은 크게 데이터 수집, 변환, 저장의 단계로 구성돼요. 각 단계는 모듈화되어 있어 새로운 콘텐츠 타입이 추가되더라도 전체 시스템을 수정하지 않고 해당 모듈만 추가하면 되는 유연한 구조를 가져요.\nFeed-Entity 데이터 파이프라인\n위 이미지는 Feed-Entity의 데이터 파이프라인을 상세하게 보여주고 있어요. 이 파이프라인은 크게 네 단계로 구성되어 있는데, 각 단계별로 자세히 살펴보겠습니다.\n1. 데이터 수집\n데이터 수집 흐름\n첫 번째 단계는 데이터 수집 과정이에요. 중고거래, 알바, 동네생활, 부동산 등 여러 서비스에서 생성된 원본 데이터가 Feed-Entity 시스템으로 유입됩니다. 각 서비스마다 데이터 구조와 형식이 다르기 때문에, 이 단계에서는 다양한 형태의 데이터를 처리할 수 있는 유연한 수집 메커니즘이 필요해요.\nFeed-Entity 시스템은 이러한 유연한 수집 메커니즘을 위해 데이터 유형별로 별도의 큐를 운영해요. 각 큐에서 데이터를 처리할 때는 멱등성(Idempotency)을 보장하도록 설계했어요. 덕분에 같은 SourceContent가 여러 번 전달되더라도 단 한 번만 처리돼요. 또한 실시간 데이터 스트림을 통해 새로운 콘텐츠나 업데이트된 콘텐츠를 지속적으로 수집하여 사용자에게 항상 최신 정보를 제공할 수 있어요.\n2. 데이터 변환\n데이터 변환 흐름\n두 번째 단계는 수집된 다양한 형태의 데이터를 표준화된 Feed-Entity 형식으로 변환하는 과정이에요. 이 과정에서 각 콘텐츠 타입에 맞는 변환 로직이 적용돼요. 예를 들어 중고거래 게시글은 상품 정보, 가격, 위치 등의 필드를 가지는 반면, 동네생활 게시글은 본문 내용, 카테고리, 댓글 수 등 다른 구조를 가져요. 변환 단계에서는 이러한 다양한 구조의 데이터들을 공통 필드(ID, 타입, 생성 시간 등)를 가진 Feed-Entity라는 통일된 형식으로 래핑하면서도, 각 콘텐츠의 고유한 특성은 Entity 필드 내부에 보존하여 변환해요.\n변환된 Feed-Entity 데이터는 별도의 저장소에 저장되어 피드 시스템 전체에서 일관되게 접근할 수 있게 돼요. 모듈화된 시스템 구조 덕분에 새로운 콘텐츠 타입이 추가되더라도, 전체 시스템을 수정하지 않고 해당 모듈만 추가하면 되는 유연한 구조를 갖추고 있어요. 이는 시스템의 확장성을 크게 향상시키고, 새로운 서비스를 빠르게 통합할 수 있게 해주는 핵심 장점이에요.\n3. 데이터 검증 및 DLQ 처리\n데이터 검증 및 DLQ 처리 흐름\n세 번째 단계는 데이터 검증 과정이에요. SourceContent나 Feed-Entity 데이터가 검증에 실패할 경우, 해당 데이터는 Dead Letter Queue(DLQ)로 이동하게 돼요. DLQ는 처리에 실패한 메시지를 저장해 두는 특별한 큐로, 이를 통해 데이터 손실 없이 나중에 다시 처리할 수 있게 해요.\n예를 들어 원본 데이터의 형식이 변경되었거나 필수 필드가 누락되었을 때, 데이터 변환 과정에서 오류가 발생할 수 있어요. 이런 경우 해당 데이터는 DLQ로 이동하고, 개발자들은 오류의 원인을 분석한 후 필요한 수정을 거쳐 데이터를 다시 처리할 수 있어요. 이러한 메커니즘을 통해 시스템의 안정성을 높이고, 데이터 무결성을 보장했어요.\n또한 DLQ 시스템은 문제가 발생한 데이터를 자동으로 모니터링하고 알림을 보내는 기능도 포함하고 있어요. 이를 통해 개발팀이 빠르게 문제를 인지하고 대응할 수 있게 되었어요. 이는 데이터 파이프라인의 신뢰성을 높이고, 장애 상황에서도 데이터 손실을 최소화할 수 있게 했어요.\n4. 메시지 큐 프로듀스 및 서비스 간 연동\n메시지 생성 및 서비스 간 연동 흐름\n마지막 단계는 변환된 Feed-Entity 데이터를 별도의 메시지 큐에 프로듀스(Produce)하는 과정이에요. 이를 통해 피드 시스템 외의 다른 서비스들도 이 표준화된 데이터를 활용할 수 있게 되었어요. 다양한 내부 서비스들이 Feed-Entity를 구독(Subscribe)하여 필요한 정보를 실시간으로 받아볼 수 있게 되었어요. 이런 구조는 서비스 간 데이터 일관성을 유지하고, 각 서비스가 독립적으로 발전할 수 있는 기반이 되었어요.\n또한 처음 Feed-Entity 시스템을 도입할 때는 콜드 스타트(Cold Start) 문제를 해결하기 위한 백필(Backfill) 기능도 중요했어요. 백필은 기존에 존재하던 콘텐츠들을 새로운 Feed-Entity 형식으로 변환하여 시스템에 채워 넣는 과정이에요. 이 과정을 통해 새 시스템을 도입하는 순간부터 충분한 양의 데이터를 확보하고, 사용자들에게 풍부한 콘텐츠를 제공할 수 있었어요.\n이러한 메시지 큐 기반의 아키텍처는 시스템 간 느슨한 결합(Loose Coupling)을 가능하게 하여, 각 서비스가 독립적으로 개발, 배포, 확장될 수 있게 해요. 또한 비동기 처리 방식을 통해 시스템의 부하를 분산시키고, 전체 시스템의 안정성과 확장성을 높이는 데 크게 기여해요.\nFeed-Entity Serving Flow\nFeed-Entity를 잘 저장한 것만큼 이를 효율적으로 서빙하는 것도 정말 중요해요. 특히 피드는 쓰기보다 읽기 트래픽이 훨씬 많다는 특성이 있어서, 읽기에 최적화된 구조로 데이터를 저장하고 적절한 캐싱 전략을 설계하는 것이 필수예요.\n피드인프라팀에서는 Feed-Entity 데이터를 효율적으로 서빙하기 위해 지역별 특성을 고려한 Redis 캐싱 전략을 구현했어요. Feed-Entity는 지역성이 강한 특징이 있기 때문에, 지역별로 다른 캐시를 구성하여 데이터 접근 속도를 크게 향상시켰어요. 사용자가 특정 지역의 피드를 요청하면, 해당 지역에 최적화된 캐시에서 데이터를 빠르게 가져와요.\nFeed-Entity 서빙 흐름\nFeed-Entity 서빙 시스템은 효율적인 데이터 접근을 위해 다단계 저장 및 조회 구조를 갖추고 있어요. 이 시스템은 크게 Redis 캐싱 레이어와 데이터베이스 저장소의 두 계층으로 구성되어 있어요.\n데이터 저장 프로세스\nFeed-Entity가 생성되거나 업데이트되면, 다음과 같은 과정을 거쳐요:\n\n데이터베이스 저장: 모든 Feed-Entity는 우선 영구 저장소인 데이터베이스에 저장됩니다. 이는 데이터의 영구성과 내구성을 보장하기 위함이에요.\n인덱스 생성: 저장과 동시에 해당 Feed-Entity의 메타데이터와 지역 정보를 포함한 인덱스가 생성됩니다. 이 인덱스는 빠른 검색과 필터링을 위한 핵심 자료구조예요.\n레디스 캐시 업데이트: 생성된 인덱스는 지역별로 구분된 Redis 캐시에 저장됩니다. 각 지역마다 별도의 캐시 버킷을 유지하여 지역 기반 쿼리의 성능을 최적화했어요.\n\n데이터 조회 프로세스\n사용자가 특정 지역의 피드를 요청하면, 시스템은 다음과 같은 단계로 데이터를 효율적으로 조회해요:\n\n캐시 조회 (Cache Hit): 먼저 해당 지역의 Redis 캐시에서 인덱스를 조회합니다. 이때 인덱스에는 Feed-Entity ID와 기본 메타데이터만 포함되어 있어 메모리 사용을 최소화하면서도 빠른 응답 속도를 제공해요.\n데이터베이스 조회 최소화: 캐시에서 인덱스를 찾으면(Cache Hit), 해당 인덱스를 기반으로 필요한 Feed-Entity만 선택적으로 캐시 혹은 데이터베이스에서 가져옵니다. 이를 통해 전체 데이터베이스 스캔 없이도 필요한 데이터만 효율적으로 접근할 수 있어요.\n캐시 미스 처리 (Cache Miss): 만약 캐시에서 해당 지역의 인덱스를 찾지 못하면(Cache Miss), 시스템은 데이터베이스를 직접 조회하여 필요한 Feed-Entity를 검색해요.\n\n성능 최적화\n이러한 다층 구조는 여러 성능 이점을 가져왔어요:\n\n읽기 트래픽 최적화: 피드 시스템은 특성상 쓰기보다 읽기 작업이 압도적으로 많은데, 인덱스 기반 캐싱을 통해 읽기 성능을 크게 향상시켰어요.\n지역별 부하 분산: 지역별로 별도의 캐시를 관리함으로써 특정 지역의 트래픽이 증가하더라도 다른 지역의 성능에 영향을 미치지 않도록 했어요.\n\n이렇게 설계된 Feed-Entity 서빙 시스템은 수백만 사용자의 지역 기반 피드 요청을 매우 낮은 지연 시간(p99 기준 평균 20ms 이하)으로 처리해요. 특히 사용자가 많은 대도시 지역에서도 안정적인 성능을 유지하며 사용자 경험을 크게 개선했어요.\nFeed-Entity의 장점과 효과\nFeed-Entity를 도입하면서 저희 팀은 여러 가지 중요한 개선 효과를 얻을 수 있었어요. 앞서 Feed-Entity를 통해 이루고 싶은 목표를 다섯 가지 측면에서 정리했었는데요. 각 측면에서 경험한 구체적인 장점들은 아래와 같아요.\n\n데이터 구조의 표준화: 이전에는 서로 다른 형식의 데이터를 처리하기 위해 각 서비스마다 별도의 로직이 필요했지만, Feed-Entity를 통해 모든 콘텐츠를 일관된 형식으로 관리하면서 개발 복잡성이 크게 줄어들었어요.\n시스템 확장성 개선: 기존에는 새로운 콘텐츠 타입을 추가할 때마다 피드 시스템 전체를 수정해야 했지만, Feed-Entity 도입 후에는 해당 콘텐츠에 대한 변환 모듈만 추가하면 되는 구조가 되었어요. 이런 유연한 아키텍처 덕분에 빠르게 변화하는 비즈니스 요구사항에 신속하게 대응할 수 있게 되었어요.\n데이터 일관성 확보: DLQ 처리 메커니즘을 통해 데이터 손실 없이 오류 상황을 효과적으로 관리하고, 표준화된 스키마를 통해 데이터 품질을 일관되게 유지할 수 있어요. 이는 서비스 안정성 향상과 운영 부담 감소로 이어졌어요.\n통합 관리 시스템 구축: 서비스 간 연동이 훨씬 용이해졌어요. Feed-Entity를 통해 이제는 한 곳에서 모든 콘텐츠를 관리할 수 있어요. 새로운 서비스를 추가하거나 기존 서비스를 수정할 때, 표준화된 인터페이스 덕분에 전체 시스템에 미치는 영향이 최소화되었어요. 이런 구조적 이점은 개발 속도와 효율성을 크게 향상시켰고, 팀 간 협업도 더 원활하게 만들었어요.\n사용자 경험 향상: 다양한 콘텐츠 타입(중고거래, 알바, 부동산, 동네생활 등)을 통합적으로 관리하게 되면서, 사용자에게 더 풍부하고 개인화된 피드 경험을 제공할 수 있어요. 사용자의 관심사와 위치에 기반한 맞춤형 콘텐츠를 보여줄 수 있게 되었어요.\n\n이러한 여러 장점들이 모여 피드 시스템은 Feed-Entity를 통해 더 안정적이고, 확장 가능한 시스템을 구축할 수 있었어요.\nFeed-Entity NEXT\nFeed-Entity는 현재 당근의 피드 시스템에서 핵심적인 역할을 담당하고 있지만, 아직 해결해야 할 여러 과제가 있어요. 지속적인 사용자 증가와 함께 콘텐츠의 다양성도 늘어나면서, 데이터 처리 효율성과 확장성에 대한 새로운 요구사항이 계속해서 등장하고 있어요. 또한 사용자별 맞춤형 경험을 더욱 세밀하게 제공하기 위해서는 Feed-Entity 시스템의 고도화가 필요한 상황이에요. 이러한 도전 과제들을 해결하기 위해 저희 팀은 다음과 같은 방향으로 개선을 계획하고 있어요.\n\n복합적 인덱싱 전략: 현재는 단순히 최신순 지역별 큐만 가지고 있지만, 이것만으로는 다양한 요구를 충족시키기에 부족해요. 향후에는 거리순, 카테고리별, 인기도별, 최신순 등 다양한 인덱싱 전략을 구현하여 멀티 큐 시스템을 운영할 필요성이 있어요. 이를 통해 사용자가 원하는 방식으로 콘텐츠를 빠르게 탐색할 수 있게 될 거예요. 특히 지리적 거리에 따른 인덱싱은 하이퍼로컬 서비스인 당근의 특성을 더욱 강화할 수 있는 중요한 요소예요. 또한 카테고리별 인덱싱은 사용자가 관심 있는 특정 영역의 콘텐츠만 효율적으로 찾을 수 있게 도와줄 거예요. 이러한 복합적 인덱싱 전략을 구현함으로써 Feed-Entity의 서빙 속도와 정확도를 크게 향상시킬 수 있을 것으로 기대해요.\n추천 모델학습 활용: Feed-Entity는 아직 추천 시스템 전반에 적용되지 않아요. 이를 추천 모델 학습과 서빙에 활용한다면, 사용자별 선호도 예측의 정확도를 높이고 개인화된 피드 경험을 제공할 수 있을 것이에요. 또한 통일된 데이터 구조를 기반으로 ML 파이프라인을 구축하면 모델 업데이트와 학습 프로세스를 더욱 효율적으로 관리할 수 있을 거라 기대돼요.\n탐색 시스템의 SSOT 확장: 현재 Feed-Entity는 해시태그 시스템과 추천 알림에서 SSOT(Single Source of Truth)로 성공적으로 활용되고 있어요. 이러한 성공을 바탕으로 더 많은 시스템으로 Feed-Entity의 활용 범위를 확장할 계획이에요. 이를 통해 전체 서비스에서 일관된 데이터 구조와 높은 신뢰성을 확보할 수 있을 것으로 기대돼요.\n\n이러한 과제들을 해결하여 Feed-Entity를 추천 전반에 활용할 수 있게 된다면, 당근의 피드 시스템은 한 단계 더 발전된 형태로 사용자들에게 가치 있는 경험을 제공할 수 있을 것이라고 믿어요.\n마치며…\n이렇게 피드라는 복잡한 문제를 해결하기 위해 Feed-Entity라는 개념을 도입하고 발전시켜 온 피드인프라팀. 저희는 항상 더 나은 기술과 사용자 경험을 위해 끊임없이 도전하고 있어요. 혹시 이런 기술적 도전에 함께하고 싶으신가요? 당근 피드인프라팀에서는 수백만 명의 사용자들에게 하이퍼로컬 가치 있는 정보를 효율적으로 전달하기 위한 기술을 개발하고 다양한 실험에 도전할 열정적인 동료를 찾고 있어요.\n당근 피드인프라팀과 함께 하이퍼로컬 피드 경험을 만들어 갈 동료를 기다립니다.\n당근마켓 채용 페이지: https://team.daangn.com/jobs/\n\nFeed-Entity: 당근 피드의 심장 was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "Lebron J",
        "guid": "https://medium.com/p/e2ba0a7f57fa",
        "categories": [
          "software-engineering",
          "programming",
          "startup",
          "system-architecture"
        ],
        "isoDate": "2025-04-03T06:05:58.000Z"
      },
      {
        "creator": "당근",
        "title": "AI 툴 개발은 처음이라, 당근 비개발자 구성원들의 AI 도전기",
        "link": "https://medium.com/daangn/ai-%ED%88%B4-%EA%B0%9C%EB%B0%9C%EC%9D%80-%EC%B2%98%EC%9D%8C%EC%9D%B4%EB%9D%BC-%EB%8B%B9%EA%B7%BC-%EB%B9%84%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B5%AC%EC%84%B1%EC%9B%90%EB%93%A4%EC%9D%98-ai-%EB%8F%84%EC%A0%84%EA%B8%B0-fb62d2a6c2f3?source=rss----4505f82a2dbd---4",
        "pubDate": "Tue, 01 Apr 2025 07:05:14 GMT",
        "content:encoded": "<h3>AI 툴 개발은 처음이라, 당근 비개발자 구성원들의 AI 도전기 — 당근 AI Show &amp; Tell #1</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*L4Xt94VeWiQ2GJ3MfzRYgA.png\" /><figcaption>해당 이미지는 OpenAI의 이미지 생성 모델인 DALL·E를 활용하여 GPT-4o에서 생성되었습니다.</figcaption></figure><p>최근 IT 업계는 생성형 AI의 등장으로 또 한 번의 큰 전환점을 맞이했어요. 사용자 경험이 AI 중심으로 재편되면서, 기존 서비스의 PMF(Product Market Fit)가 빠르게 무너지는 사례가 많아졌죠. 하루아침에 기존 방식이 낡은 것으로 여겨지는 시대가 열린 거예요. 당근도 이런 흐름 속에서 멈춰 있지 않고, AI를 활용한 다양한 실험을 빠르게 시도하고 있어요.</p><p>이 과정에서 중요한 건 완벽한 정답을 찾는 게 아니라, 실패하더라도 직접 실험하고 실행해보는 경험 그 자체예요. 당근은 매주 화요일마다 ‘AI Show &amp; Tell’을 통해 각 팀의 프로젝트와 시행착오를 공유하고 있어요. 단순한 결과가 아닌, 실패 속에서 얻은 인사이트까지 나누는 자리죠. 업무나 서비스에 AI를 적용한 사례부터 개발 중인 기능의 어려움, 새로운 아이디어까지 다양하게 공유하면서, 모두가 함께 새로운 가능성을 발견하고 있어요.</p><p>앞으로 당근의 AI Show &amp; Tell에서 공유되는 실험들을 생생하게 나누려고 해요. 특히 이번 글에서는 직군에 관계없이 누구나 AI에 도전할 수 있다는 가능성을 보여주는 프로젝트 세 가지를 소개해 드릴게요. 엔지니어뿐 아니라 프로덕트 디자이너, CEO Staff, 운영 매니저까지 얼마나 다양한 구성원들이 AI 실험에 도전하고, 자신의 업무에서 변화를 만들어가고 있는지 확인해보세요. 🚀</p><p>*️이 콘텐츠는 생성형 AI를 활용해 제작된 콘텐츠입니다.</p><h3>개발은 몰라도, AI 실험은 누구나</h3><h3>Project 1. 디자이너가 직접 만든 피그마 플러그인, ‘Ratiosnap’</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UzZG_aFyyw6_zMYs86qrDw.png\" /></figure><p>로컬비즈니스의 Product Designer Hazel은 Cursor를 활용해, 업무에 필요한 피그마 플러그인을 직접 개발했어요. 시작은 아주 사소한 불편함이었죠. 피그마에서 UI 여백을 2:3 비율로 배치하고 싶었는데, px 단위로 매번 직접 계산해서 넣어야 했거든요. 처음엔 ChatGPT에게 비율 계산을 요청하고 그 값을 복사해 사용하는 식으로 해결했지만, 이마저도 반복되다 보니 꽤 번거롭게 느껴졌어요. 결국 이런 수고로움을 줄이기 위해, 디자인 요소의 위치를 자동으로 조정해주는 플러그인을 직접 만들어보기로 했어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YXUcm6Ml6eWoB4wEWCrU6g.png\" /></figure><p>개발 지식이 거의 없는 Hazel은 단 30분 만에 피그마 플러그인 ‘Ratiosnap’을 완성했어요. 더 놀라운 건 “이런 기능을 만들어줘”라고 구체적인 지시를 내리지 않았다는 점이에요. 평소에 겪던 비효율적인 작업 방식을 설명하고 아이디어를 요청했을 뿐인데, Cursor는 문제를 분석하고 기능 요구사항까지 마치 PRD처럼 정리해주었어요. Hazel은 그 흐름을 따라가며 필요한 부분은 피드백하고 디자인과 기능을 조율했죠. UI 구성부터 코드 작성까지 대부분의 과정을 AI가 주도했고, Hazel은 디자이너로서의 관점과 감각을 더해가며 제품을 완성해 나갔어요.</p><p>이 경험은 Hazel에게 단순한 플러그인 제작 이상의 의미였어요. 디자이너가 문제를 정의하고 솔루션을 기획하는 데서 그치는 것이 아니라, 직접 구현까지 주도할 수 있는 가능성을 확인한 순간이었죠. Cursor라는 도구 덕분에 코드를 몰라도 아이디어를 빠르게 실현할 수 있다는 자신감을 얻은 거예요. AI로 자동화되기 어려운 디자이너의 섬세한 미적 감각과 사용자에 대한 직관이 앞으로 프로덕트 디자인에 중요한 경쟁력이 될 수 있겠다는 인사이트도 얻었죠.</p><p>Hazel의 실험은 팀에도 긍정적인 영향을 주기도 했는데요. 같은 팀의 PM인 Heart도 Hazel이 만든 플러그인을 보고, Cursor를 사용해 PM에게 유용한 플러그인을 이어서 만든 거예요. 실험 하나가 또 다른 실험을 불러오며, 팀 안에 자연스럽게 AI 실험 문화가 번져나갔어요.</p><h3>Project 2. 사내 모든 AI 프로젝트를 한 곳에, ‘AI 프로젝트 캐처’</h3><p>전략지원팀의 CEO Staff인 Kyle은 인프라팀의 Site Reliability Engineer인 Alden의 도움을 받아, 전사 AI 프로젝트를 한 곳에 모아 공유하는 ‘AI 프로젝트 캐처’를 만들었어요. 당근에서는 여러 팀이 다양한 AI 실험을 진행 중이지만, 전사적으로 정보가 공유되지 않아 중복 작업이 생기거나 협업 기회를 놓치는 경우가 많았죠. 이 문제를 해결하기 위해 Kyle은 슬랙에서 오가는 AI 관련 논의를 자동 수집하고 시각화하는 시스템을 기획했고, 인프라팀의 Alden이 기술적으로 구현하며 함께 시스템을 빠르게 만들었어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*JJVHuowIehbJGUwblr70ow.png\" /></figure><p>‘AI 프로젝트 캐처’는 슬랙 메시지 중 AI 프로젝트와 관련된 내용을 감지해, 해당 게시글의 태스크, 카테고리, 요약을 자동 생성한 뒤 전용 채널에 등록하는 방식으로 작동해요. 누구나 이 채널에서 전사 프로젝트 현황을 확인할 수 있어요. 관심 있는 주제에 쉽게 접근하고 관련 팀과 협업할 수 있는 환경이 마련된 거죠. 프로젝트의 진행 상황이 실시간으로 공유되어 조직 전체의 AI 실험 속도를 높이고, 더 빠른 실행과 개선이 가능해진 것도 중요한 변화예요.</p><p>사실 이 시스템도 특정 팀이 단독으로 만든 것이 아니라, 다양한 구성원이 협업한 결과인데요. Kyle이 슬랙에 아이디어를 올린 것을 계기로 다양한 피드백이 모였고, 과거 <a href=\"https://about.daangn.com/blog/archive/%EB%8B%B9%EA%B7%BC-%ED%95%B4%EC%BB%A4%ED%86%A4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%AA%B0%EC%9E%85-%ED%98%91%EC%97%85/\">당근 Gen AI 해커톤</a>에서 만들어진 유사한 슬랙 봇의 레포지토리가 공유되며 실험이 빠르게 구체화됐죠. Alden이 이를 기반으로 Cursor와 프롬프트 스튜디오*를 활용해 단 하루 만에 시스템을 구현했어요.</p><blockquote>*프롬프트 스튜디오: 다양한 LLM을 활용해, 간편한 프롬프트 엔지니어링으로 서비스 기능을 구현할 수 있는 사내 AI 툴</blockquote><p>프로젝트를 설계한 Kyle도 프롬프트 스튜디오를 활용해 슬랙 메시지 분류 기준을 직접 수정하며 개선에 적극 참여했는데요. Kyle은 이번 실험을 통해 “코딩을 몰라도 프롬프트 스튜디오 같은 도구를 활용하면, 기능 개발에 더 적극적으로 기여할 수 있겠다는 확신이 들었다”고 말했어요. Kyle은 개발자에게 의존하지 않고 문제를 개선해가는 경험을 통해 큰 동기부여를 받았고, 앞으로 더 다양한 실험에 도전하고 싶다는 자신감도 얻었다고 해요. 실제로 이번 프로젝트를 계기로 이후로도 모바일 앱이나 슬랙 봇을 직접 만들어 보고, API 연동과 서버 배포까지 시도해봤다고 해요.</p><h3>Project 3. AI로 운영 업무의 효율을 높이다, ‘정규표현식 생성기 &amp; 폴리시 체커’</h3><p>중고거래 서비스의 운영을 담당하는 Operations Manager, Sang은 AI를 활용해 당근의 운영 업무를 더욱 효율적으로 바꾼 실험을 소개했어요. Sang은 평소 중고거래 게시글에서 사기, 전문 판매, 구인구직 등 금지 행위를 시도하는 어뷰저들을 탐지하고 대응하는 업무를 맡고 있는데요. 문제는 이 어뷰저들이 규제를 피하기 위해 표현 방식을 계속 바꾼다는 점이에요. 이를 잡아내려면 그때그때 새로운 정규표현식을 수작업으로 만들어야 했는데, 이는 시간이 오래 걸리고 빠른 대응을 어렵게 한다는 단점이 있었어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yU9MGrehg2AO3XoHYX2orQ.png\" /></figure><p>Sang은 이 비효율을 해결하기 위해 Cursor로 자동화 툴을 만들었어요. 그가 만든 정규표현식 생성기에 학습 데이터를 제공하고 프롬프트만 입력하면, JS 형식의 정규표현식을 자동으로 생성해줘요. 예를 들어 먼저 ‘구인구직’으로 신고된 게시글 500건을 CSV 파일로 업로드하고, “일자리를 구하는 사람의 패턴을 잡아줘”라는 프롬프트만 입력하면 되죠.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*QytnOqiZZfrlc33elneS1A.png\" /></figure><p>이어 Sang은 같은 방식으로 내부 정책 문서를 AI가 직접 점검하고 개선점을 제안하는 툴도 만들어봤어요. 이른바 ‘폴리시 체커(Policy Checker)’인데요. 당근의 거래 금지 항목이나 사용자 가이드라인 등 기존 문서를 AI에게 입력하니, 누락된 정보나 모호한 표현, 관련 법률이나 연관 가이드라인까지 짚어줬어요. 문서를 하나하나 검토하지 않아도, 실제로 의미 있는 개선 포인트들을 얻을 수 있었죠.</p><p>이 실험을 통해 Sang은 AI가 단순히 도와주는 도구를 넘어, 운영 정책을 함께 만들어가는 파트너가 될 수 있다는 가능성을 체감했다고 말했어요. Cursor 같은 도구가 처음엔 낯설었지만, 여러 효과적인 툴을 이틀 만에 완성할 수 있었던 경험은 비개발자인 그에게도 큰 자신감을 안겨줬죠. “워드나 노션을 누구나 쓰듯이, AI 툴도 의지만 있다면 누구나 쓸 수 있다”고 말하며, 진짜 장벽은 기술이 아니라 ‘심리적 거리감’이라는 점도 강조했어요.</p><h4>누구나 아이디어를 실현하는 곳</h4><p>AI 실험은 더 이상 엔지니어만의 영역이 아니라, 아이디어만 있다면 누구든지 직접 실행할 수 있는 것이 됐어요. 당근에서는 직군이라는 경계 없이 다양한 구성원들이 각자의 문제를 정의하고, 스스로 해결책을 실험하며 실제 변화를 만들어내고 있어요.</p><p>이런 변화는 단순히 AI 기술을 도입했다는 의미를 넘어, 당근이 더 빠르고 효과적으로 일할 수 있는 방법을 실험하고 실제로 실현해가고 있음을 보여줘요. 실제로 매주 전사적으로 실험을 공유하고, 사소한 아이디어라도 실행해볼 수 있도록 아낌없이 지원하는 환경을 만들어가고 있어요. 덕분에 누구든지, 어떤 팀이든, AI를 활용한 실험에 뛰어들 수 있는 문화가 자연스럽게 자리잡고 있죠.</p><p>앞으로도 당근의 AI Show &amp; Tell에서는 이런 실험들이 계속 이어질 거예요. 다양한 팀에서 시작된 변화의 흐름이 계속해서 전사로 퍼져나가고 있거든요. 누구나 새로운 시도의 주체가 될 수 있는 AI 실험의 현장, 그 생생한 이야기들이 궁금하다면 다음 편도 기대해주세요!</p><blockquote>함께 AI로 새로운 가능성을 발견하고 싶다면? <br>👉 <a href=\"https://about.daangn.com/jobs/\"><strong>당근 채용 공고 바로 가기</strong></a></blockquote><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fb62d2a6c2f3\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/ai-%ED%88%B4-%EA%B0%9C%EB%B0%9C%EC%9D%80-%EC%B2%98%EC%9D%8C%EC%9D%B4%EB%9D%BC-%EB%8B%B9%EA%B7%BC-%EB%B9%84%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B5%AC%EC%84%B1%EC%9B%90%EB%93%A4%EC%9D%98-ai-%EB%8F%84%EC%A0%84%EA%B8%B0-fb62d2a6c2f3\">AI 툴 개발은 처음이라, 당근 비개발자 구성원들의 AI 도전기</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "AI 툴 개발은 처음이라, 당근 비개발자 구성원들의 AI 도전기 — 당근 AI Show & Tell #1\n해당 이미지는 OpenAI의 이미지 생성 모델인 DALL·E를 활용하여 GPT-4o에서 생성되었습니다.\n최근 IT 업계는 생성형 AI의 등장으로 또 한 번의 큰 전환점을 맞이했어요. 사용자 경험이 AI 중심으로 재편되면서, 기존 서비스의 PMF(Product Market Fit)가 빠르게 무너지는 사례가 많아졌죠. 하루아침에 기존 방식이 낡은 것으로 여겨지는 시대가 열린 거예요. 당근도 이런 흐름 속에서 멈춰 있지 않고, AI를 활용한 다양한 실험을 빠르게 시도하고 있어요.\n이 과정에서 중요한 건 완벽한 정답을 찾는 게 아니라, 실패하더라도 직접 실험하고 실행해보는 경험 그 자체예요. 당근은 매주 화요일마다 ‘AI Show & Tell’을 통해 각 팀의 프로젝트와 시행착오를 공유하고 있어요. 단순한 결과가 아닌, 실패 속에서 얻은 인사이트까지 나누는 자리죠. 업무나 서비스에 AI를 적용한 사례부터 개발 중인 기능의 어려움, 새로운 아이디어까지 다양하게 공유하면서, 모두가 함께 새로운 가능성을 발견하고 있어요.\n앞으로 당근의 AI Show & Tell에서 공유되는 실험들을 생생하게 나누려고 해요. 특히 이번 글에서는 직군에 관계없이 누구나 AI에 도전할 수 있다는 가능성을 보여주는 프로젝트 세 가지를 소개해 드릴게요. 엔지니어뿐 아니라 프로덕트 디자이너, CEO Staff, 운영 매니저까지 얼마나 다양한 구성원들이 AI 실험에 도전하고, 자신의 업무에서 변화를 만들어가고 있는지 확인해보세요. 🚀\n*️이 콘텐츠는 생성형 AI를 활용해 제작된 콘텐츠입니다.\n개발은 몰라도, AI 실험은 누구나\nProject 1. 디자이너가 직접 만든 피그마 플러그인, ‘Ratiosnap’\n\n로컬비즈니스의 Product Designer Hazel은 Cursor를 활용해, 업무에 필요한 피그마 플러그인을 직접 개발했어요. 시작은 아주 사소한 불편함이었죠. 피그마에서 UI 여백을 2:3 비율로 배치하고 싶었는데, px 단위로 매번 직접 계산해서 넣어야 했거든요. 처음엔 ChatGPT에게 비율 계산을 요청하고 그 값을 복사해 사용하는 식으로 해결했지만, 이마저도 반복되다 보니 꽤 번거롭게 느껴졌어요. 결국 이런 수고로움을 줄이기 위해, 디자인 요소의 위치를 자동으로 조정해주는 플러그인을 직접 만들어보기로 했어요.\n\n개발 지식이 거의 없는 Hazel은 단 30분 만에 피그마 플러그인 ‘Ratiosnap’을 완성했어요. 더 놀라운 건 “이런 기능을 만들어줘”라고 구체적인 지시를 내리지 않았다는 점이에요. 평소에 겪던 비효율적인 작업 방식을 설명하고 아이디어를 요청했을 뿐인데, Cursor는 문제를 분석하고 기능 요구사항까지 마치 PRD처럼 정리해주었어요. Hazel은 그 흐름을 따라가며 필요한 부분은 피드백하고 디자인과 기능을 조율했죠. UI 구성부터 코드 작성까지 대부분의 과정을 AI가 주도했고, Hazel은 디자이너로서의 관점과 감각을 더해가며 제품을 완성해 나갔어요.\n이 경험은 Hazel에게 단순한 플러그인 제작 이상의 의미였어요. 디자이너가 문제를 정의하고 솔루션을 기획하는 데서 그치는 것이 아니라, 직접 구현까지 주도할 수 있는 가능성을 확인한 순간이었죠. Cursor라는 도구 덕분에 코드를 몰라도 아이디어를 빠르게 실현할 수 있다는 자신감을 얻은 거예요. AI로 자동화되기 어려운 디자이너의 섬세한 미적 감각과 사용자에 대한 직관이 앞으로 프로덕트 디자인에 중요한 경쟁력이 될 수 있겠다는 인사이트도 얻었죠.\nHazel의 실험은 팀에도 긍정적인 영향을 주기도 했는데요. 같은 팀의 PM인 Heart도 Hazel이 만든 플러그인을 보고, Cursor를 사용해 PM에게 유용한 플러그인을 이어서 만든 거예요. 실험 하나가 또 다른 실험을 불러오며, 팀 안에 자연스럽게 AI 실험 문화가 번져나갔어요.\nProject 2. 사내 모든 AI 프로젝트를 한 곳에, ‘AI 프로젝트 캐처’\n전략지원팀의 CEO Staff인 Kyle은 인프라팀의 Site Reliability Engineer인 Alden의 도움을 받아, 전사 AI 프로젝트를 한 곳에 모아 공유하는 ‘AI 프로젝트 캐처’를 만들었어요. 당근에서는 여러 팀이 다양한 AI 실험을 진행 중이지만, 전사적으로 정보가 공유되지 않아 중복 작업이 생기거나 협업 기회를 놓치는 경우가 많았죠. 이 문제를 해결하기 위해 Kyle은 슬랙에서 오가는 AI 관련 논의를 자동 수집하고 시각화하는 시스템을 기획했고, 인프라팀의 Alden이 기술적으로 구현하며 함께 시스템을 빠르게 만들었어요.\n\n‘AI 프로젝트 캐처’는 슬랙 메시지 중 AI 프로젝트와 관련된 내용을 감지해, 해당 게시글의 태스크, 카테고리, 요약을 자동 생성한 뒤 전용 채널에 등록하는 방식으로 작동해요. 누구나 이 채널에서 전사 프로젝트 현황을 확인할 수 있어요. 관심 있는 주제에 쉽게 접근하고 관련 팀과 협업할 수 있는 환경이 마련된 거죠. 프로젝트의 진행 상황이 실시간으로 공유되어 조직 전체의 AI 실험 속도를 높이고, 더 빠른 실행과 개선이 가능해진 것도 중요한 변화예요.\n사실 이 시스템도 특정 팀이 단독으로 만든 것이 아니라, 다양한 구성원이 협업한 결과인데요. Kyle이 슬랙에 아이디어를 올린 것을 계기로 다양한 피드백이 모였고, 과거 당근 Gen AI 해커톤에서 만들어진 유사한 슬랙 봇의 레포지토리가 공유되며 실험이 빠르게 구체화됐죠. Alden이 이를 기반으로 Cursor와 프롬프트 스튜디오*를 활용해 단 하루 만에 시스템을 구현했어요.\n*프롬프트 스튜디오: 다양한 LLM을 활용해, 간편한 프롬프트 엔지니어링으로 서비스 기능을 구현할 수 있는 사내 AI 툴\n프로젝트를 설계한 Kyle도 프롬프트 스튜디오를 활용해 슬랙 메시지 분류 기준을 직접 수정하며 개선에 적극 참여했는데요. Kyle은 이번 실험을 통해 “코딩을 몰라도 프롬프트 스튜디오 같은 도구를 활용하면, 기능 개발에 더 적극적으로 기여할 수 있겠다는 확신이 들었다”고 말했어요. Kyle은 개발자에게 의존하지 않고 문제를 개선해가는 경험을 통해 큰 동기부여를 받았고, 앞으로 더 다양한 실험에 도전하고 싶다는 자신감도 얻었다고 해요. 실제로 이번 프로젝트를 계기로 이후로도 모바일 앱이나 슬랙 봇을 직접 만들어 보고, API 연동과 서버 배포까지 시도해봤다고 해요.\nProject 3. AI로 운영 업무의 효율을 높이다, ‘정규표현식 생성기 & 폴리시 체커’\n중고거래 서비스의 운영을 담당하는 Operations Manager, Sang은 AI를 활용해 당근의 운영 업무를 더욱 효율적으로 바꾼 실험을 소개했어요. Sang은 평소 중고거래 게시글에서 사기, 전문 판매, 구인구직 등 금지 행위를 시도하는 어뷰저들을 탐지하고 대응하는 업무를 맡고 있는데요. 문제는 이 어뷰저들이 규제를 피하기 위해 표현 방식을 계속 바꾼다는 점이에요. 이를 잡아내려면 그때그때 새로운 정규표현식을 수작업으로 만들어야 했는데, 이는 시간이 오래 걸리고 빠른 대응을 어렵게 한다는 단점이 있었어요.\n\nSang은 이 비효율을 해결하기 위해 Cursor로 자동화 툴을 만들었어요. 그가 만든 정규표현식 생성기에 학습 데이터를 제공하고 프롬프트만 입력하면, JS 형식의 정규표현식을 자동으로 생성해줘요. 예를 들어 먼저 ‘구인구직’으로 신고된 게시글 500건을 CSV 파일로 업로드하고, “일자리를 구하는 사람의 패턴을 잡아줘”라는 프롬프트만 입력하면 되죠.\n\n이어 Sang은 같은 방식으로 내부 정책 문서를 AI가 직접 점검하고 개선점을 제안하는 툴도 만들어봤어요. 이른바 ‘폴리시 체커(Policy Checker)’인데요. 당근의 거래 금지 항목이나 사용자 가이드라인 등 기존 문서를 AI에게 입력하니, 누락된 정보나 모호한 표현, 관련 법률이나 연관 가이드라인까지 짚어줬어요. 문서를 하나하나 검토하지 않아도, 실제로 의미 있는 개선 포인트들을 얻을 수 있었죠.\n이 실험을 통해 Sang은 AI가 단순히 도와주는 도구를 넘어, 운영 정책을 함께 만들어가는 파트너가 될 수 있다는 가능성을 체감했다고 말했어요. Cursor 같은 도구가 처음엔 낯설었지만, 여러 효과적인 툴을 이틀 만에 완성할 수 있었던 경험은 비개발자인 그에게도 큰 자신감을 안겨줬죠. “워드나 노션을 누구나 쓰듯이, AI 툴도 의지만 있다면 누구나 쓸 수 있다”고 말하며, 진짜 장벽은 기술이 아니라 ‘심리적 거리감’이라는 점도 강조했어요.\n누구나 아이디어를 실현하는 곳\nAI 실험은 더 이상 엔지니어만의 영역이 아니라, 아이디어만 있다면 누구든지 직접 실행할 수 있는 것이 됐어요. 당근에서는 직군이라는 경계 없이 다양한 구성원들이 각자의 문제를 정의하고, 스스로 해결책을 실험하며 실제 변화를 만들어내고 있어요.\n이런 변화는 단순히 AI 기술을 도입했다는 의미를 넘어, 당근이 더 빠르고 효과적으로 일할 수 있는 방법을 실험하고 실제로 실현해가고 있음을 보여줘요. 실제로 매주 전사적으로 실험을 공유하고, 사소한 아이디어라도 실행해볼 수 있도록 아낌없이 지원하는 환경을 만들어가고 있어요. 덕분에 누구든지, 어떤 팀이든, AI를 활용한 실험에 뛰어들 수 있는 문화가 자연스럽게 자리잡고 있죠.\n앞으로도 당근의 AI Show & Tell에서는 이런 실험들이 계속 이어질 거예요. 다양한 팀에서 시작된 변화의 흐름이 계속해서 전사로 퍼져나가고 있거든요. 누구나 새로운 시도의 주체가 될 수 있는 AI 실험의 현장, 그 생생한 이야기들이 궁금하다면 다음 편도 기대해주세요!\n함께 AI로 새로운 가능성을 발견하고 싶다면? \n👉 당근 채용 공고 바로 가기\n\nAI 툴 개발은 처음이라, 당근 비개발자 구성원들의 AI 도전기 was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "당근",
        "guid": "https://medium.com/p/fb62d2a6c2f3",
        "categories": [
          "ai-tools",
          "cursor",
          "automation",
          "ai"
        ],
        "isoDate": "2025-04-01T07:05:14.000Z"
      },
      {
        "creator": "Yany Choi",
        "title": "Karpenter 트러블슈팅 — 비용과 안정성 두 마리 토끼 잡기",
        "link": "https://medium.com/daangn/karpenter-%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85-%EB%B9%84%EC%9A%A9%EA%B3%BC-%EC%95%88%EC%A0%95%EC%84%B1-%EB%91%90%EB%A7%88%EB%A6%AC-%ED%86%A0%EB%81%BC-%EC%9E%A1%EA%B8%B0-ce8bd45ec8f2?source=rss----4505f82a2dbd---4",
        "pubDate": "Thu, 27 Mar 2025 06:32:10 GMT",
        "content:encoded": "<h3>Karpenter 트러블슈팅 — 비용과 안정성 두 마리 토끼 잡기</h3><p>안녕하세요, 저는 당근페이 인프라팀에서 Site Reliability Engineer로 일하고 있는 Yany라고 해요. 저희 팀은 당근페이의 인프라를 안정적으로 관리해요. 개발자들의 프로덕트 개발 속도를 향상하고, 동시에 비용도 최적화하죠.</p><p>저희는 클러스터 오토스케일링 없이 ASG(AWS EC2 AutoScaling Group)로, 그리고 HorizontalPodAutoscaler 없이 클러스터를 관리하고 있었어요. 여기에는 몇 가지 문제가 있었어요:</p><ul><li>스케일 아웃 과정에서 네트워크에 여러 병목 지점이 생겼어요.</li><li>클러스터 업데이트를 진행하면서 ASG마다 AMI를 업데이트해야 했고, 오토스케일링이 원활하지 못했어요.</li><li>컴플라이언스 이슈로 인해 분리된 노드, 서브넷에서 동작해야 하는 워크로드가 증가하면서 ASG가 늘어나 관리 포인트가 증가하고 있었어요.</li><li>새벽 시간대에 트래픽이 현저히 적은 것에 비해 리소스를 너무 많이 사용하고 있었어요.</li></ul><p>당근페이의 거래량과 유저 수가 급격히 증가하면서, 기존의 ASG 기반 인프라 운영 방식으로는 한계가 명확해졌어요. 이에 따라 <strong>더 유연하고 자동화된 클러스터 스케일링이 필요했고, 그 해답으로 Karpenter를 도입하게 되었어요.</strong></p><p>그 여정은 저희가 생각한 것만큼 마냥 쉽지만은 않았는데요. 이번 글에서는 그 트러블슈팅 과정을 구체적으로 소개해드리려고 해요. Karpenter 도입을 고민 중이시거나 더 효율적으로 사용할 방법을 찾고 계신다면, 이 글이 큰 도움이 되길 바라요.</p><h3><a href=\"https://karpenter.sh/\">Karpenter</a>란?</h3><p>Karpenter는 쿠버네티스 클러스터에서 파드의 수요에 맞춰 노드의 양을 조절하는 Cluster Autoscaling Operator에요. 여러 컴포넌트를 통해 원하는 규격의 노드를 생성하고, 생성된 노드의 생명주기를 관리하도록 도와줘요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ecaimmwGOl2GcGHOImZ_wA.png\" /><figcaption>출처: [<a href=\"https://karpenter.sh/\">https://karpenter.sh/</a>]</figcaption></figure><p>대표적인 기능은 아래와 같아요:</p><p><strong>Provisioning</strong></p><ul><li>Pending 상태의 파드가 존재하면, 스케줄링을 통해 필요한 노드를 생성하여 해당 파드가 스케줄링될 수 있도록 해요.</li><li>각 CSP(Cloud Service Provider, 저희의 경우 AWS가 여기에 해당해요.)에서 만든 NodeClass 구현체를 통해 인스턴스의 규격을 정해요.<br>- AWS로 가정했을 때 AMI, Subnet, Storage, Security Group, Userdata 등 EC2 인스턴스 자체와 관련된 설정을 진행할 수 있어요.</li><li>NodePool을 통해 기존 ASG처럼 목적별로 노드를 생성할 수 있어요.<br>- 여러 타입의 인스턴스를 생성할 수 있어, <a href=\"https://github.com/kubernetes/autoscaler\">Cluster Autoscaler</a> (이하 CA)보다 훨씬 효율적으로 스케일링을 진행할 수 있어요.</li></ul><p><strong>Disruption</strong></p><ul><li><strong>Drift</strong>: NodeClass, NodePool이 바뀌면 Drift를 통해 노드들을 원하는 상태로 Sync할 수 있어요.</li><li><strong>Consolidation</strong>: 충분히 사용하고 있지 않은 노드를 삭제해서 최적화된 양의 리소스를 사용할 수 있어요.<br>- <strong>SingleNodeConsolidation</strong>: 활용도가 낮은 개별 노드를 식별해요. 해당 노드의 워크로드를 다른 노드로 이동한 후 불필요한 노드를 삭제함으로써 리소스 낭비를 줄여요.<br>- <strong>MultiNodeConsolidation</strong>: 여러 개의 작은 노드에 분산된 워크로드를 더 적은 수의 큰 노드로 통합하여 리소스 효율성을 높여요. 이 과정에서 Karpenter는 기존 노드들을 대체할 수 있는 최적의 노드 구성을 자동으로 계산해요.<br>- <strong>EmptyNodeConsolidation</strong>: 워크로드가 전혀 실행되지 않는 빈 노드를 감지하여 신속하게 삭제함으로써 불필요한 리소스 비용을 절감해요. 이는 클러스터에서 사용되지 않는 자원을 즉시 회수하는 데 효과적이에요.</li><li><strong>Expiration</strong>: 노드의 수명을 정하고, 그 시간이 지나면 노드를 삭제해요.</li></ul><p>주요 컴포넌트는 NodeClass (<a href=\"https://github.com/aws/karpenter-provider-aws/blob/main/pkg/apis/v1/ec2nodeclass.go\">AWS 구현체</a>의 경우 EC2NodeClass, <a href=\"https://github.com/Azure/karpenter-provider-azure/blob/main/pkg/apis/v1alpha2/aksnodeclass.go\">Azure 구현체</a>의 경우 AKSNodeClass)<a href=\"https://github.com/kubernetes-sigs/karpenter/blob/main/pkg/apis/v1/nodepool.go\">NodePool</a>, <a href=\"https://github.com/kubernetes-sigs/karpenter/blob/main/pkg/apis/v1/nodeclaim.go\">NodeClaim</a>이 있어요. 각 역할은 다음과 같아요:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*P1OSGloYQoE9S5muAoEBBg.png\" /></figure><p>Karpenter와 CA의 특징을 항목별로 비교해 보면 아래와 같아요:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uY3gUG2Y-0O_Nupd4sI44w.png\" /></figure><p>Karpenter는 확실히 CA보다 더 효율적이고 빠른 오토스케일링이 가능하도록 지원해 준다는 점에서 커뮤니티에서 인기가 많아요. 저희도 그런 이유로 도입했고요. 하지만 다양한 측면에서 예상하지 못했던 문제점들을 마주했는데요. 어떤 문제들을 마주했고 어떻게 해결했는지 본격적으로 설명해 드릴게요.</p><h3>Troubleshooting</h3><h3>1. 스케줄링이 생각처럼 되지 않아요</h3><p>처음 Karpenter를 PoC할 땐 대체로 잘 확장됐었지만, 때때로 한두 개의 파드들이 Pending 상태에서 풀리지 않고 대기하는 것을 발견했어요. 이 부분을 해결하기 위해 스케줄링 로직을 더 파보면서 재밌는 사실을 알게 되었어요. 바로 <strong>Karpenter 내부에서</strong> <strong>스케줄링을 시뮬레이션한다는 사실</strong>이었어요.</p><p>Karpenter의 스케줄링은 아래와 같은 상황에서 발생하게 돼요:</p><ul><li>Provisioning Loop가 돌 때<br>클러스터 내에서 파드가 Pending되는 이벤트를 탐지해요. 이런 Loop를 끊임없이 반복해서 지속적으로 클러스터 리소스들을 탐색하는 과정을 거쳐요. 파드의 수요가 실제 리소스를 넘는 순간을 빠르게 포착한 후 얼마나 리소스가 더 필요한지 계산해야 하기 때문에 스케줄링이 필요해요.</li><li>Disruption Loop가 돌 때 (Consolidation, Draft 등)<br>Disruption 또한 Provisioning Loop와 마찬가지로 끊임없이 반복하는데요. 현재 노드가 파드 수요보다 많아 불필요하게 사용되는 리소스를 탐지해요. 특정 노드를 지운 후의 파드 스케줄링 방법, 새로운 노드의 생성 여부를 결정해야 하기 때문에 스케줄링이 필요해요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uY3gUG2Y-0O_Nupd4sI44w.png\" /></figure><h4>스케줄링 동작 방식</h4><p>우선 스케줄링 대상 파드를 선정하기부터 큐에서 파드 하나를 추출하기까지의 과정을 도식으로 나타내면 아래와 같은데요. 단계별로 각 과정을 설명할게요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tADeQg57V-AwX6m27P7raw.png\" /></figure><p>먼저 파드들은 아래의 조건에 부합해야 스케줄링 대상으로 선정돼요.</p><ul><li>Pending 상태의 파드들</li><li>삭제 대상인 노드의 파드 중 DaemonSet과 이미 삭제되고 있는 파드들<br>- 노드 status의 MarkedForDeletion이 true인지<br>- 노드 자체가 NodeClaim과 관계없이 삭제되고 있는지<br>- NodeClaim, 혹은 매핑된 노드가 삭제되고 있는지</li></ul><p>이렇게 스케줄링 대상 파드들을 정리했으면, 먼저 CPU와 메모리를 많이 사용하는 순서대로 정렬해요. 그 후 큐로 만들어서 리소스를 많이 사용하는 파드들부터 순차적으로 스케줄링을 시작해요.</p><pre>func byCPUAndMemoryDescending(pods []*v1.Pod, podRequests map[types.UID]v1.ResourceList) func(i int, j int) bool {<br> return func(i, j int) bool {<br>  lhsPod := pods[i]<br>  rhsPod := pods[j]<br><br>  lhs := podRequests[lhsPod.UID]<br>  rhs := podRequests[rhsPod.UID]<br><br>  cpuCmp := resources.Cmp(lhs[v1.ResourceCPU], rhs[v1.ResourceCPU])<br>  if cpuCmp &lt; 0 {<br>   return false<br>  } else if cpuCmp &gt; 0 {<br>   return true<br>  }<br>  memCmp := resources.Cmp(lhs[v1.ResourceMemory], rhs[v1.ResourceMemory])<br><br>  if memCmp &lt; 0 {<br>   return false<br>  } else if memCmp &gt; 0 {<br>   return true<br>  }<br>  return lhsPod.UID &lt; rhsPod.UID<br> }<br>}</pre><p>위 과정을 마쳤다면 이제 본격적으로 스케줄링을 시도할 수 있는데요. 이후의 과정을 도식으로 나타나면 아래와 같아요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*b3KGTDo3KgQ5EGlakKeRAQ.png\" /></figure><p>가장 먼저 큐에서 파드들을 하나씩 꺼내서 노드에 배치하기 시작하는데, 여기서 기본적인 kube-scheduler의 동작을 모방하기 시작해요. (<a href=\"https://github.com/kubernetes-sigs/karpenter/blob/main/pkg/controllers/provisioning/scheduling/scheduler.go#L352\">소스코드</a>)</p><p>파드를 배치하고자 하는 노드에는 아래와 같은 우선순위로 작업이 진행돼요.</p><ol><li>클러스터 내 실제 노드에서 먼저 스케줄링 시도</li></ol><pre>// 클러스터 내 실제 노드에서 먼저 스케줄링을 시도해요.<br> for _, node := range s.existingNodes {<br>  if err := node.Add(ctx, s.kubeClient, pod, s.cachedPodData[pod.UID]); err == nil {<br>   return nil<br>  }<br> }</pre><p>2. 생성하려고 준비한 NodeClaim에 스케줄링 시도</p><pre>// Consider using https://pkg.go.dev/container/heap<br> sort.Slice(s.newNodeClaims, func(a, b int) bool { return len(s.newNodeClaims[a].Pods) &lt; len(s.newNodeClaims[b].Pods) })<br><br> // 생성하려고 준비한 NodeClaim에도 스케줄링을 시도해요.<br> for _, nodeClaim := range s.newNodeClaims {<br>  if err := nodeClaim.Add(pod, s.cachedPodData[pod.UID]); err == nil {<br>   return nil<br>  }<br> }</pre><p>3. 새로운 NodeClaim 생성</p><pre>// 노드를 새로 생성해요.<br> var errs error<br> for _, nodeClaimTemplate := range s.nodeClaimTemplates {<br>  instanceTypes := nodeClaimTemplate.InstanceTypeOptions<br><br>  // if limits have been applied to the nodepool, ensure we filter instance types to avoid violating those limits<br>  if remaining, ok := s.remainingResources[nodeClaimTemplate.NodePoolName]; ok {<br>   instanceTypes = filterByRemainingResources(instanceTypes, remaining)<br>   ... // (validation)<br>  }<br><br>  nodeClaim := NewNodeClaim(nodeClaimTemplate, s.topology, s.daemonOverhead[nodeClaimTemplate], instanceTypes)<br>  if err := nodeClaim.Add(pod, s.cachedPodData[pod.UID]); err != nil {<br>   ... // (error handling)<br>   continue<br>  }<br><br>  // we will launch this nodeClaim and need to track its maximum possible resource usage against our remaining resources<br>  s.newNodeClaims = append(s.newNodeClaims, nodeClaim)<br>  s.remainingResources[nodeClaimTemplate.NodePoolName] = subtractMax(s.remainingResources[nodeClaimTemplate.NodePoolName], nodeClaim.InstanceTypeOptions)<br>  return nil<br> }<br> return errs</pre><p>위의 우선순위에 맞춰 yaml로 작성하는 수많은 규칙을 반영하기 위해, Karpenter 내에서 스케줄링할 노드를 지정해요. 그 과정은 아래 순서대로 진행돼요. (이 코드는 <a href=\"https://github.com/kubernetes-sigs/karpenter/blob/main/pkg/controllers/provisioning/scheduling/existingnode.go#L68\">실제 클러스터에 존재하는 노드에 스케줄링하는 상황의 로직</a>이고, <a href=\"https://github.com/kubernetes-sigs/karpenter/blob/main/pkg/controllers/provisioning/scheduling/nodeclaim.go#L111\">NodeClaim에 파드를 추가하는 로직</a>과는 분리되어 작성되어 있어요.)</p><ol><li>노드와 파드의 taint와 toleration의 일치 여부를 파악해요.</li></ol><pre>// 노드와 파드의 taint-toleration이 일치해야 해요.<br> if err := scheduling.Taints(n.cachedTaints).ToleratesPod(pod); err != nil {<br>  return err<br> }</pre><p>2. 노드가 기존에 존재하면, 노드의 volume 제한을 넘지 않는지 확인해요.</p><pre>// 노드가 기존에 존재하면, 노드의 volume 제한을 넘지 않도록 해요.<br> volumes, err := scheduling.GetVolumes(ctx, kubeClient, pod)<br> if err != nil {<br>  return err<br> }<br> if err = n.VolumeUsage().ExceedsLimits(volumes); err != nil {<br>  return fmt.Errorf(&quot;checking volume usage, %w&quot;, err)<br> }</pre><p>3. 노드의 포트를 중복해서 사용하는지 확인해요.</p><pre>// 노드의 포트를 중복해서 사용하는지 확인해요.<br> hostPorts := scheduling.GetHostPorts(pod)<br> if err = n.HostPortUsage().Conflicts(pod, hostPorts); err != nil {<br>  return fmt.Errorf(&quot;checking host port usage, %w&quot;, err)<br> }</pre><p>4. 노드의 리소스 총량이 새로 뜰 파드를 포함한 request 수요를 감당할 수 있는지 확인해요. NodeClaim을 새로 생성한 경우에는 request 총량을 더해서 인스턴스를 새로 생성할 때 활용할 수 있도록 해요.</p><pre> // 노드의 리소스 총량이 새로 뜰 파드를 포함한 request 수요를 감당할 수 있는지 확인해요. <br> // NodeClaim을 새로 생성한 경우에는 request 총량을 더해서 인스턴스를 새로 생성할 때 활용할 수 있도록 해요.<br> requests := resources.Merge(n.requests, podData.Requests)<br> if !resources.Fits(requests, n.cachedAvailable) {<br>  return fmt.Errorf(&quot;exceeds node resources&quot;)<br> }</pre><p>5. nodeAffinity, nodeSelector를 확인해서 노드와 파드의 조건이 부합하는지 확인해요.</p><pre>// nodeAffinity, nodeSelector를 확인해서 노드와 파드의 조건이 부합하는지 확인해요.<br>nodeRequirements := scheduling.NewRequirements(n.requirements.Values()...)<br>if err = nodeRequirements.Compatible(podData.Requirements); err != nil {<br> return err<br>}<br>nodeRequirements.Add(podData.Requirements.Values()...)</pre><p>6. 토폴로지 요건을 확인해요. 이 부분은 nodeAffinity와 topologySpreadConstraint이 공존하는데, 둘 다 이 과정에서 같이 확인하게 돼요. 여기서 preferred 설정이 들어가 있는 affinity는 계산에 포함되지 않게 돼요.</p><pre>// topology 요건을 확인해요.<br> topologyRequirements, err := n.topology.AddRequirements(pod, n.cachedTaints, podData.StrictRequirements, nodeRequirements)<br> if err != nil {<br>  return err<br> }<br> if err = nodeRequirements.Compatible(topologyRequirements); err != nil {<br>  return err<br> }<br> nodeRequirements.Add(topologyRequirements.Values()...)</pre><p>7. 위 과정을 큐 안에 있는 모든 파드들의 시뮬레이션이 완료될 때까지 반복해요.</p><h4>Karpenter를 활용한 스케줄링의 장점과 한계</h4><p>이 과정의 코드를 보게 되면 kube-scheduler의 기본적인 작동 알고리즘과 동일하게 작동하도록 여러 k8s 라이브러리들을 랩핑해서 내부에서 같은 순서로 로직을 돌리고 있어요. 이렇게 구현하면 NodeClaim의 수요를 빠르게 파악할 수 있어, Karpenter의 최대 강점 중 하나인 빠른 프로비저닝을 제공할 수 있어요.</p><p>하지만 이 부분이 kube-scheduler와 완전하게 동일하다는 보장은 하긴 어려워요. 이 글을 작성하고 있는 Karpenter v1.1.1 현재, Kubernetes 1.28 버전에서 beta로 전환된 topologySpreadConstraints의 matchLabelKeys 는 스케줄링 과정에서 계산하지 않고 있어요. 저희는 Karpenter를 도입하기 이전, ReplicaSet 별로 skew를 계산하기 위해 matchLabelKey에 pod-template-hash (ReplicaSet 뒤의 난수)를 활용하고 있었는데, Karpenter를 사용하면서 이 기능을 포기해야 했어요.</p><p>이 기능은 1년 넘게 <a href=\"https://github.com/kubernetes-sigs/karpenter/pull/852\">Karpenter upstream PR</a>에 올라가 있었다가 1.3.0 버전에서 반영되었어요. 이렇듯 Karpenter는 쿠버네티스의 버전에 따른 변경 사항들을 빠르게 따라오지 못하는 이슈가 있어요. 개인적으로는 kube-scheduler에 접근할 수 있는 인터페이스가 아직 없어서, 더 정확하고 각 버전에 맞는 스케줄링 로직으로 노드를 생성할 수 없다는 게 조금 아쉬웠어요.</p><h3>2. 커스텀 AMI를 사용할 때 제약사항이 있어요.</h3><p>당근페이는 보안규정을 준수하는 노드를 효율적으로 제작하고 사용하기 위해 골든 이미지를 만들어요. 골든 이미지란 보안 컴플라이언스를 준수하기 위한 설정들과 접근제어 처리를 한 이미지예요. 추가 설정을 위해 packer + ansible로 베이킹할 필요 없이 준비가 완료된 이미지를 의미하죠. EKS AMI도 이 과정을 거쳐서 생성하고 있는데, 이 이미지들을 활용하기 위해서 EC2NodeClass에 해당 AMI를 사용해야 했어요.</p><p>우선 아무 설정 없이 AMI Family (OS)만 설정하면, AWS SSM Parameter Store로 이미지 AMI를 회수해요. (<a href=\"https://github.com/aws/karpenter-provider-aws/blob/main/pkg/providers/amifamily/al2023.go#L72\">소스코드</a>)</p><pre>func (a AL2023) resolvePath(architecture, variant, k8sVersion, amiVersion string) string {<br> name := lo.Ternary(<br>  amiVersion == v1.AliasVersionLatest,<br>  &quot;recommended&quot;,<br>  fmt.Sprintf(&quot;amazon-eks-node-al2023-%s-%s-%s-%s&quot;, architecture, variant, k8sVersion, amiVersion),<br> )<br> return fmt.Sprintf(&quot;/aws/service/eks/optimized-ami/%s/amazon-linux-2023/%s/%s/%s/image_id&quot;, k8sVersion, architecture, variant, name)<br>}</pre><p>하지만 저희의 커스텀 이미지를 Parameter Store에 보관한 다음 NodeClass 컨트롤러에서 주기적으로 변경 사항을 가져오는 기능은 없었어요. 대신 직접 AMI 지정하거나 AMI를 태그해서 가져올 수 있었는데요. 저희는 실제 프로덕션 환경으로 나가는 계정과 이러한 운영 작업을 위한 계정이 분리되어 있다는 게 문제였어요. AMI를 복사할 때 AMI에 붙은 태그를 타 계정으로 같이 이동시킬 수가 없었죠. 결국 이 과정에 추가적인 리소스를 사용해서 여러 개의 계정에 태그를 동시에 추가하는 별도의 파이프라인을 구성해야 했어요.</p><h3>3. 작은 노드 위주로 생성해요.</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*xX_HMJY5mfZXp08P8YiuWw.png\" /></figure><p>저희는 기존에 2xlarge 노드를 기본으로 ASG를 구성하고 있었어요. 이를 그대로 Karpenter에 올렸더니, 그 이후부터는 xlarge 위주로 노드를 생성하기 시작했어요. Karpenter의 스케줄링 알고리즘에 따르면 현재 파드들의 resource 수요에 맞게 더 촘촘히 노드를 배치할 수 있어 이러한 접근이 유리해요. 그러나 동시에 노드 개수와 비례하여 증가하는 DaemonSet 비용을 무시할 수 없었기 때문에, 팀에서는 저희가 원하는 방향성으로 스케줄링이 되지 않는 이유를 찾아 나섰어요.</p><p>그 원인은 저희가 설정한 budget에 있었어요. budget은 NodePool에서 consolidation의 reason 별로 동시에 몇 개의 노드를 삭제할 수 있는지 설정하는 값이에요. 저희는 전반적으로, 그리고 보수적으로 스케줄링하기 위해서 budget을 낮게 잡았고, 그 결과 MultiNodeConsolidation이 발생하지 않은 채 SingleNodeConsolidation만 발생했어요. 결국 하나하나의 노드를 삭제하게 되면서 여러 노드를 하나의 노드로 통합하는 액션이 실제로 작동되지 못했어요.</p><p>하지만 budget을 높게 잡아서 disruption의 강도를 높이게 되면, 워크로드들을 너무 공격적으로 이동시키는 것이라고 판단했어요. 그래서 최소 노드 크기를 2xlarge로 설정해서 daemonset으로 인해 발생하게 되는 오버헤드를 줄이려고 했죠.</p><h3>4. 실제 리소스와 Karpenter에서 인식하는 리소스의 양에 차이가 있어요.</h3><p>Karpenter 메트릭을 수집하고 대시보드로 관찰하기 시작했는데, 노드들의 실제 리소스 양보다 Karpenter에서 계산한 리소스 양이 적다는 사실을 알게 되었어요. 이에 따라 더 공격적으로 프로비저닝이 발생해 안정성이 떨어졌어요. 게다가 실제 스케줄링과 어긋나는 엣지 케이스들도 발견되었죠.</p><p>대시보드에는 EKS AMI와 인스턴스 타입에 따라 제공되는 인스턴스 리소스 크기가 표시되는데요. 정확한 리소스의 차이를 확인하기 위해 노드를 실제로 띄워서 확인해 본 결과, 실제 사용 가능한 리소스의 양과 일치하지 않았어요. 이 값은 OS, kubelet 등 노드를 운용하기 위해 필요한 컴포넌트들이 차지하는 공간인데, 이 공간에 대한 계산을 Karpenter에서 일괄적으로 퍼센티지로 설정해서 발생하는 이슈였어요. (<a href=\"https://github.com/aws/karpenter-provider-aws/blob/main/pkg/providers/instancetype/types.go#L329\">소스코드</a>)</p><pre>func memory(ctx context.Context, info ec2types.InstanceTypeInfo) *resource.Quantity {<br> sizeInMib := *info.MemoryInfo.SizeInMiB<br> ...<br> mem := resources.Quantity(fmt.Sprintf(&quot;%dMi&quot;, sizeInMib))<br> // Account for VM overhead in calculation<br> mem.Sub(resource.MustParse(fmt.Sprintf(&quot;%dMi&quot;, int64(math.Ceil(float64(mem.Value())*options.FromContext(ctx).VMMemoryOverheadPercent/1024/1024)))))<br> return mem<br>}</pre><p>이 부분을 해결하기 위해 가장 먼저 AL2023 EKS AMI를 기준으로 인스턴스를 띄우면 제공되는 메모리양과 free 명령어를 통해 나오는 Available 메모리의 갭을 측정했어요. 이후 저희가 허용하는 인스턴스 중 가장 큰 갭을 기준으로 그 일괄적인 값을 반영해서 사용했어요. 다만, 이 해결법은 엣지 케이스의 빈도를 줄였지만, kube-scheduler에서 인식하는 상태와 Karpenter에서 인식하는 상태가 동일하지 않다는 문제가 있었어요.</p><p>1.1.0 버전에서는 <a href=\"https://github.com/aws/karpenter-provider-aws/pull/7004\">한 번 생성된 인스턴스의 실제 리소스 양을 캐싱하도록 패치</a>됐어요. 덕분에 이후 같은 인스턴스 타입을 생성할 때 더 정확한 리소스 값을 반영할 수 있었어요. 특히, 이 업데이트로 인해 Karpenter의 리소스 계산 방식이 개선되면서, 평소 스케줄링의 정합성이 크게 향상되었어요.</p><h3>5. Node Churn이 발생해요.</h3><p>Node Churn은 Karpenter에서 consolidation이 한번 발생할 때 여러 개의 노드가 연쇄적으로 disruption되고 새로 생성되는 현상을 말해요. Churn은 휘젓는다는 뜻인데요. Node Churn이 발생하면 국자로 수프를 휘젓듯이 하나의 이벤트로 인해 많은 수의 워커 노드가 한 번에 재배치되기 시작해요.</p><p>저희는 처음에 이 문제가 너무 급진적으로 consolidation budget을 잡았기 때문이라고 생각했어요. budget을 10%로 설정한 상태에서 진행했는데 pdb를 겨우 지키는 수준에서 파드들이 계속 노드 사이를 오갔어요. CPU 사용량이 급증하게 되었고, 무려 클러스터 전체 노드 중 약 50%가 순차적으로 지워지고 다시 생성됐어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6AS48ZTmkU0mRuW-oux_Zg.png\" /><figcaption>drift처럼 보이지만, 사실은 created와 underutilized가 겹쳐서 노란색처럼 보이는 것이에요. 생성 → 삭제 → 생성 → 삭제 → …를 몇 시간 동안 반복하고 있었어요.</figcaption></figure><p>그래서 모든 budget을 1로 설정하고 동시에 consolidation을 진행할 수 없게 하려고 했어요. 이에 따라 작은 노드를 큰 노드로 병합하는 MultiNodeConsolidation을 사용할 수 없게 됐죠. 하지만, 이렇게 해도 Node Churn이 지속적으로 발생했고, 어떨 때는 하루 종일 Churn이 발생하기도 했어요.</p><p>이후 메트릭을 확인해 보니 모든 consolidation의 시작 시점은 파드 수요의 변경 시점에 있었어요. Node Churn이 크게 발생할 정도의 본격적인 consolidation은 주로 영업일 낮 시간대였는데요. 새로 배포를 진행하면서 rolling, canary 업데이트를 진행하면서 파드의 수요가 요동치는 거였어요.</p><p>이 부분을 개선하고자 이후 개발자들이 배포하는 낮 시간대에는 budget을 1로, 그리고 새벽 시간대에는 budget을 2로 설정했어요. 밤에 budget이 모자라 consolidation이 밀려서 낮에 대규모로 churn이 발생하지 않도록 말이죠. 결과적으로 전체 노드의 10% 내에서 consolidation이 연쇄적으로 발생하는 수준까지 효과적으로 개선했어요.</p><h3>결과, 앞으로 할 일</h3><p>Karpenter를 도입하면서 저희는 여러 방면에서 긍정적인 효과를 보게 되었어요. 가장 큰 효과는 비용을 효율적으로 줄였다는 점이죠. 월간 인프라 비용을 약 10,000$ 절감할 수 있었어요. EKS 클러스터 업데이트 과정에서도 워커 노드의 AMI 교체, 노드의 점진적인 업데이트 등을 조금 더 손쉽게 작업할 수 있게 되었어요.</p><p>다만 아직 더 개선해야 할 부분도 많아요:</p><h4>1. 노드 웜업 시간 개선</h4><p>Karpenter 도입 후 노드가 빠르게 스케일링되면서, 새로 생성된 노드가 워크로드를 정상적으로 처리하기까지 걸리는 초기 웜업 시간 문제가 발생했어요. 이를 해결하기 위해 다음과 같은 방법을 적용했어요:</p><ul><li>일정 수준의 여유 노드를 유지하는 <strong>Overprovisioning 파드</strong>를 활용해 모든 가용 영역(Zone)에서 최소한 하나의 노드를 항상 유지하도록 했어요. 이를 통해 갑작스러운 스케일 아웃 시에도 빠르게 대응할 수 있게 됐어요.</li><li>JVM 서비스들에 readinessProbe를 통한 첫 접근을 유도해 클래스들을 미리 로딩함으로써 웜업 시간을 점진적으로 줄여나가고 있어요.</li></ul><h4>2. 레이턴시 안정화</h4><p>기존에는 스케일링 없이 진행해서 서비스 레이턴시 증가가 눈에 띄지 않았는데, Karpenter로 인한 Node Churn과 배포가 동시에 일어나 레이턴시가 크게 튀는 경우도 발생했어요. 이를 개선하기 위해 Karpenter에서 제공하는 disruption 방지 어노테이션(karpenter.sh/do-not-disrupt)을 배포 중인 서비스에 자동으로 삽입하는 컨트롤러를 개발 중이에요. 이를 통해 더 안정적이면서도 비용 효율적인 인프라를 조성하기 위해 노력하고 있어요.</p><h4>3. 스케줄링 정합성 향상</h4><p>Karpenter와 k8s를 사용하면서 가장 불편함을 느꼈던 스케줄링 흐름 파악을 위해, 현재 Karpenter 스케줄링 시뮬레이터를 개발하고 있어요. 개발이 완료되면 Karpenter와 kube-scheduler의 스케줄링 정합성이 깨졌을 때, 빠르게 원인을 파악하고 문제를 해결할 수 있을 것으로 기대하고 있어요.</p><h3>당근페이 SRE로 오세요!</h3><p>당근페이는 전자금융업자로 많은 규제를 받고 있지만 가능한 한 여러 기술에 대해 열린 마음으로 접근하고 있어요. 저희 당근페이 SRE들은 개발자들의 배포 편의성과 인프라의 효율적 운영을 위해서라면, 어떤 기술이라도 심층적으로 분석해요. 또 그 기술이 필요하다고 판단되면 빠르게 도입하죠. 신뢰와 충돌이라는 신념 아래에서 동료들과 다양한 기술을 심도 있게 테스트하고 있어요.</p><p>더 효율적이고 아름다운 인프라를 만들어가기 위해 저희와 함께할 분을 찾고 있어요. 많은 관심 부탁드려요!</p><p><a href=\"https://team.daangn.com/jobs/5792072003/\">https://team.daangn.com/jobs/5792072003/</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ce8bd45ec8f2\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/karpenter-%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85-%EB%B9%84%EC%9A%A9%EA%B3%BC-%EC%95%88%EC%A0%95%EC%84%B1-%EB%91%90%EB%A7%88%EB%A6%AC-%ED%86%A0%EB%81%BC-%EC%9E%A1%EA%B8%B0-ce8bd45ec8f2\">Karpenter 트러블슈팅 — 비용과 안정성 두 마리 토끼 잡기</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "Karpenter 트러블슈팅 — 비용과 안정성 두 마리 토끼 잡기\n안녕하세요, 저는 당근페이 인프라팀에서 Site Reliability Engineer로 일하고 있는 Yany라고 해요. 저희 팀은 당근페이의 인프라를 안정적으로 관리해요. 개발자들의 프로덕트 개발 속도를 향상하고, 동시에 비용도 최적화하죠.\n저희는 클러스터 오토스케일링 없이 ASG(AWS EC2 AutoScaling Group)로, 그리고 HorizontalPodAutoscaler 없이 클러스터를 관리하고 있었어요. 여기에는 몇 가지 문제가 있었어요:\n\n스케일 아웃 과정에서 네트워크에 여러 병목 지점이 생겼어요.\n클러스터 업데이트를 진행하면서 ASG마다 AMI를 업데이트해야 했고, 오토스케일링이 원활하지 못했어요.\n컴플라이언스 이슈로 인해 분리된 노드, 서브넷에서 동작해야 하는 워크로드가 증가하면서 ASG가 늘어나 관리 포인트가 증가하고 있었어요.\n새벽 시간대에 트래픽이 현저히 적은 것에 비해 리소스를 너무 많이 사용하고 있었어요.\n\n당근페이의 거래량과 유저 수가 급격히 증가하면서, 기존의 ASG 기반 인프라 운영 방식으로는 한계가 명확해졌어요. 이에 따라 더 유연하고 자동화된 클러스터 스케일링이 필요했고, 그 해답으로 Karpenter를 도입하게 되었어요.\n그 여정은 저희가 생각한 것만큼 마냥 쉽지만은 않았는데요. 이번 글에서는 그 트러블슈팅 과정을 구체적으로 소개해드리려고 해요. Karpenter 도입을 고민 중이시거나 더 효율적으로 사용할 방법을 찾고 계신다면, 이 글이 큰 도움이 되길 바라요.\nKarpenter란?\nKarpenter는 쿠버네티스 클러스터에서 파드의 수요에 맞춰 노드의 양을 조절하는 Cluster Autoscaling Operator에요. 여러 컴포넌트를 통해 원하는 규격의 노드를 생성하고, 생성된 노드의 생명주기를 관리하도록 도와줘요.\n출처: [https://karpenter.sh/]\n대표적인 기능은 아래와 같아요:\nProvisioning\n\nPending 상태의 파드가 존재하면, 스케줄링을 통해 필요한 노드를 생성하여 해당 파드가 스케줄링될 수 있도록 해요.\n각 CSP(Cloud Service Provider, 저희의 경우 AWS가 여기에 해당해요.)에서 만든 NodeClass 구현체를 통해 인스턴스의 규격을 정해요.\n- AWS로 가정했을 때 AMI, Subnet, Storage, Security Group, Userdata 등 EC2 인스턴스 자체와 관련된 설정을 진행할 수 있어요.\nNodePool을 통해 기존 ASG처럼 목적별로 노드를 생성할 수 있어요.\n- 여러 타입의 인스턴스를 생성할 수 있어, Cluster Autoscaler (이하 CA)보다 훨씬 효율적으로 스케일링을 진행할 수 있어요.\n\nDisruption\n\nDrift: NodeClass, NodePool이 바뀌면 Drift를 통해 노드들을 원하는 상태로 Sync할 수 있어요.\nConsolidation: 충분히 사용하고 있지 않은 노드를 삭제해서 최적화된 양의 리소스를 사용할 수 있어요.\n- SingleNodeConsolidation: 활용도가 낮은 개별 노드를 식별해요. 해당 노드의 워크로드를 다른 노드로 이동한 후 불필요한 노드를 삭제함으로써 리소스 낭비를 줄여요.\n- MultiNodeConsolidation: 여러 개의 작은 노드에 분산된 워크로드를 더 적은 수의 큰 노드로 통합하여 리소스 효율성을 높여요. 이 과정에서 Karpenter는 기존 노드들을 대체할 수 있는 최적의 노드 구성을 자동으로 계산해요.\n- EmptyNodeConsolidation: 워크로드가 전혀 실행되지 않는 빈 노드를 감지하여 신속하게 삭제함으로써 불필요한 리소스 비용을 절감해요. 이는 클러스터에서 사용되지 않는 자원을 즉시 회수하는 데 효과적이에요.\nExpiration: 노드의 수명을 정하고, 그 시간이 지나면 노드를 삭제해요.\n\n주요 컴포넌트는 NodeClass (AWS 구현체의 경우 EC2NodeClass, Azure 구현체의 경우 AKSNodeClass)NodePool, NodeClaim이 있어요. 각 역할은 다음과 같아요:\n\nKarpenter와 CA의 특징을 항목별로 비교해 보면 아래와 같아요:\n\nKarpenter는 확실히 CA보다 더 효율적이고 빠른 오토스케일링이 가능하도록 지원해 준다는 점에서 커뮤니티에서 인기가 많아요. 저희도 그런 이유로 도입했고요. 하지만 다양한 측면에서 예상하지 못했던 문제점들을 마주했는데요. 어떤 문제들을 마주했고 어떻게 해결했는지 본격적으로 설명해 드릴게요.\nTroubleshooting\n1. 스케줄링이 생각처럼 되지 않아요\n처음 Karpenter를 PoC할 땐 대체로 잘 확장됐었지만, 때때로 한두 개의 파드들이 Pending 상태에서 풀리지 않고 대기하는 것을 발견했어요. 이 부분을 해결하기 위해 스케줄링 로직을 더 파보면서 재밌는 사실을 알게 되었어요. 바로 Karpenter 내부에서 스케줄링을 시뮬레이션한다는 사실이었어요.\nKarpenter의 스케줄링은 아래와 같은 상황에서 발생하게 돼요:\n\nProvisioning Loop가 돌 때\n클러스터 내에서 파드가 Pending되는 이벤트를 탐지해요. 이런 Loop를 끊임없이 반복해서 지속적으로 클러스터 리소스들을 탐색하는 과정을 거쳐요. 파드의 수요가 실제 리소스를 넘는 순간을 빠르게 포착한 후 얼마나 리소스가 더 필요한지 계산해야 하기 때문에 스케줄링이 필요해요.\nDisruption Loop가 돌 때 (Consolidation, Draft 등)\nDisruption 또한 Provisioning Loop와 마찬가지로 끊임없이 반복하는데요. 현재 노드가 파드 수요보다 많아 불필요하게 사용되는 리소스를 탐지해요. 특정 노드를 지운 후의 파드 스케줄링 방법, 새로운 노드의 생성 여부를 결정해야 하기 때문에 스케줄링이 필요해요.\n\n스케줄링 동작 방식\n우선 스케줄링 대상 파드를 선정하기부터 큐에서 파드 하나를 추출하기까지의 과정을 도식으로 나타내면 아래와 같은데요. 단계별로 각 과정을 설명할게요.\n\n먼저 파드들은 아래의 조건에 부합해야 스케줄링 대상으로 선정돼요.\n\nPending 상태의 파드들\n삭제 대상인 노드의 파드 중 DaemonSet과 이미 삭제되고 있는 파드들\n- 노드 status의 MarkedForDeletion이 true인지\n- 노드 자체가 NodeClaim과 관계없이 삭제되고 있는지\n- NodeClaim, 혹은 매핑된 노드가 삭제되고 있는지\n\n이렇게 스케줄링 대상 파드들을 정리했으면, 먼저 CPU와 메모리를 많이 사용하는 순서대로 정렬해요. 그 후 큐로 만들어서 리소스를 많이 사용하는 파드들부터 순차적으로 스케줄링을 시작해요.\nfunc byCPUAndMemoryDescending(pods []*v1.Pod, podRequests map[types.UID]v1.ResourceList) func(i int, j int) bool {\n return func(i, j int) bool {\n  lhsPod := pods[i]\n  rhsPod := pods[j]\n  lhs := podRequests[lhsPod.UID]\n  rhs := podRequests[rhsPod.UID]\n  cpuCmp := resources.Cmp(lhs[v1.ResourceCPU], rhs[v1.ResourceCPU])\n  if cpuCmp < 0 {\n   return false\n  } else if cpuCmp > 0 {\n   return true\n  }\n  memCmp := resources.Cmp(lhs[v1.ResourceMemory], rhs[v1.ResourceMemory])\n  if memCmp < 0 {\n   return false\n  } else if memCmp > 0 {\n   return true\n  }\n  return lhsPod.UID < rhsPod.UID\n }\n}\n위 과정을 마쳤다면 이제 본격적으로 스케줄링을 시도할 수 있는데요. 이후의 과정을 도식으로 나타나면 아래와 같아요.\n\n가장 먼저 큐에서 파드들을 하나씩 꺼내서 노드에 배치하기 시작하는데, 여기서 기본적인 kube-scheduler의 동작을 모방하기 시작해요. (소스코드)\n파드를 배치하고자 하는 노드에는 아래와 같은 우선순위로 작업이 진행돼요.\n\n클러스터 내 실제 노드에서 먼저 스케줄링 시도\n\n// 클러스터 내 실제 노드에서 먼저 스케줄링을 시도해요.\n for _, node := range s.existingNodes {\n  if err := node.Add(ctx, s.kubeClient, pod, s.cachedPodData[pod.UID]); err == nil {\n   return nil\n  }\n }\n2. 생성하려고 준비한 NodeClaim에 스케줄링 시도\n// Consider using https://pkg.go.dev/container/heap\n sort.Slice(s.newNodeClaims, func(a, b int) bool { return len(s.newNodeClaims[a].Pods) < len(s.newNodeClaims[b].Pods) })\n // 생성하려고 준비한 NodeClaim에도 스케줄링을 시도해요.\n for _, nodeClaim := range s.newNodeClaims {\n  if err := nodeClaim.Add(pod, s.cachedPodData[pod.UID]); err == nil {\n   return nil\n  }\n }\n3. 새로운 NodeClaim 생성\n// 노드를 새로 생성해요.\n var errs error\n for _, nodeClaimTemplate := range s.nodeClaimTemplates {\n  instanceTypes := nodeClaimTemplate.InstanceTypeOptions\n  // if limits have been applied to the nodepool, ensure we filter instance types to avoid violating those limits\n  if remaining, ok := s.remainingResources[nodeClaimTemplate.NodePoolName]; ok {\n   instanceTypes = filterByRemainingResources(instanceTypes, remaining)\n   ... // (validation)\n  }\n  nodeClaim := NewNodeClaim(nodeClaimTemplate, s.topology, s.daemonOverhead[nodeClaimTemplate], instanceTypes)\n  if err := nodeClaim.Add(pod, s.cachedPodData[pod.UID]); err != nil {\n   ... // (error handling)\n   continue\n  }\n  // we will launch this nodeClaim and need to track its maximum possible resource usage against our remaining resources\n  s.newNodeClaims = append(s.newNodeClaims, nodeClaim)\n  s.remainingResources[nodeClaimTemplate.NodePoolName] = subtractMax(s.remainingResources[nodeClaimTemplate.NodePoolName], nodeClaim.InstanceTypeOptions)\n  return nil\n }\n return errs\n위의 우선순위에 맞춰 yaml로 작성하는 수많은 규칙을 반영하기 위해, Karpenter 내에서 스케줄링할 노드를 지정해요. 그 과정은 아래 순서대로 진행돼요. (이 코드는 실제 클러스터에 존재하는 노드에 스케줄링하는 상황의 로직이고, NodeClaim에 파드를 추가하는 로직과는 분리되어 작성되어 있어요.)\n\n노드와 파드의 taint와 toleration의 일치 여부를 파악해요.\n\n// 노드와 파드의 taint-toleration이 일치해야 해요.\n if err := scheduling.Taints(n.cachedTaints).ToleratesPod(pod); err != nil {\n  return err\n }\n2. 노드가 기존에 존재하면, 노드의 volume 제한을 넘지 않는지 확인해요.\n// 노드가 기존에 존재하면, 노드의 volume 제한을 넘지 않도록 해요.\n volumes, err := scheduling.GetVolumes(ctx, kubeClient, pod)\n if err != nil {\n  return err\n }\n if err = n.VolumeUsage().ExceedsLimits(volumes); err != nil {\n  return fmt.Errorf(\"checking volume usage, %w\", err)\n }\n3. 노드의 포트를 중복해서 사용하는지 확인해요.\n// 노드의 포트를 중복해서 사용하는지 확인해요.\n hostPorts := scheduling.GetHostPorts(pod)\n if err = n.HostPortUsage().Conflicts(pod, hostPorts); err != nil {\n  return fmt.Errorf(\"checking host port usage, %w\", err)\n }\n4. 노드의 리소스 총량이 새로 뜰 파드를 포함한 request 수요를 감당할 수 있는지 확인해요. NodeClaim을 새로 생성한 경우에는 request 총량을 더해서 인스턴스를 새로 생성할 때 활용할 수 있도록 해요.\n // 노드의 리소스 총량이 새로 뜰 파드를 포함한 request 수요를 감당할 수 있는지 확인해요. \n // NodeClaim을 새로 생성한 경우에는 request 총량을 더해서 인스턴스를 새로 생성할 때 활용할 수 있도록 해요.\n requests := resources.Merge(n.requests, podData.Requests)\n if !resources.Fits(requests, n.cachedAvailable) {\n  return fmt.Errorf(\"exceeds node resources\")\n }\n5. nodeAffinity, nodeSelector를 확인해서 노드와 파드의 조건이 부합하는지 확인해요.\n// nodeAffinity, nodeSelector를 확인해서 노드와 파드의 조건이 부합하는지 확인해요.\nnodeRequirements := scheduling.NewRequirements(n.requirements.Values()...)\nif err = nodeRequirements.Compatible(podData.Requirements); err != nil {\n return err\n}nodeRequirements.Add(podData.Requirements.Values()...)\n6. 토폴로지 요건을 확인해요. 이 부분은 nodeAffinity와 topologySpreadConstraint이 공존하는데, 둘 다 이 과정에서 같이 확인하게 돼요. 여기서 preferred 설정이 들어가 있는 affinity는 계산에 포함되지 않게 돼요.\n// topology 요건을 확인해요.\n topologyRequirements, err := n.topology.AddRequirements(pod, n.cachedTaints, podData.StrictRequirements, nodeRequirements)\n if err != nil {\n  return err\n }\n if err = nodeRequirements.Compatible(topologyRequirements); err != nil {\n  return err\n }\n nodeRequirements.Add(topologyRequirements.Values()...)\n7. 위 과정을 큐 안에 있는 모든 파드들의 시뮬레이션이 완료될 때까지 반복해요.\nKarpenter를 활용한 스케줄링의 장점과 한계\n이 과정의 코드를 보게 되면 kube-scheduler의 기본적인 작동 알고리즘과 동일하게 작동하도록 여러 k8s 라이브러리들을 랩핑해서 내부에서 같은 순서로 로직을 돌리고 있어요. 이렇게 구현하면 NodeClaim의 수요를 빠르게 파악할 수 있어, Karpenter의 최대 강점 중 하나인 빠른 프로비저닝을 제공할 수 있어요.\n하지만 이 부분이 kube-scheduler와 완전하게 동일하다는 보장은 하긴 어려워요. 이 글을 작성하고 있는 Karpenter v1.1.1 현재, Kubernetes 1.28 버전에서 beta로 전환된 topologySpreadConstraints의 matchLabelKeys 는 스케줄링 과정에서 계산하지 않고 있어요. 저희는 Karpenter를 도입하기 이전, ReplicaSet 별로 skew를 계산하기 위해 matchLabelKey에 pod-template-hash (ReplicaSet 뒤의 난수)를 활용하고 있었는데, Karpenter를 사용하면서 이 기능을 포기해야 했어요.\n이 기능은 1년 넘게 Karpenter upstream PR에 올라가 있었다가 1.3.0 버전에서 반영되었어요. 이렇듯 Karpenter는 쿠버네티스의 버전에 따른 변경 사항들을 빠르게 따라오지 못하는 이슈가 있어요. 개인적으로는 kube-scheduler에 접근할 수 있는 인터페이스가 아직 없어서, 더 정확하고 각 버전에 맞는 스케줄링 로직으로 노드를 생성할 수 없다는 게 조금 아쉬웠어요.\n2. 커스텀 AMI를 사용할 때 제약사항이 있어요.\n당근페이는 보안규정을 준수하는 노드를 효율적으로 제작하고 사용하기 위해 골든 이미지를 만들어요. 골든 이미지란 보안 컴플라이언스를 준수하기 위한 설정들과 접근제어 처리를 한 이미지예요. 추가 설정을 위해 packer + ansible로 베이킹할 필요 없이 준비가 완료된 이미지를 의미하죠. EKS AMI도 이 과정을 거쳐서 생성하고 있는데, 이 이미지들을 활용하기 위해서 EC2NodeClass에 해당 AMI를 사용해야 했어요.\n우선 아무 설정 없이 AMI Family (OS)만 설정하면, AWS SSM Parameter Store로 이미지 AMI를 회수해요. (소스코드)\nfunc (a AL2023) resolvePath(architecture, variant, k8sVersion, amiVersion string) string {\n name := lo.Ternary(\n  amiVersion == v1.AliasVersionLatest,\n  \"recommended\",\n  fmt.Sprintf(\"amazon-eks-node-al2023-%s-%s-%s-%s\", architecture, variant, k8sVersion, amiVersion),\n )\n return fmt.Sprintf(\"/aws/service/eks/optimized-ami/%s/amazon-linux-2023/%s/%s/%s/image_id\", k8sVersion, architecture, variant, name)\n}\n하지만 저희의 커스텀 이미지를 Parameter Store에 보관한 다음 NodeClass 컨트롤러에서 주기적으로 변경 사항을 가져오는 기능은 없었어요. 대신 직접 AMI 지정하거나 AMI를 태그해서 가져올 수 있었는데요. 저희는 실제 프로덕션 환경으로 나가는 계정과 이러한 운영 작업을 위한 계정이 분리되어 있다는 게 문제였어요. AMI를 복사할 때 AMI에 붙은 태그를 타 계정으로 같이 이동시킬 수가 없었죠. 결국 이 과정에 추가적인 리소스를 사용해서 여러 개의 계정에 태그를 동시에 추가하는 별도의 파이프라인을 구성해야 했어요.\n3. 작은 노드 위주로 생성해요.\n\n저희는 기존에 2xlarge 노드를 기본으로 ASG를 구성하고 있었어요. 이를 그대로 Karpenter에 올렸더니, 그 이후부터는 xlarge 위주로 노드를 생성하기 시작했어요. Karpenter의 스케줄링 알고리즘에 따르면 현재 파드들의 resource 수요에 맞게 더 촘촘히 노드를 배치할 수 있어 이러한 접근이 유리해요. 그러나 동시에 노드 개수와 비례하여 증가하는 DaemonSet 비용을 무시할 수 없었기 때문에, 팀에서는 저희가 원하는 방향성으로 스케줄링이 되지 않는 이유를 찾아 나섰어요.\n그 원인은 저희가 설정한 budget에 있었어요. budget은 NodePool에서 consolidation의 reason 별로 동시에 몇 개의 노드를 삭제할 수 있는지 설정하는 값이에요. 저희는 전반적으로, 그리고 보수적으로 스케줄링하기 위해서 budget을 낮게 잡았고, 그 결과 MultiNodeConsolidation이 발생하지 않은 채 SingleNodeConsolidation만 발생했어요. 결국 하나하나의 노드를 삭제하게 되면서 여러 노드를 하나의 노드로 통합하는 액션이 실제로 작동되지 못했어요.\n하지만 budget을 높게 잡아서 disruption의 강도를 높이게 되면, 워크로드들을 너무 공격적으로 이동시키는 것이라고 판단했어요. 그래서 최소 노드 크기를 2xlarge로 설정해서 daemonset으로 인해 발생하게 되는 오버헤드를 줄이려고 했죠.\n4. 실제 리소스와 Karpenter에서 인식하는 리소스의 양에 차이가 있어요.\nKarpenter 메트릭을 수집하고 대시보드로 관찰하기 시작했는데, 노드들의 실제 리소스 양보다 Karpenter에서 계산한 리소스 양이 적다는 사실을 알게 되었어요. 이에 따라 더 공격적으로 프로비저닝이 발생해 안정성이 떨어졌어요. 게다가 실제 스케줄링과 어긋나는 엣지 케이스들도 발견되었죠.\n대시보드에는 EKS AMI와 인스턴스 타입에 따라 제공되는 인스턴스 리소스 크기가 표시되는데요. 정확한 리소스의 차이를 확인하기 위해 노드를 실제로 띄워서 확인해 본 결과, 실제 사용 가능한 리소스의 양과 일치하지 않았어요. 이 값은 OS, kubelet 등 노드를 운용하기 위해 필요한 컴포넌트들이 차지하는 공간인데, 이 공간에 대한 계산을 Karpenter에서 일괄적으로 퍼센티지로 설정해서 발생하는 이슈였어요. (소스코드)\nfunc memory(ctx context.Context, info ec2types.InstanceTypeInfo) *resource.Quantity {\n sizeInMib := *info.MemoryInfo.SizeInMiB\n ...\n mem := resources.Quantity(fmt.Sprintf(\"%dMi\", sizeInMib))\n // Account for VM overhead in calculation\n mem.Sub(resource.MustParse(fmt.Sprintf(\"%dMi\", int64(math.Ceil(float64(mem.Value())*options.FromContext(ctx).VMMemoryOverheadPercent/1024/1024)))))\n return mem\n}\n이 부분을 해결하기 위해 가장 먼저 AL2023 EKS AMI를 기준으로 인스턴스를 띄우면 제공되는 메모리양과 free 명령어를 통해 나오는 Available 메모리의 갭을 측정했어요. 이후 저희가 허용하는 인스턴스 중 가장 큰 갭을 기준으로 그 일괄적인 값을 반영해서 사용했어요. 다만, 이 해결법은 엣지 케이스의 빈도를 줄였지만, kube-scheduler에서 인식하는 상태와 Karpenter에서 인식하는 상태가 동일하지 않다는 문제가 있었어요.\n1.1.0 버전에서는 한 번 생성된 인스턴스의 실제 리소스 양을 캐싱하도록 패치됐어요. 덕분에 이후 같은 인스턴스 타입을 생성할 때 더 정확한 리소스 값을 반영할 수 있었어요. 특히, 이 업데이트로 인해 Karpenter의 리소스 계산 방식이 개선되면서, 평소 스케줄링의 정합성이 크게 향상되었어요.\n5. Node Churn이 발생해요.\nNode Churn은 Karpenter에서 consolidation이 한번 발생할 때 여러 개의 노드가 연쇄적으로 disruption되고 새로 생성되는 현상을 말해요. Churn은 휘젓는다는 뜻인데요. Node Churn이 발생하면 국자로 수프를 휘젓듯이 하나의 이벤트로 인해 많은 수의 워커 노드가 한 번에 재배치되기 시작해요.\n저희는 처음에 이 문제가 너무 급진적으로 consolidation budget을 잡았기 때문이라고 생각했어요. budget을 10%로 설정한 상태에서 진행했는데 pdb를 겨우 지키는 수준에서 파드들이 계속 노드 사이를 오갔어요. CPU 사용량이 급증하게 되었고, 무려 클러스터 전체 노드 중 약 50%가 순차적으로 지워지고 다시 생성됐어요.\ndrift처럼 보이지만, 사실은 created와 underutilized가 겹쳐서 노란색처럼 보이는 것이에요. 생성 → 삭제 → 생성 → 삭제 → …를 몇 시간 동안 반복하고 있었어요.\n그래서 모든 budget을 1로 설정하고 동시에 consolidation을 진행할 수 없게 하려고 했어요. 이에 따라 작은 노드를 큰 노드로 병합하는 MultiNodeConsolidation을 사용할 수 없게 됐죠. 하지만, 이렇게 해도 Node Churn이 지속적으로 발생했고, 어떨 때는 하루 종일 Churn이 발생하기도 했어요.\n이후 메트릭을 확인해 보니 모든 consolidation의 시작 시점은 파드 수요의 변경 시점에 있었어요. Node Churn이 크게 발생할 정도의 본격적인 consolidation은 주로 영업일 낮 시간대였는데요. 새로 배포를 진행하면서 rolling, canary 업데이트를 진행하면서 파드의 수요가 요동치는 거였어요.\n이 부분을 개선하고자 이후 개발자들이 배포하는 낮 시간대에는 budget을 1로, 그리고 새벽 시간대에는 budget을 2로 설정했어요. 밤에 budget이 모자라 consolidation이 밀려서 낮에 대규모로 churn이 발생하지 않도록 말이죠. 결과적으로 전체 노드의 10% 내에서 consolidation이 연쇄적으로 발생하는 수준까지 효과적으로 개선했어요.\n결과, 앞으로 할 일\nKarpenter를 도입하면서 저희는 여러 방면에서 긍정적인 효과를 보게 되었어요. 가장 큰 효과는 비용을 효율적으로 줄였다는 점이죠. 월간 인프라 비용을 약 10,000$ 절감할 수 있었어요. EKS 클러스터 업데이트 과정에서도 워커 노드의 AMI 교체, 노드의 점진적인 업데이트 등을 조금 더 손쉽게 작업할 수 있게 되었어요.\n다만 아직 더 개선해야 할 부분도 많아요:\n1. 노드 웜업 시간 개선\nKarpenter 도입 후 노드가 빠르게 스케일링되면서, 새로 생성된 노드가 워크로드를 정상적으로 처리하기까지 걸리는 초기 웜업 시간 문제가 발생했어요. 이를 해결하기 위해 다음과 같은 방법을 적용했어요:\n\n일정 수준의 여유 노드를 유지하는 Overprovisioning 파드를 활용해 모든 가용 영역(Zone)에서 최소한 하나의 노드를 항상 유지하도록 했어요. 이를 통해 갑작스러운 스케일 아웃 시에도 빠르게 대응할 수 있게 됐어요.\nJVM 서비스들에 readinessProbe를 통한 첫 접근을 유도해 클래스들을 미리 로딩함으로써 웜업 시간을 점진적으로 줄여나가고 있어요.\n\n2. 레이턴시 안정화\n기존에는 스케일링 없이 진행해서 서비스 레이턴시 증가가 눈에 띄지 않았는데, Karpenter로 인한 Node Churn과 배포가 동시에 일어나 레이턴시가 크게 튀는 경우도 발생했어요. 이를 개선하기 위해 Karpenter에서 제공하는 disruption 방지 어노테이션(karpenter.sh/do-not-disrupt)을 배포 중인 서비스에 자동으로 삽입하는 컨트롤러를 개발 중이에요. 이를 통해 더 안정적이면서도 비용 효율적인 인프라를 조성하기 위해 노력하고 있어요.\n3. 스케줄링 정합성 향상\nKarpenter와 k8s를 사용하면서 가장 불편함을 느꼈던 스케줄링 흐름 파악을 위해, 현재 Karpenter 스케줄링 시뮬레이터를 개발하고 있어요. 개발이 완료되면 Karpenter와 kube-scheduler의 스케줄링 정합성이 깨졌을 때, 빠르게 원인을 파악하고 문제를 해결할 수 있을 것으로 기대하고 있어요.\n당근페이 SRE로 오세요!\n당근페이는 전자금융업자로 많은 규제를 받고 있지만 가능한 한 여러 기술에 대해 열린 마음으로 접근하고 있어요. 저희 당근페이 SRE들은 개발자들의 배포 편의성과 인프라의 효율적 운영을 위해서라면, 어떤 기술이라도 심층적으로 분석해요. 또 그 기술이 필요하다고 판단되면 빠르게 도입하죠. 신뢰와 충돌이라는 신념 아래에서 동료들과 다양한 기술을 심도 있게 테스트하고 있어요.\n더 효율적이고 아름다운 인프라를 만들어가기 위해 저희와 함께할 분을 찾고 있어요. 많은 관심 부탁드려요!\nhttps://team.daangn.com/jobs/5792072003/\n\nKarpenter 트러블슈팅 — 비용과 안정성 두 마리 토끼 잡기 was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "Yany Choi",
        "guid": "https://medium.com/p/ce8bd45ec8f2",
        "categories": [
          "programming",
          "sre",
          "kubernetes",
          "karpenter"
        ],
        "isoDate": "2025-03-27T06:32:10.000Z"
      },
      {
        "creator": "Ho Yeon",
        "title": "구글처럼 복잡한 권한 쉽게 관리하기 feat. GraphQL",
        "link": "https://medium.com/daangn/%EA%B5%AC%EA%B8%80%EC%B2%98%EB%9F%BC-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EA%B6%8C%ED%95%9C-%EC%89%BD%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0-feat-graphql-9ce80d34d39b?source=rss----4505f82a2dbd---4",
        "pubDate": "Thu, 20 Mar 2025 08:21:54 GMT",
        "content:encoded": "<p>안녕하세요. 당근 알림 경험팀에서 프론트엔드 엔지니어로 일하고 있는 딜런(Dylan.lee)이라고 해요.</p><p>알림 경험팀은 당근 사용자들뿐만 아니라 당근 구성원들의 알림 경험(Notification Experiences)을 책임져요. 사용자가 그동안 받은 알림을 모아볼 수 있는 알림함부터 당근 구성원이 알림을 간편하게 발송할 수 있는 알림 센터까지, 알림과 관련된 다양한 서비스를 만들고 있죠.</p><p>알림 센터와 같은 서비스를 만들다 보면 필연적으로 인증과 인가를 다루게 돼요. 알림 센터는 다양한 소속의 당근 구성원들이 사용하기 때문에, 민감한 정보는 외부에 노출되지 않도록 소속에 따라 권한을 분리해야 하죠. 또한 마케팅성 알림은 마케팅 팀의 승인이 있는 경우에만 발송할 수 있어야 하고요.</p><p>이렇게 서비스가 복잡해지고 기능이 고도화될수록 인증과 관련된 코드가 길어지고 복잡해지는 문제가 생겼어요. 이번 글에서는 권한을 선언적으로 관리하며 코드의 복잡성을 효과적으로 개선한 방법을 소개해 드리려고 해요.</p><h3>역할을 기반으로 권한을 관리한다면?</h3><p>알림 센터에서는 사용자에게 발송되는 알림 내용을 템플릿 형태로 관리해요. 이것을 알림 시나리오라고 하는데요. 당근의 모든 구성원은 여기에 접근 권한을 갖고 있지만 외부 협력사는 볼 수 없어야 해요. 이러한 권한은 단순했기 때문에 간단한 분기만으로도 관리할 수 있었어요.</p><pre>const canAccess = (user, entity) =&gt; {<br>  if (entity === &quot;scenarioPage&quot; &amp;&amp; user.company === &quot;daangn&quot;) return true;<br>  return false;<br>}</pre><p>그러다 권한 정책이 업데이트되었어요. 외부 협력사 직원이더라도 특정 이메일 값을 갖는 사용자라면, 알림 시나리오 페이지에 접근 권한을 가지도록 수정이 필요했어요. 그래서 저는 allow list를 만들어 관리했어요.</p><pre>const allowList = [&quot;john@external.com&quot;];<br><br>const canAccess = (user, entity) =&gt; {<br>  if (entity === &quot;scenarioPage&quot; &amp;&amp; (user.company === &quot;daangn&quot; || allowList.includes(user.email))) return true;<br>  return false;<br>}</pre><p>그러다가 새로운 기능이 추가되었어요. 마케팅성 알림을 발송하기 전에는 마케팅팀에게 리뷰를 요청하고, 마케팅팀이 승인할 때만 발송할 수 있어야 했죠.</p><pre>const allowList = [&quot;john@external.com&quot;];<br><br>const canAccess = (user, entity) =&gt; {<br>  if (entity === &quot;scenarioPage&quot; &amp;&amp; (user.company === &quot;daangn&quot; || allowList.includes(user.email))) return true;<br>  if (entity === &quot;approveButton&quot; &amp;&amp; user.team === &quot;marketing&quot;) return true;<br>  return false;<br>}</pre><p>이번엔 알림 경험팀에 특수한 권한을 부여해야 했어요.</p><ul><li>아직 개발이 진행 중인 기능을 전사에 공개하기 전에 알림 경험팀만 먼저 사용할 수 있어야 했어요.</li><li>알림 경험팀은 모든 알림에 대해 승인 권한을 가져야 했어요.</li></ul><pre>const allowList = [&quot;john@external.com&quot;];<br><br>const canAccess = (user, entity) =&gt; {<br>  if (entity === &quot;scenarioPage&quot; &amp;&amp; (user.company === &quot;daangn&quot; || allowList.includes(user.email))) return true;<br>  if (entity === &quot;approveButton&quot; &amp;&amp; (user.team === &quot;marketing&quot; || user.team === &quot;nx&quot;)) return true;<br>  if (entity === &quot;experimental&quot; &amp;&amp; user.team === &quot;nx&quot;) return true;<br>  return false;<br>}</pre><p>권한이 복잡해질 때마다 코드가 읽기 어려워지니, 이건 지속 가능한 방법이 아니라는 생각이 들었어요.</p><h3>RBAC에서 ReBAC으로</h3><p>기존에 사용하던 방식을 <strong>RBAC(Role-Based Access Control)</strong>이라고 불러요. 사용자가 어떠한 권한을 가지고 있느냐에 따라서 접근 권한을 제어하는 방식인데요. 간단한 권한 관계에서는 효과적일 수 있지만, 관계가 복잡해질수록 가독성이 저하되고 관리하기 어렵다는 단점이 있어요. 위에서의 사례처럼 역할만을 기반으로 권한을 관리하다 보니 코드의 복잡성이 과도하게 증가하는 <strong>권한 폭발</strong>이 발생할 수도 있고요.</p><blockquote><strong>권한 폭발(Role Explosion)</strong></blockquote><blockquote>조직 구조가 복잡해지고 역할의 수가 기하급수적으로 증가하는 현상</blockquote><pre>const canAccess = (user, entity) =&gt; {<br>  if (entity === &quot;scenarioPage&quot; &amp;&amp; (user.company === &quot;daangn&quot; || user.email === &quot;john@external.com&quot;)) return true;<br>  if (entity === &quot;approveButton&quot; &amp;&amp; (user.team === &quot;marketing&quot; || user.team === &quot;nx&quot; || user.rank === &quot;manager&quot;)) return true;<br>  if (entity === &quot;experimental&quot; &amp;&amp; (user.team === &quot;nx&quot; || (user.team === &quot;engineering&quot; &amp;&amp; user.rank === &quot;senior&quot;))) return true;<br>  if (entity === &quot;reports&quot; &amp;&amp; (user.team === &quot;analytics&quot; || user.team === &quot;finance&quot; || user.email === &quot;ceo@daangn.com&quot;)) return true;<br>  if (entity === &quot;userAdmin&quot; &amp;&amp; (user.team === &quot;security&quot; || (user.rank === &quot;director&quot; &amp;&amp; user.department === &quot;IT&quot;))) return true;<br>  if (entity === &quot;settings&quot; &amp;&amp; (user.isAdmin || user.email === &quot;system@daangn.com&quot; || user.team === &quot;devops&quot;)) return true;<br>  if (entity === &quot;billing&quot; &amp;&amp; (user.team === &quot;finance&quot; || user.rank === &quot;vp&quot; || user.email.endsWith(&quot;@accounting.daangn.com&quot;))) return true;<br>  if (entity === &quot;metrics&quot; &amp;&amp; (user.hasMetricsAccess || user.team === &quot;data&quot; || (user.projects &amp;&amp; user.projects.includes(&quot;analytics&quot;)))) return true;<br>  return false;<br>}</pre><p>RBAC은 대상 엔티티(Entity, 상호작용하려고 하는 요소)마다 접근이 가능한지 판단해 줄 기준이 필요하고, 그 기준이 바로 역할이에요. 그런데 대상 엔티티가 위계를 가지고 있는 경우, 상위 엔티티에 역할이 추가될 때마다 하위 엔티티에도 역할을 추가해 주어야 해요. 예를 들어, 팀과 팀원처럼 사용자가 위계를 가지고 있는 경우, 팀 역할과 팀원 역할로 나누어서 관리되어야 해요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NeP27gYsiY-hUW5EMnouAw.png\" /></figure><p>서론에서 제시한 예제 중 “알림 시나리오 페이지 접근 권한” 부분만 도식화해 본 그림이에요. RBAC은 역할의 위계를 표현하지 못하기 때문에 특정 엔티티에 접근할 수 있는 모든 권한을 명시해 주어야 해요.</p><p>여기서 <strong>ReBAC(Relation-Based Access Control)</strong>을 사용하면 복잡한 권한을 더 쉽게 관리할 수 있어요. ReBAC은 구글의 Zanzibar에서도 사용하고 있는 권한 관리 방식인데요. RBAC과는 다르게 권한 간의 관계를 기반으로 권한을 제어해요.</p><p>ReBAC을 사용하면 팀과 팀원의 관계가 자연스럽게 연결돼요. 따라서 어떤 User가 직접 NotificationScenario에 접근할 수 있는 권한이 없더라도 member로 연결된 Team에 접근 권한이 있다면, 그 User는 NotificationScenario에 접근할 수 있다는 것을 알 수 있어요.</p><h3>TypeScript로 구현하기</h3><p>타입스크립트를 사용해서 ReBAC을 구현할 수 있는 다양한 방법들이 있어요. 저는 그중에서 graplix(<a href=\"https://github.com/daangn/graplix\">https://github.com/daangn/graplix</a>)를 사용했어요.</p><p>graplix는 당근에서 오픈소스로 공개한 ReBAC 기반 인증/인가 프레임워크예요. ReBAC의 권한 관계를 그래프로 표현할 수 있다는 점에서 착안해 GraphQL에서 영감을 받아 만들어졌어요. graplix를 사용해서 예시의 권한 관계를 구현해 볼게요.</p><h3>Step 1. 스키마 작성하기</h3><p><strong>[엔티티 간의 관계 표현하기]</strong></p><p>graplix는 스키마 우선 접근 방식(Schema-First Approach)을 사용해서 ReBAC을 만들고 있어요. 그래서 먼저 스키마를 작성해 주어야 해요.</p><pre>const schema = {<br>  Employee: {},<br>  Team: {},<br>  NotificationScenario: {}<br>}</pre><p>사용하고자 하는 엔티티를 타입으로 작성하면 돼요. 이 엔티티들은 그래프의 노드가 되고, 스키마에서 그 관계를 명시해 줄 거예요.</p><p>예를 들어 어떤 팀은 어떤 직원을 멤버로 가져요. 다시 말해보면,</p><blockquote><em>Team과 Employee는 member라는 관계를 맺는다.</em></blockquote><p>라고 쓸 수 있어요. 그 관계를 스키마로 표현하면 아래와 같아요.</p><pre>const schema = {<br>  Employee: {},<br>  Team: {<br>    member: {<br>      type: &quot;Employee&quot;<br>    }<br>  },<br>  NotificationScenario: {}<br>}</pre><p>그림으로 표현하면 아래처럼 표현할 수 있어요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8t76DvngOob2xVqkkwDDFw.png\" /></figure><p><strong>[관계 참조하기]</strong></p><p>마찬가지로 접근하고자 하는 타겟 엔티티와의 관계도 표현할 수 있어요.</p><pre>const schema = {<br>  Employee: {},<br>  Team: {<br>    member: {<br>      type: &quot;Employee&quot;<br>    }<br>  },<br>  NotificationScenario: {<br>    viewer_employee: {<br>      type: &quot;Employee&quot;<br>    },<br>  }<br>}</pre><p>Employee라는 엔티티와 NotificationScenario 엔티티는 viewer_employee라는 관계를 맺는다고 정의할 수 있어요. 마찬가지로 Team 엔티티와 NotificationScenario 엔티티는 Team 타입의 관계를 맺어요.</p><pre>const schema = {<br>  Employee: {},<br>  Team: {<br>    member: {<br>      type: &quot;Employee&quot;<br>    }<br>  },<br>  NotificationScenario: {<br>    viewer_team: {<br>      type: &quot;Team&quot;<br>    },<br>    viewer_employee: {<br>      type: &quot;Employee&quot;<br>    },<br>  }<br>}</pre><p>graplix에서는 when 절을 사용할 수 있는데요. 다른 관계를 참조해서 관계를 만들 수도 있어요. 예를 들어 can_access라는 관계를 만들고 “viewer_employee 관계일 때 접근 가능하다”라는 표현을 해주고 싶다면 아래처럼 써줄 수 있어요.</p><pre>const schema = {<br>  Employee: {},<br>  Team: {<br>    member: {<br>      type: &quot;Employee&quot;<br>    }<br>  },<br>  NotificationScenario: {<br>    viewer_team: {<br>      type: &quot;Team&quot;<br>    },<br>    viewer_employee: {<br>      type: &quot;Employee&quot;<br>    },<br>    can_access: [{ when: &quot;viewer_employee&quot; }]<br>  }<br>}</pre><p>지금까지 작성된 관계를 그림으로 표현해 보면 아래와 같아요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5KF2p1_OAIPMrkMDYSGgUA.png\" /></figure><p><strong>[관계 상속하기]</strong></p><p>from 절을 이용해서 관계를 상속해 줄 수도 있어요. 예를 들어, viewer_team은 Team 타입이고, Team 엔티티에는 member로 관계를 맺고 있는 Employee라는 엔티티가 있어요. 즉 “viewer_team의 member로 있는 Employee도 NotificationScenario에 접근할 수 있다”라는 걸 표현해 주기 위해서는 아래와 같이 표현해 줄 수 있어요.</p><pre>const schema = {<br>  Employee: {},<br>  Team: {<br>    member: {<br>      type: &quot;Employee&quot;<br>    }<br>  },<br>  NotificationScenario: {<br>    viewer_team: {<br>      type: &quot;Team&quot;<br>    },<br>    viewer_employee: {<br>      type: &quot;Employee&quot;<br>    },<br>    can_access: [<br>      { when: &quot;viewer_employee&quot; },<br>      { when: &quot;member&quot;, from: &quot;viewer_team&quot; }<br>    ]<br>  }<br>}</pre><p>추가된 관계를 그림으로 표현해 보면 아래와 같아요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pj2rbvShbI2i3zD2_qRDrA.png\" /></figure><p>이렇게 간단하게 작성한 스키마만으로,</p><ol><li>어떤 직원은 어떤 알림 시나리오에 접근 권한이 있다.</li><li>어떤 팀에 속하는 직원은 어떤 알림 시나리오에 접근 권한이 있다.</li></ol><p>라는 것을 표현해 줄 수 있게 되었어요. 나머지 관계도 스키마로 표현하면 아래와 같아요.</p><pre>const schema = {<br>  Employee: {},<br>  Team: {<br>    member: {<br>      type: &quot;Employee&quot;<br>    }<br>  },<br>  NotificationScenario: {<br>    viewer_team: {<br>      type: &quot;Team&quot;<br>    },<br>    viewer_employee: {<br>      type: &quot;Employee&quot;<br>    },<br>    reviewer: {<br>      type: &quot;Employee&quot;<br>    },<br>    can_access: [{ when: &quot;viewer_employee&quot; }, { when: &quot;member&quot;, from: &quot;viewer_team&quot; }],<br>    can_approve: [{ when: &quot;reviewer&quot; }]<br>  }<br>}</pre><p>만들어진 스키마를 도식화하면 아래와 같아요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*iQzb5AhoKH905QYLEYidBg.png\" /></figure><p>“알림 경험팀의 Dylan.lee가 NotificationScenario와 viewer 관계를 맺는가?”라는 조건은 다음과 같은 순서로 평가되어요.</p><ul><li>Dylan.lee라는 Employee 엔티티는 NotificationsExperiences팀이라는 Team 엔티티와 member 관계를 맺는지</li><li>NotificationsExperiences팀이라는 Team 엔티티와 NotificationScenario라는 엔티티가 viewer_team 관계를 맺는지</li></ul><p>두 관계가 참이라면 Dylan.lee는 NotificationScenario와 can_access 관계를 맺기 때문에 접근이 가능하다는 결과가 나와요.</p><h3>Step 2. Identify 함수 만들기</h3><p>identify 함수는 타입을 알 수 없는 엔티티를 입력받고 어떤 엔티티인지 구분해 주는 함수예요.</p><p>예를 들어 Employee는 email, Team은 code, NotificationScenario는 id를 식별자로 사용하고자 하면 아래와 같이 엔티티 타입을 만들어줄 수 있어요.</p><pre>type Entity = {<br>  Employee: { type: &quot;Employee&quot;; email: string };<br>  Team: { type: &quot;Team&quot;; code: string };<br>  NotificationScenario: { type: &quot;NotificationScenario&quot;; id: string };<br>}</pre><p>이제 identify 함수는 이렇게 써줄 수 있어요.</p><pre>const identify: GraplixIdentifier&lt;Entity&gt; = (entity) =&gt; {<br>  switch (entity.type) {<br>    case &#39;User&#39;:<br>      return { type: &#39;User&#39;, id: entity.email };<br>    case &#39;Team&#39;:<br>      return { type: &#39;Team&#39;, id: entity.code };<br>    case &#39;NotificationScenario&#39;:<br>      return { type: &#39;NotificationScenario&#39;, id: entity.id };<br>  }<br>};</pre><h3>Step 3. 리졸버 작성하기</h3><p>스키마를 정의했으니 이제 리졸버를 작성해 줘야 해요. 리졸버는 실제로 그 관계를 어떻게 평가할 것인지 작성해 주는 부분이에요. 여기서 Entity에 선언된 타입을 활용할 수 있어요. Employee 엔티티가 어떤 Team 엔티티와 member 관계를 맺는지 평가한다고 가정해 볼게요.</p><pre>const resolvers = {<br>  Employee: {},<br>  Team: {<br>    member: {<br>      type: &quot;Employee&quot;,<br>      async resolve(entity, context) {}<br>    }<br>  },<br>  // ...<br>}</pre><p>그러면 작성한 Entity 타입에 의해 resolve 메소드의 첫 번째 인자(entity)는 { type: &#39;Team&#39;, code: string } 타입을 가지게 돼요. entity.code를 이용해서 특정 부서에 속하는 사용자 목록을 반환할 수 있어요.</p><pre>const resolvers = {<br>  Employee: {},<br>  Team: {<br>    member: {<br>      type: &quot;Employee&quot;,<br>      async resolve(entity, context) {<br>        const employees = await context.listAllEmployees();<br>        const filteredEmployees = employees.filter((employee) =&gt; employee.code === code);<br>        <br>        return filteredEmployees;<br>      }<br>    }<br>  },<br>  // ...<br>}</pre><p>이제 작성한 리졸버와 스키마를 graplix 함수에 넣으면 check 함수를 반환해요.</p><pre>export const { check } = graplix({<br>  resolvers,<br>  schemas,<br>  identify,<br>  context: { listAllEmployees: () ⇒ /* ... */ }<br>})</pre><p>이제 check 함수를 활용하면 복잡한 권한을 간편하게 선언적으로 다룰 수 있게 돼요.</p><pre>const canAccess = await check({<br>  user: req.user,<br>  object: page,<br>  relation: &quot;can_access&quot;<br>});</pre><h3>Step 4. 활용하기</h3><p>이렇게 구현한 인증/인가 기술을 활용해서 기능별 권한 제어를 구현한 사례를 소개해 드릴게요. 알림 센터에서 가장 많이 쓰이고 있는 형태는 게이트 컴포넌트예요. &lt;Permission /&gt;이라는 이름으로 만들어 사용하고 있어요.</p><h3>&lt;Permission /&gt; 컴포넌트</h3><p>&lt;Permission /&gt;은 확인하고 싶은 featureId만 전달해 주면 현재 보고 있는 사용자의 정보를 담아 권한을 확인하고, 결과에 따라 해당 컴포넌트를 보여줄지 말지 결정해 주는 컴포넌트예요. 내부적으로 usePermission 훅을 사용하기 때문에 권한을 체크하는 과정에서 Suspense가 발생해요.</p><pre>type PermissionProps = {<br>  featureId: FeatureId;<br>  children: React.ReactNode;<br>  fallback?: React.ReactNode;<br>  decorate?: boolean | ((children: React.ReactNode) =&gt; React.ReactNode);<br>};</pre><p>featureId와 children 외에 fallback과 decorate props도 볼 수 있는데요. fallback은 권한이 없거나 인증에 실패했을 경우 보여줄 ReactNode를 입력받도록 하는 prop이에요. decorate는 어떤 featureId로 인가를 해주고 있는지 시각적으로 보여주기 위한 prop이에요.</p><p>&lt;Permission /&gt; 컴포넌트를 이용하면 이렇게 간단하게 인가 여부를 관리할 수 있어요.</p><pre>&lt;Permission featureId=&quot;read:notification-scenario&quot;&gt;<br>  &lt;Tab&gt;모니터링&lt;/Tab&gt;<br>&lt;/Permission&gt;</pre><h3>내부 구현</h3><p>실제 알림 센터에서는 BFF에서 graplix를 활용하고 있어요. 아래는 featureId에 따라 can_access를 평가하도록 설정한 코드예요.</p><pre>app.get(&quot;/api/authorize/:featureId&quot;, (req, res) =&gt; {<br>  const canAccess = await check({<br>    user: req.email,<br>    object: req.param.featureId,<br>    relation: &#39;can_access&#39;,<br>  });<br><br>  res.send(canAccess);<br>});</pre><p>그리고 usePermission 훅을 구현해서 리액트 클라이언트에서 쉽게 사용할 수 있어요. 예제 코드는 TanStack Query를 사용해서 구현한 예시예요.</p><pre>function usePermission(featureId) {<br>  const { data: hasPermission } = useSuspenseQuery({ <br>    queryKey: [&#39;permission&#39;, featureId], <br>    queryFn: async ({ queryKey }) =&gt; {<br>      const [_, featureId] = queryKey;<br>      const response = await fetch(`/api/authorize/${featureId}`);<br>    <br>      return response.json();<br>    }<br>  });<br>  <br>  return hasPermission;<br>  }<br>}</pre><p>이제 usePermission 훅을 이용해서 &lt;Permission /&gt; 컴포넌트를 만들 수 있어요. usePermission이 반환한 결과가 true라면 children을, false라면 fallback을 반환해 줌으로써 권한이 없는 경우를 핸들링해 줄 수 있어요.</p><pre>function Permission({ featureId, children, fallback, decorate }: PermissionProps): React.ReactNode {<br>  const hasPermission = usePermission(featureId);<br><br>  if (!hasPermission) {<br>    return fallback;<br>  }<br><br>  return children;<br>});</pre><p>기존에 사용하던 &lt;Permission /&gt; 컴포넌트가 어떤 컴포넌트를 제어하고 있는지 파악하기 어렵다는 의견이 있었어요. 실제로 전사에 정식으로 공개한 새로운 기능이 일부 구성원에게 보이지 않았던 문제가 있었고, 이것을 해결하기 위해 decorate를 추가했어요.</p><pre>function Permission({ featureId, children, fallback, decorate }: PermissionProps): React.ReactNode {<br>  const hasPermission = usePermission(featureId);<br><br>  if (!hasPermission) {<br>    return fallback;<br>  }<br><br>  if (typeof decorate === &#39;function&#39;) {<br>    return decorate(children);<br>  }<br><br>  if (decorate === true) {<br>    return &lt;Decorator featureId={featureId}&gt;{children}&lt;/Decorator&gt;;<br>  }<br><br>  return children;<br>});</pre><p>decorate prop은 boolean 혹은 render prop 형태로 제공돼요. 직접 사용하는 곳에서 컴포넌트를 만들어 주입할 수 있고, 그렇지 않으면 &lt;Decorator /&gt; 컴포넌트로 감싸게 돼요. 모든 곳에 테두리를 추가하면 시각적으로 복잡해지니 이렇게 분기를 추가해 두었어요.</p><p>&lt;Decorator /&gt; 컴포넌트는 radix의 &lt;Slot /&gt; 컴포넌트를 활용했어요. 자식 컴포넌트의 레이아웃을 바꾸지 않고 border 스타일을 주입해 주는 용도로 사용하고 있어요.</p><pre>export const Decorator = ({ children, featureId, ...props }: DecoratorProps) =&gt; {<br>  return (<br>    &lt;div style={{ position: &#39;relative&#39; }}&gt;<br>      &lt;span<br>        style={{<br>          position: &#39;absolute&#39;,<br>          top: 0,<br>          right: 0,<br>          // ...<br>        }}<br>      &gt;<br>        {featureId}<br>      &lt;/span&gt;<br>      &lt;Slot {...props} style={{ border: &#39;2px solid hsl(var(--destructive))&#39; }}&gt;<br>        {children}<br>      &lt;/Slot&gt;<br>    &lt;/div&gt;<br>  );<br>};</pre><p>&lt;Decorator /&gt; 컴포넌트가 적용된 실제 모습은 아래와 같아요.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kJOrs5D88g0Yuv_q0NyU5g.png\" /></figure><p>이제 이렇게 &lt;Permission /&gt;으로 감싸주기만 하면, 더 이상 if 문을 작성할 필요 없이 복잡한 권한들을 단순하게 제어하고 관리/추적할 수 있게 되었어요.</p><h3>마치며</h3><p>ReBAC을 적용하기 전에는 아래와 같이 써야 했던 코드가,</p><pre>function App() {<br>  const user = getUserInfo();<br>  const canViewMonitoring = user.team.codes.includes(&quot;CODE0001&quot;);<br>  <br>  return (<br>    &lt;Tabs&gt;<br>      &lt;Tab&gt;기본 정보&lt;/Tab&gt;<br>      &lt;Tab&gt;통계&lt;/Tab&gt;<br>      {canViewMonitoring &amp;&amp; (<br>        &lt;Tab&gt;모니터링&lt;/Tab&gt;<br>      )}<br>      &lt;Tab&gt;시나리오 버전 정보&lt;/Tab&gt;<br>    &lt;/Tabs&gt;<br>  );  <br>}</pre><p>이렇게 같이 간단하고 선언적인 코드로 바뀔 수 있었어요.</p><pre>function App() {<br>  return (<br>    &lt;Tabs&gt;<br>      &lt;Tab&gt;기본 정보&lt;/Tab&gt;<br>      &lt;Tab&gt;통계&lt;/Tab&gt;<br>      &lt;Permission featureId=&quot;nx&quot;&gt;<br>        &lt;Tab&gt;모니터링&lt;/Tab&gt;<br>      &lt;/Permission&gt;<br>      &lt;Tab&gt;시나리오 버전 정보&lt;/Tab&gt;<br>    &lt;/Tabs&gt;<br>  );  <br>}</pre><p>이번 글에서는 ReBAC을 이용해서 점점 복잡해지는 권한을 잘 다루는 법을 알아봤어요. 그런데 ReBAC에도 한계가 있어요. 관계가 복잡해지고 노드가 많아질수록 N+1 문제가 생길 확률이 높아질 수 있어요. 저희 팀 같은 경우에는 Dataloader나 적절한 캐싱으로 N+1 문제를 방지하고 있어요. 이런 부분들을 인지하고 사용한다면 ReBAC과 그 구현체인 graplix에도 높은 잠재력이 있다고 생각해요. graplix에 관심이 생겼다면 독자 여러분도 graplix에 많은 기여해 보시길 바라요!</p><ul><li>참조</li><li><a href=\"https://permify.co/post/role-explosion/\">https://permify.co/post/role-explosion/</a></li><li><a href=\"https://www.osohq.com/academy/relationship-based-access-control-rebac\">https://www.osohq.com/academy/relationship-based-access-control-rebac</a></li><li><a href=\"https://www.okta.com/blog/2023/06/authorization-back-to-basics-rbac-vs-rebac/\">https://www.okta.com/blog/2023/06/authorization-back-to-basics-rbac-vs-rebac/</a></li><li><a href=\"https://www.okta.com/kr/identity-101/role-based-access-control-vs-attribute-based-access-control/\">https://www.okta.com/kr/identity-101/role-based-access-control-vs-attribute-based-access-control/</a></li></ul><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9ce80d34d39b\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/%EA%B5%AC%EA%B8%80%EC%B2%98%EB%9F%BC-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EA%B6%8C%ED%95%9C-%EC%89%BD%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0-feat-graphql-9ce80d34d39b\">구글처럼 복잡한 권한 쉽게 관리하기 feat. GraphQL</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "안녕하세요. 당근 알림 경험팀에서 프론트엔드 엔지니어로 일하고 있는 딜런(Dylan.lee)이라고 해요.\n알림 경험팀은 당근 사용자들뿐만 아니라 당근 구성원들의 알림 경험(Notification Experiences)을 책임져요. 사용자가 그동안 받은 알림을 모아볼 수 있는 알림함부터 당근 구성원이 알림을 간편하게 발송할 수 있는 알림 센터까지, 알림과 관련된 다양한 서비스를 만들고 있죠.\n알림 센터와 같은 서비스를 만들다 보면 필연적으로 인증과 인가를 다루게 돼요. 알림 센터는 다양한 소속의 당근 구성원들이 사용하기 때문에, 민감한 정보는 외부에 노출되지 않도록 소속에 따라 권한을 분리해야 하죠. 또한 마케팅성 알림은 마케팅 팀의 승인이 있는 경우에만 발송할 수 있어야 하고요.\n이렇게 서비스가 복잡해지고 기능이 고도화될수록 인증과 관련된 코드가 길어지고 복잡해지는 문제가 생겼어요. 이번 글에서는 권한을 선언적으로 관리하며 코드의 복잡성을 효과적으로 개선한 방법을 소개해 드리려고 해요.\n역할을 기반으로 권한을 관리한다면?\n알림 센터에서는 사용자에게 발송되는 알림 내용을 템플릿 형태로 관리해요. 이것을 알림 시나리오라고 하는데요. 당근의 모든 구성원은 여기에 접근 권한을 갖고 있지만 외부 협력사는 볼 수 없어야 해요. 이러한 권한은 단순했기 때문에 간단한 분기만으로도 관리할 수 있었어요.\nconst canAccess = (user, entity) => {\n  if (entity === \"scenarioPage\" && user.company === \"daangn\") return true;\n  return false;\n}\n그러다 권한 정책이 업데이트되었어요. 외부 협력사 직원이더라도 특정 이메일 값을 갖는 사용자라면, 알림 시나리오 페이지에 접근 권한을 가지도록 수정이 필요했어요. 그래서 저는 allow list를 만들어 관리했어요.\nconst allowList = [\"john@external.com\"];\nconst canAccess = (user, entity) => {\n  if (entity === \"scenarioPage\" && (user.company === \"daangn\" || allowList.includes(user.email))) return true;\n  return false;\n}\n그러다가 새로운 기능이 추가되었어요. 마케팅성 알림을 발송하기 전에는 마케팅팀에게 리뷰를 요청하고, 마케팅팀이 승인할 때만 발송할 수 있어야 했죠.\nconst allowList = [\"john@external.com\"];\nconst canAccess = (user, entity) => {\n  if (entity === \"scenarioPage\" && (user.company === \"daangn\" || allowList.includes(user.email))) return true;\n  if (entity === \"approveButton\" && user.team === \"marketing\") return true;\n  return false;\n}\n이번엔 알림 경험팀에 특수한 권한을 부여해야 했어요.\n\n아직 개발이 진행 중인 기능을 전사에 공개하기 전에 알림 경험팀만 먼저 사용할 수 있어야 했어요.\n알림 경험팀은 모든 알림에 대해 승인 권한을 가져야 했어요.\n\nconst allowList = [\"john@external.com\"];\nconst canAccess = (user, entity) => {\n  if (entity === \"scenarioPage\" && (user.company === \"daangn\" || allowList.includes(user.email))) return true;\n  if (entity === \"approveButton\" && (user.team === \"marketing\" || user.team === \"nx\")) return true;\n  if (entity === \"experimental\" && user.team === \"nx\") return true;\n  return false;\n}\n권한이 복잡해질 때마다 코드가 읽기 어려워지니, 이건 지속 가능한 방법이 아니라는 생각이 들었어요.\nRBAC에서 ReBAC으로\n기존에 사용하던 방식을 RBAC(Role-Based Access Control)이라고 불러요. 사용자가 어떠한 권한을 가지고 있느냐에 따라서 접근 권한을 제어하는 방식인데요. 간단한 권한 관계에서는 효과적일 수 있지만, 관계가 복잡해질수록 가독성이 저하되고 관리하기 어렵다는 단점이 있어요. 위에서의 사례처럼 역할만을 기반으로 권한을 관리하다 보니 코드의 복잡성이 과도하게 증가하는 권한 폭발이 발생할 수도 있고요.\n권한 폭발(Role Explosion)\n조직 구조가 복잡해지고 역할의 수가 기하급수적으로 증가하는 현상\nconst canAccess = (user, entity) => {\n  if (entity === \"scenarioPage\" && (user.company === \"daangn\" || user.email === \"john@external.com\")) return true;\n  if (entity === \"approveButton\" && (user.team === \"marketing\" || user.team === \"nx\" || user.rank === \"manager\")) return true;\n  if (entity === \"experimental\" && (user.team === \"nx\" || (user.team === \"engineering\" && user.rank === \"senior\"))) return true;\n  if (entity === \"reports\" && (user.team === \"analytics\" || user.team === \"finance\" || user.email === \"ceo@daangn.com\")) return true;\n  if (entity === \"userAdmin\" && (user.team === \"security\" || (user.rank === \"director\" && user.department === \"IT\"))) return true;\n  if (entity === \"settings\" && (user.isAdmin || user.email === \"system@daangn.com\" || user.team === \"devops\")) return true;\n  if (entity === \"billing\" && (user.team === \"finance\" || user.rank === \"vp\" || user.email.endsWith(\"@accounting.daangn.com\"))) return true;\n  if (entity === \"metrics\" && (user.hasMetricsAccess || user.team === \"data\" || (user.projects && user.projects.includes(\"analytics\")))) return true;\n  return false;\n}\nRBAC은 대상 엔티티(Entity, 상호작용하려고 하는 요소)마다 접근이 가능한지 판단해 줄 기준이 필요하고, 그 기준이 바로 역할이에요. 그런데 대상 엔티티가 위계를 가지고 있는 경우, 상위 엔티티에 역할이 추가될 때마다 하위 엔티티에도 역할을 추가해 주어야 해요. 예를 들어, 팀과 팀원처럼 사용자가 위계를 가지고 있는 경우, 팀 역할과 팀원 역할로 나누어서 관리되어야 해요.\n\n서론에서 제시한 예제 중 “알림 시나리오 페이지 접근 권한” 부분만 도식화해 본 그림이에요. RBAC은 역할의 위계를 표현하지 못하기 때문에 특정 엔티티에 접근할 수 있는 모든 권한을 명시해 주어야 해요.\n여기서 ReBAC(Relation-Based Access Control)을 사용하면 복잡한 권한을 더 쉽게 관리할 수 있어요. ReBAC은 구글의 Zanzibar에서도 사용하고 있는 권한 관리 방식인데요. RBAC과는 다르게 권한 간의 관계를 기반으로 권한을 제어해요.\nReBAC을 사용하면 팀과 팀원의 관계가 자연스럽게 연결돼요. 따라서 어떤 User가 직접 NotificationScenario에 접근할 수 있는 권한이 없더라도 member로 연결된 Team에 접근 권한이 있다면, 그 User는 NotificationScenario에 접근할 수 있다는 것을 알 수 있어요.\nTypeScript로 구현하기\n타입스크립트를 사용해서 ReBAC을 구현할 수 있는 다양한 방법들이 있어요. 저는 그중에서 graplix(https://github.com/daangn/graplix)를 사용했어요.\ngraplix는 당근에서 오픈소스로 공개한 ReBAC 기반 인증/인가 프레임워크예요. ReBAC의 권한 관계를 그래프로 표현할 수 있다는 점에서 착안해 GraphQL에서 영감을 받아 만들어졌어요. graplix를 사용해서 예시의 권한 관계를 구현해 볼게요.\nStep 1. 스키마 작성하기\n[엔티티 간의 관계 표현하기]\ngraplix는 스키마 우선 접근 방식(Schema-First Approach)을 사용해서 ReBAC을 만들고 있어요. 그래서 먼저 스키마를 작성해 주어야 해요.\nconst schema = {\n  Employee: {},\n  Team: {},\n  NotificationScenario: {}\n}\n사용하고자 하는 엔티티를 타입으로 작성하면 돼요. 이 엔티티들은 그래프의 노드가 되고, 스키마에서 그 관계를 명시해 줄 거예요.\n예를 들어 어떤 팀은 어떤 직원을 멤버로 가져요. 다시 말해보면,\nTeam과 Employee는 member라는 관계를 맺는다.\n라고 쓸 수 있어요. 그 관계를 스키마로 표현하면 아래와 같아요.\nconst schema = {\n  Employee: {},\n  Team: {\n    member: {\n      type: \"Employee\"\n    }\n  },\n  NotificationScenario: {}\n}\n그림으로 표현하면 아래처럼 표현할 수 있어요.\n\n[관계 참조하기]\n마찬가지로 접근하고자 하는 타겟 엔티티와의 관계도 표현할 수 있어요.\nconst schema = {\n  Employee: {},\n  Team: {\n    member: {\n      type: \"Employee\"\n    }\n  },\n  NotificationScenario: {\n    viewer_employee: {\n      type: \"Employee\"\n    },\n  }\n}\nEmployee라는 엔티티와 NotificationScenario 엔티티는 viewer_employee라는 관계를 맺는다고 정의할 수 있어요. 마찬가지로 Team 엔티티와 NotificationScenario 엔티티는 Team 타입의 관계를 맺어요.\nconst schema = {\n  Employee: {},\n  Team: {\n    member: {\n      type: \"Employee\"\n    }\n  },\n  NotificationScenario: {\n    viewer_team: {\n      type: \"Team\"\n    },\n    viewer_employee: {\n      type: \"Employee\"\n    },\n  }\n}\ngraplix에서는 when 절을 사용할 수 있는데요. 다른 관계를 참조해서 관계를 만들 수도 있어요. 예를 들어 can_access라는 관계를 만들고 “viewer_employee 관계일 때 접근 가능하다”라는 표현을 해주고 싶다면 아래처럼 써줄 수 있어요.\nconst schema = {\n  Employee: {},\n  Team: {\n    member: {\n      type: \"Employee\"\n    }\n  },\n  NotificationScenario: {\n    viewer_team: {\n      type: \"Team\"\n    },\n    viewer_employee: {\n      type: \"Employee\"\n    },\n    can_access: [{ when: \"viewer_employee\" }]\n  }\n}\n지금까지 작성된 관계를 그림으로 표현해 보면 아래와 같아요.\n\n[관계 상속하기]\nfrom 절을 이용해서 관계를 상속해 줄 수도 있어요. 예를 들어, viewer_team은 Team 타입이고, Team 엔티티에는 member로 관계를 맺고 있는 Employee라는 엔티티가 있어요. 즉 “viewer_team의 member로 있는 Employee도 NotificationScenario에 접근할 수 있다”라는 걸 표현해 주기 위해서는 아래와 같이 표현해 줄 수 있어요.\nconst schema = {\n  Employee: {},\n  Team: {\n    member: {\n      type: \"Employee\"\n    }\n  },\n  NotificationScenario: {\n    viewer_team: {\n      type: \"Team\"\n    },\n    viewer_employee: {\n      type: \"Employee\"\n    },\n    can_access: [\n      { when: \"viewer_employee\" },\n      { when: \"member\", from: \"viewer_team\" }\n    ]\n  }\n}\n추가된 관계를 그림으로 표현해 보면 아래와 같아요.\n\n이렇게 간단하게 작성한 스키마만으로,\n\n어떤 직원은 어떤 알림 시나리오에 접근 권한이 있다.\n어떤 팀에 속하는 직원은 어떤 알림 시나리오에 접근 권한이 있다.\n\n라는 것을 표현해 줄 수 있게 되었어요. 나머지 관계도 스키마로 표현하면 아래와 같아요.\nconst schema = {\n  Employee: {},\n  Team: {\n    member: {\n      type: \"Employee\"\n    }\n  },\n  NotificationScenario: {\n    viewer_team: {\n      type: \"Team\"\n    },\n    viewer_employee: {\n      type: \"Employee\"\n    },\n    reviewer: {\n      type: \"Employee\"\n    },\n    can_access: [{ when: \"viewer_employee\" }, { when: \"member\", from: \"viewer_team\" }],\n    can_approve: [{ when: \"reviewer\" }]\n  }\n}\n만들어진 스키마를 도식화하면 아래와 같아요.\n\n“알림 경험팀의 Dylan.lee가 NotificationScenario와 viewer 관계를 맺는가?”라는 조건은 다음과 같은 순서로 평가되어요.\n\nDylan.lee라는 Employee 엔티티는 NotificationsExperiences팀이라는 Team 엔티티와 member 관계를 맺는지\nNotificationsExperiences팀이라는 Team 엔티티와 NotificationScenario라는 엔티티가 viewer_team 관계를 맺는지\n\n두 관계가 참이라면 Dylan.lee는 NotificationScenario와 can_access 관계를 맺기 때문에 접근이 가능하다는 결과가 나와요.\nStep 2. Identify 함수 만들기\nidentify 함수는 타입을 알 수 없는 엔티티를 입력받고 어떤 엔티티인지 구분해 주는 함수예요.\n예를 들어 Employee는 email, Team은 code, NotificationScenario는 id를 식별자로 사용하고자 하면 아래와 같이 엔티티 타입을 만들어줄 수 있어요.\ntype Entity = {\n  Employee: { type: \"Employee\"; email: string };\n  Team: { type: \"Team\"; code: string };\n  NotificationScenario: { type: \"NotificationScenario\"; id: string };\n}\n이제 identify 함수는 이렇게 써줄 수 있어요.\nconst identify: GraplixIdentifier<Entity> = (entity) => {\n  switch (entity.type) {\n    case 'User':\n      return { type: 'User', id: entity.email };\n    case 'Team':\n      return { type: 'Team', id: entity.code };\n    case 'NotificationScenario':\n      return { type: 'NotificationScenario', id: entity.id };\n  }\n};\nStep 3. 리졸버 작성하기\n스키마를 정의했으니 이제 리졸버를 작성해 줘야 해요. 리졸버는 실제로 그 관계를 어떻게 평가할 것인지 작성해 주는 부분이에요. 여기서 Entity에 선언된 타입을 활용할 수 있어요. Employee 엔티티가 어떤 Team 엔티티와 member 관계를 맺는지 평가한다고 가정해 볼게요.\nconst resolvers = {\n  Employee: {},\n  Team: {\n    member: {\n      type: \"Employee\",\n      async resolve(entity, context) {}\n    }\n  },\n  // ...\n}\n그러면 작성한 Entity 타입에 의해 resolve 메소드의 첫 번째 인자(entity)는 { type: 'Team', code: string } 타입을 가지게 돼요. entity.code를 이용해서 특정 부서에 속하는 사용자 목록을 반환할 수 있어요.\nconst resolvers = {\n  Employee: {},\n  Team: {\n    member: {\n      type: \"Employee\",\n      async resolve(entity, context) {\n        const employees = await context.listAllEmployees();\n        const filteredEmployees = employees.filter((employee) => employee.code === code);\n        \n        return filteredEmployees;\n      }\n    }\n  },\n  // ...\n}\n이제 작성한 리졸버와 스키마를 graplix 함수에 넣으면 check 함수를 반환해요.\nexport const { check } = graplix({\n  resolvers,\n  schemas,\n  identify,\n  context: { listAllEmployees: () ⇒ /* ... */ }\n})\n이제 check 함수를 활용하면 복잡한 권한을 간편하게 선언적으로 다룰 수 있게 돼요.\nconst canAccess = await check({\n  user: req.user,\n  object: page,\n  relation: \"can_access\"\n});\nStep 4. 활용하기\n이렇게 구현한 인증/인가 기술을 활용해서 기능별 권한 제어를 구현한 사례를 소개해 드릴게요. 알림 센터에서 가장 많이 쓰이고 있는 형태는 게이트 컴포넌트예요. <Permission />이라는 이름으로 만들어 사용하고 있어요.\n<Permission /> 컴포넌트\n<Permission />은 확인하고 싶은 featureId만 전달해 주면 현재 보고 있는 사용자의 정보를 담아 권한을 확인하고, 결과에 따라 해당 컴포넌트를 보여줄지 말지 결정해 주는 컴포넌트예요. 내부적으로 usePermission 훅을 사용하기 때문에 권한을 체크하는 과정에서 Suspense가 발생해요.\ntype PermissionProps = {\n  featureId: FeatureId;\n  children: React.ReactNode;\n  fallback?: React.ReactNode;\n  decorate?: boolean | ((children: React.ReactNode) => React.ReactNode);\n};\nfeatureId와 children 외에 fallback과 decorate props도 볼 수 있는데요. fallback은 권한이 없거나 인증에 실패했을 경우 보여줄 ReactNode를 입력받도록 하는 prop이에요. decorate는 어떤 featureId로 인가를 해주고 있는지 시각적으로 보여주기 위한 prop이에요.\n<Permission /> 컴포넌트를 이용하면 이렇게 간단하게 인가 여부를 관리할 수 있어요.\n<Permission featureId=\"read:notification-scenario\">\n  <Tab>모니터링</Tab>\n</Permission>\n내부 구현\n실제 알림 센터에서는 BFF에서 graplix를 활용하고 있어요. 아래는 featureId에 따라 can_access를 평가하도록 설정한 코드예요.\napp.get(\"/api/authorize/:featureId\", (req, res) => {\n  const canAccess = await check({\n    user: req.email,\n    object: req.param.featureId,\n    relation: 'can_access',\n  });\n  res.send(canAccess);\n});\n그리고 usePermission 훅을 구현해서 리액트 클라이언트에서 쉽게 사용할 수 있어요. 예제 코드는 TanStack Query를 사용해서 구현한 예시예요.\nfunction usePermission(featureId) {\n  const { data: hasPermission } = useSuspenseQuery({ \n    queryKey: ['permission', featureId], \n    queryFn: async ({ queryKey }) => {\n      const [_, featureId] = queryKey;\n      const response = await fetch(`/api/authorize/${featureId}`);\n    \n      return response.json();\n    }\n  });\n  \n  return hasPermission;\n  }\n}\n이제 usePermission 훅을 이용해서 <Permission /> 컴포넌트를 만들 수 있어요. usePermission이 반환한 결과가 true라면 children을, false라면 fallback을 반환해 줌으로써 권한이 없는 경우를 핸들링해 줄 수 있어요.\nfunction Permission({ featureId, children, fallback, decorate }: PermissionProps): React.ReactNode {\n  const hasPermission = usePermission(featureId);\n  if (!hasPermission) {\n    return fallback;\n  }\n  return children;\n});\n기존에 사용하던 <Permission /> 컴포넌트가 어떤 컴포넌트를 제어하고 있는지 파악하기 어렵다는 의견이 있었어요. 실제로 전사에 정식으로 공개한 새로운 기능이 일부 구성원에게 보이지 않았던 문제가 있었고, 이것을 해결하기 위해 decorate를 추가했어요.\nfunction Permission({ featureId, children, fallback, decorate }: PermissionProps): React.ReactNode {\n  const hasPermission = usePermission(featureId);\n  if (!hasPermission) {\n    return fallback;\n  }\n  if (typeof decorate === 'function') {\n    return decorate(children);\n  }\n  if (decorate === true) {\n    return <Decorator featureId={featureId}>{children}</Decorator>;\n  }\n  return children;\n});\ndecorate prop은 boolean 혹은 render prop 형태로 제공돼요. 직접 사용하는 곳에서 컴포넌트를 만들어 주입할 수 있고, 그렇지 않으면 <Decorator /> 컴포넌트로 감싸게 돼요. 모든 곳에 테두리를 추가하면 시각적으로 복잡해지니 이렇게 분기를 추가해 두었어요.\n<Decorator /> 컴포넌트는 radix의 <Slot /> 컴포넌트를 활용했어요. 자식 컴포넌트의 레이아웃을 바꾸지 않고 border 스타일을 주입해 주는 용도로 사용하고 있어요.\nexport const Decorator = ({ children, featureId, ...props }: DecoratorProps) => {\n  return (\n    <div style={{ position: 'relative' }}>\n      <span\n        style={{\n          position: 'absolute',\n          top: 0,\n          right: 0,\n          // ...\n        }}\n      >\n        {featureId}\n      </span>\n      <Slot {...props} style={{ border: '2px solid hsl(var(--destructive))' }}>\n        {children}\n      </Slot>\n    </div>\n  );\n};\n<Decorator /> 컴포넌트가 적용된 실제 모습은 아래와 같아요.\n\n이제 이렇게 <Permission />으로 감싸주기만 하면, 더 이상 if 문을 작성할 필요 없이 복잡한 권한들을 단순하게 제어하고 관리/추적할 수 있게 되었어요.\n마치며\nReBAC을 적용하기 전에는 아래와 같이 써야 했던 코드가,\nfunction App() {\n  const user = getUserInfo();\n  const canViewMonitoring = user.team.codes.includes(\"CODE0001\");\n  \n  return (\n    <Tabs>\n      <Tab>기본 정보</Tab>\n      <Tab>통계</Tab>\n      {canViewMonitoring && (\n        <Tab>모니터링</Tab>\n      )}\n      <Tab>시나리오 버전 정보</Tab>\n    </Tabs>\n  );  \n}\n이렇게 같이 간단하고 선언적인 코드로 바뀔 수 있었어요.\nfunction App() {\n  return (\n    <Tabs>\n      <Tab>기본 정보</Tab>\n      <Tab>통계</Tab>\n      <Permission featureId=\"nx\">\n        <Tab>모니터링</Tab>\n      </Permission>\n      <Tab>시나리오 버전 정보</Tab>\n    </Tabs>\n  );  \n}\n이번 글에서는 ReBAC을 이용해서 점점 복잡해지는 권한을 잘 다루는 법을 알아봤어요. 그런데 ReBAC에도 한계가 있어요. 관계가 복잡해지고 노드가 많아질수록 N+1 문제가 생길 확률이 높아질 수 있어요. 저희 팀 같은 경우에는 Dataloader나 적절한 캐싱으로 N+1 문제를 방지하고 있어요. 이런 부분들을 인지하고 사용한다면 ReBAC과 그 구현체인 graplix에도 높은 잠재력이 있다고 생각해요. graplix에 관심이 생겼다면 독자 여러분도 graplix에 많은 기여해 보시길 바라요!\n\n참조\nhttps://permify.co/post/role-explosion/\nhttps://www.osohq.com/academy/relationship-based-access-control-rebac\nhttps://www.okta.com/blog/2023/06/authorization-back-to-basics-rbac-vs-rebac/\nhttps://www.okta.com/kr/identity-101/role-based-access-control-vs-attribute-based-access-control/\n\n구글처럼 복잡한 권한 쉽게 관리하기 feat. GraphQL was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "Ho Yeon",
        "guid": "https://medium.com/p/9ce80d34d39b",
        "categories": [
          "programming",
          "access-control",
          "rebac",
          "authorization"
        ],
        "isoDate": "2025-03-20T08:21:54.000Z"
      },
      {
        "creator": "Ina Jeon",
        "title": "건강한 SEO로 성장하는 웹사이트 만들기",
        "link": "https://medium.com/daangn/%EA%B1%B4%EA%B0%95%ED%95%9C-seo%EB%A1%9C-%EC%84%B1%EC%9E%A5%ED%95%98%EB%8A%94-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-bc858a86c34b?source=rss----4505f82a2dbd---4",
        "pubDate": "Thu, 06 Mar 2025 06:14:43 GMT",
        "content:encoded": "<p>안녕하세요, 당근 프로덕트 디자이너 Ina입니다.</p><p>당근의 웹사이트를 알고 계신가요? 당근 웹사이트에서는 당근의 다양한 서비스를 앱 설치 없이도 만나볼 수 있는데요. 사용자들에게 당근의 매력을 알리는 중요한 창구예요.</p><ul><li>당근 웹사이트: <a href=\"https://www.daangn.com/\">https://www.daangn.com/</a></li><li>Karrot 글로벌 웹사이트(캐나다): <a href=\"https://www.karrotmarket.com/ca/\">https://www.karrotmarket.com/ca/</a></li><li>Karrot 글로벌 웹사이트(일본): <a href=\"https://www.karrotmarket.com/jp/\">https://www.karrotmarket.com/jp/</a></li></ul><p>이번 글에서는 당근의 글로벌 서비스 Karrot의 사용자들이 웹에서도 당근을 쉽게 만날 수 있도록, 북미와 일본 지역을 대상으로 검색 엔진 최적화(SEO)를 강화하고 <strong>자연스럽게 앱 설치로 이어지는 매물 중심 탐색 경험을 개선한 웹사이트 프로젝트를 공유해보려고 해요.</strong></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6hpVVY1P9nlxBdGGR9FSsg.png\" /></figure><h4>SEO란 무엇일까요?</h4><p>SEO(Search Engine Optimization)는 검색 엔진 최적화를 의미해요. 구글이나 네이버 같은 검색엔진에서 사용자가 원하는 정보를 검색했을 때, 당근의 웹사이트가 상단에 노출되도록 만드는 작업이에요.</p><p>예를 들어, “중고 아이폰 15”라는 키워드를 검색했을 때 당근 웹사이트가 검색 결과 첫 페이지에 노출된다면, 더 많은 사람들이 사이트를 방문하게 될 거예요. 이는 곧 서비스 성장으로도 이어지겠죠.</p><p>즉, SEO는 검색 결과에서의 노출뿐만 아니라 <strong>사용자와의 연결을 강화</strong>하는 필수 전략이라고 볼 수 있어요.</p><h3>SEO를 위한 유저 경험 만들기</h3><p>이 프로젝트의 핵심은 <strong>당근 웹사이트의 검색 랭킹</strong>을 높이기 위해, 다음 세 가지 요소를 충족시키는 것이었어요:</p><ul><li><strong>관련성(Relevance)</strong>: 사용자가 실제로 원하는 키워드와 유용한 콘텐츠 제공</li><li><strong>품질(Quality)</strong>: 신뢰도를 높이는 양질의 콘텐츠 및 백링크</li><li><strong>사용성(Usability)</strong>: 모바일 친화성, 페이지 속도, 보안 등 사용자 중심의 사이트 환경</li></ul><h4><strong><em>위와 같은 기술적인 SEO 목표를 달성하면서, 동시에 사용자 만족을 높이기 위해선 어떤 경험이 필요할까요?</em></strong></h4><p>저는 이 문제를 해결하기 위해 당근의 디자인 원칙 세 가지와 검색 랭킹을 높이기 위한 기술적 솔루션 세 가지를 매칭해보고자 했어요.</p><ol><li><strong>연결된 경험 — 관련성(Relevance)</strong></li><li><strong>직관적인 경험 — 품질(Quality)</strong></li><li><strong>사용자를 위한 개선 — 사용성(Usability)</strong></li></ol><blockquote><em>(참고) 당근의 디자인 원칙 7가지<br>1. 연결된 경험<br>2. 사용자를 위한 개선<br>3. 직관적인 경험<br>4. 하나의 화면 하나의 목표<br>5. 단순한 시각 요소<br>6. 적절한 피드백<br>7. 간결한 문구</em></blockquote><h3>1. 관련성(Relevance)을 위해 ‘연결된 경험’을 제공해요</h3><h4><strong>맥락에 맞는 </strong><strong>키워드를 배치해요</strong></h4><ul><li>사용자들이 실제로 많이 검색하는 키워드를 자연스럽게 배치하고자 검색 결과 페이지에 필터를 추가했어요.</li><li>필터는 탐색 편의를 높여요. 동시에 필터에 포함된 키워드가 검색 결과에도 노출되죠. 따라서 사용자 경험과 SEO 모두에 긍정적인 영향을 줘요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*utty1Y7FDyU9LqRHRb169Q.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ezS900QS3XcUScvsCfRNpg.png\" /></figure><ul><li>그 외에도 검색창 아래에 인기 키워드를 배치하는 등 키워드가 노출되는 곳을 다양하게 늘려나가고자 했어요.</li></ul><h4><strong>지역 설정 기능을 제공해요</strong></h4><ul><li>당근을 떠올리면 가장 먼저 생각나는 ‘동네’ 키워드를 웹사이트에 녹여내기 위해, 동네 설정과 검색 기능을 추가했어요.</li><li>이를 통해 사용자는 동네에서 거래되는 물건을 쉽게 확인할 수 있게 되었어요. 또한 검색 엔진에서 ‘서초동’ + ‘소파’ 같은 지역 키워드를 함께 입력했을 때도 자연스럽게 당근 웹사이트를 만나볼 수 있게 되었어요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*nhw3M6SFGKu8Qg_et69VqQ.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OZpQ_UzxoUN2wJ4xJbO80g.png\" /></figure><h3>2. 품질(Quality)을 위해 ‘직관적인 경험’을 제공해요</h3><h4><strong>카테고리 목록을 추가해요</strong></h4><ul><li>글로벌 Karrot은 중고거래 서비스만 제공하고 있어요. 그래서 <strong>카테고리 페이지</strong>를 추가해 사용자들이 어떤 카테고리가 있는지 한눈에 파악하도록 돕고, 카테고리 자체로도 검색 결과가 보일 수 있도록 개선했어요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*t61LT3GrCN0dQKxQMW6laQ.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KXD3t8Xes4vWH5qNrXy1YA.png\" /><figcaption>카테고리 자체가 검색 결과가 되도록 노출하기</figcaption></figure><ul><li>카테고리도 하나의 검색 결과로 만들며 검색 엔진에 노출되도록 개선했어요</li></ul><h4>브레드크럼(Breadcrumb)을 추가해요</h4><ul><li>“홈 &gt; 부동산 &gt; 매물”처럼 현재 위치와 다음 동선을 한눈에 파악할 수 있도록 <strong>내비게이션 흐름</strong>을 구성했어요.</li><li>브레드크럼(Breadcrumb)은 사이트 품질을 높여요. 동시에 사용자에게 <strong>지금 어느 페이지에 있고</strong> <strong>이전에 어떤 페이지를 거쳤는지</strong>를 명확히 알려줘, <strong>직관적인 탐색 경험</strong>을 강화해요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*D_50WOxSsYjQ1O57NjH7yg.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8kQUy1s1Azgd8ESOL2OEsw.png\" /></figure><h3>3. 사용성(Usability)을 위해 사용자를 위한 개선을 만들어요</h3><h4>반응형 디자인</h4><ul><li>글로벌의 다양한 디바이스 환경을 고려해, 화면 크기에 따른 배치·컴포넌트를 6가지 브레이크포인트로 정교하게 설계했어요. <br>그 결과, 모바일 디바이스·태블릿·웹 등 다양한 환경에서도 웹사이트를 불편함 없이 이용할 수 있게 되어, 사용성(Usability)이 크게 향상됐어요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8X9cuCAS4FrJL4lyauhG4g.png\" /></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*YpSRQT7bpxXvKqdbicW2XQ.png\" /></figure><h3>결과</h3><p>배포 한 달 이후의 결과예요</p><ul><li>🇨🇦 북미(캐나다): Impression(노출) 약 <strong>20배 성장</strong>, 클릭이 <strong>2배</strong> <strong>성장</strong>했어요.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*vKNSI7gpgFBJXfxvhEktVw.png\" /><figcaption>배포 이후의 성장 그래프</figcaption></figure><ul><li>🇰🇷 한국 (24년 11월 초에 동일한 UX/UI로 개편) : 월 접속자 수 약 4<strong>3%</strong> 상승했어요. (기존 426만 → <strong>610만</strong>)</li></ul><h4>마치며</h4><p>이번 프로젝트는 ‘관련성(Relevance)’, ‘품질(Quality)’, ‘사용성(Usability)’의 세 가지 핵심 요소를 사용자 중심의 디자인으로 풀어낸 SEO 전략으로, 당근의 웹사이트가 <strong>더 많은 사용자에게 노출되고 건강하게 성장</strong>할 수 있는 발판을 마련한 프로젝트라 뜻깊게 참여할 수 있었어요.</p><p>이 프로젝트에 함께해 준 토니, 리바이, 리아, 헤일리, 해나, 브랜딩팀 리지, 쿄, 유니와 이어서 웹사이트를 널리 알리는데 애써주시는 SEO Growth 팀에게 응원과 감사의 마음을 전해요!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bc858a86c34b\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/daangn/%EA%B1%B4%EA%B0%95%ED%95%9C-seo%EB%A1%9C-%EC%84%B1%EC%9E%A5%ED%95%98%EB%8A%94-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-bc858a86c34b\">건강한 SEO로 성장하는 웹사이트 만들기</a> was originally published in <a href=\"https://medium.com/daangn\">당근 테크 블로그</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>",
        "content:encodedSnippet": "안녕하세요, 당근 프로덕트 디자이너 Ina입니다.\n당근의 웹사이트를 알고 계신가요? 당근 웹사이트에서는 당근의 다양한 서비스를 앱 설치 없이도 만나볼 수 있는데요. 사용자들에게 당근의 매력을 알리는 중요한 창구예요.\n\n당근 웹사이트: https://www.daangn.com/\nKarrot 글로벌 웹사이트(캐나다): https://www.karrotmarket.com/ca/\nKarrot 글로벌 웹사이트(일본): https://www.karrotmarket.com/jp/\n\n이번 글에서는 당근의 글로벌 서비스 Karrot의 사용자들이 웹에서도 당근을 쉽게 만날 수 있도록, 북미와 일본 지역을 대상으로 검색 엔진 최적화(SEO)를 강화하고 자연스럽게 앱 설치로 이어지는 매물 중심 탐색 경험을 개선한 웹사이트 프로젝트를 공유해보려고 해요.\n\nSEO란 무엇일까요?\nSEO(Search Engine Optimization)는 검색 엔진 최적화를 의미해요. 구글이나 네이버 같은 검색엔진에서 사용자가 원하는 정보를 검색했을 때, 당근의 웹사이트가 상단에 노출되도록 만드는 작업이에요.\n예를 들어, “중고 아이폰 15”라는 키워드를 검색했을 때 당근 웹사이트가 검색 결과 첫 페이지에 노출된다면, 더 많은 사람들이 사이트를 방문하게 될 거예요. 이는 곧 서비스 성장으로도 이어지겠죠.\n즉, SEO는 검색 결과에서의 노출뿐만 아니라 사용자와의 연결을 강화하는 필수 전략이라고 볼 수 있어요.\nSEO를 위한 유저 경험 만들기\n이 프로젝트의 핵심은 당근 웹사이트의 검색 랭킹을 높이기 위해, 다음 세 가지 요소를 충족시키는 것이었어요:\n\n관련성(Relevance): 사용자가 실제로 원하는 키워드와 유용한 콘텐츠 제공\n품질(Quality): 신뢰도를 높이는 양질의 콘텐츠 및 백링크\n사용성(Usability): 모바일 친화성, 페이지 속도, 보안 등 사용자 중심의 사이트 환경\n\n위와 같은 기술적인 SEO 목표를 달성하면서, 동시에 사용자 만족을 높이기 위해선 어떤 경험이 필요할까요?\n저는 이 문제를 해결하기 위해 당근의 디자인 원칙 세 가지와 검색 랭킹을 높이기 위한 기술적 솔루션 세 가지를 매칭해보고자 했어요.\n\n연결된 경험 — 관련성(Relevance)\n직관적인 경험 — 품질(Quality)\n사용자를 위한 개선 — 사용성(Usability)\n\n(참고) 당근의 디자인 원칙 7가지\n1. 연결된 경험\n2. 사용자를 위한 개선\n3. 직관적인 경험\n4. 하나의 화면 하나의 목표\n5. 단순한 시각 요소\n6. 적절한 피드백\n7. 간결한 문구\n1. 관련성(Relevance)을 위해 ‘연결된 경험’을 제공해요\n맥락에 맞는 키워드를 배치해요\n\n사용자들이 실제로 많이 검색하는 키워드를 자연스럽게 배치하고자 검색 결과 페이지에 필터를 추가했어요.\n필터는 탐색 편의를 높여요. 동시에 필터에 포함된 키워드가 검색 결과에도 노출되죠. 따라서 사용자 경험과 SEO 모두에 긍정적인 영향을 줘요.\n\n그 외에도 검색창 아래에 인기 키워드를 배치하는 등 키워드가 노출되는 곳을 다양하게 늘려나가고자 했어요.\n\n지역 설정 기능을 제공해요\n\n당근을 떠올리면 가장 먼저 생각나는 ‘동네’ 키워드를 웹사이트에 녹여내기 위해, 동네 설정과 검색 기능을 추가했어요.\n이를 통해 사용자는 동네에서 거래되는 물건을 쉽게 확인할 수 있게 되었어요. 또한 검색 엔진에서 ‘서초동’ + ‘소파’ 같은 지역 키워드를 함께 입력했을 때도 자연스럽게 당근 웹사이트를 만나볼 수 있게 되었어요.\n\n2. 품질(Quality)을 위해 ‘직관적인 경험’을 제공해요\n카테고리 목록을 추가해요\n\n글로벌 Karrot은 중고거래 서비스만 제공하고 있어요. 그래서 카테고리 페이지를 추가해 사용자들이 어떤 카테고리가 있는지 한눈에 파악하도록 돕고, 카테고리 자체로도 검색 결과가 보일 수 있도록 개선했어요.\n카테고리 자체가 검색 결과가 되도록 노출하기\n카테고리도 하나의 검색 결과로 만들며 검색 엔진에 노출되도록 개선했어요\n\n브레드크럼(Breadcrumb)을 추가해요\n\n“홈 > 부동산 > 매물”처럼 현재 위치와 다음 동선을 한눈에 파악할 수 있도록 내비게이션 흐름을 구성했어요.\n브레드크럼(Breadcrumb)은 사이트 품질을 높여요. 동시에 사용자에게 지금 어느 페이지에 있고 이전에 어떤 페이지를 거쳤는지를 명확히 알려줘, 직관적인 탐색 경험을 강화해요.\n\n3. 사용성(Usability)을 위해 사용자를 위한 개선을 만들어요\n반응형 디자인\n\n글로벌의 다양한 디바이스 환경을 고려해, 화면 크기에 따른 배치·컴포넌트를 6가지 브레이크포인트로 정교하게 설계했어요. \n그 결과, 모바일 디바이스·태블릿·웹 등 다양한 환경에서도 웹사이트를 불편함 없이 이용할 수 있게 되어, 사용성(Usability)이 크게 향상됐어요.\n\n결과\n배포 한 달 이후의 결과예요\n\n🇨🇦 북미(캐나다): Impression(노출) 약 20배 성장, 클릭이 2배 성장했어요.\n배포 이후의 성장 그래프\n🇰🇷 한국 (24년 11월 초에 동일한 UX/UI로 개편) : 월 접속자 수 약 43% 상승했어요. (기존 426만 → 610만)\n\n마치며\n이번 프로젝트는 ‘관련성(Relevance)’, ‘품질(Quality)’, ‘사용성(Usability)’의 세 가지 핵심 요소를 사용자 중심의 디자인으로 풀어낸 SEO 전략으로, 당근의 웹사이트가 더 많은 사용자에게 노출되고 건강하게 성장할 수 있는 발판을 마련한 프로젝트라 뜻깊게 참여할 수 있었어요.\n이 프로젝트에 함께해 준 토니, 리바이, 리아, 헤일리, 해나, 브랜딩팀 리지, 쿄, 유니와 이어서 웹사이트를 널리 알리는데 애써주시는 SEO Growth 팀에게 응원과 감사의 마음을 전해요!\n\n건강한 SEO로 성장하는 웹사이트 만들기 was originally published in 당근 테크 블로그 on Medium, where people are continuing the conversation by highlighting and responding to this story.",
        "dc:creator": "Ina Jeon",
        "guid": "https://medium.com/p/bc858a86c34b",
        "categories": [
          "design",
          "product-design",
          "seo",
          "ux-design",
          "web-design"
        ],
        "isoDate": "2025-03-06T06:14:43.000Z"
      }
    ]
  }
]